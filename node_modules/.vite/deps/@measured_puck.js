import {
  require_jsx_runtime
} from "./chunk-KSMF3YND.js";
import {
  require_react_dom
} from "./chunk-RIVBVKMB.js";
import {
  __commonJS,
  __require,
  __toESM,
  require_react
} from "./chunk-5PP2P2BA.js";

// node_modules/flat/index.js
var require_flat = __commonJS({
  "node_modules/flat/index.js"(exports, module) {
    module.exports = flatten3;
    flatten3.flatten = flatten3;
    flatten3.unflatten = unflatten2;
    function isBuffer(obj) {
      return obj && obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function keyIdentity(key) {
      return key;
    }
    function flatten3(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const maxDepth = opts.maxDepth;
      const transformKey = opts.transformKey || keyIdentity;
      const output = {};
      function step(object, prev, currentDepth) {
        currentDepth = currentDepth || 1;
        Object.keys(object).forEach(function(key) {
          const value = object[key];
          const isarray = opts.safe && Array.isArray(value);
          const type = Object.prototype.toString.call(value);
          const isbuffer = isBuffer(value);
          const isobject = type === "[object Object]" || type === "[object Array]";
          const newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
          if (!isarray && !isbuffer && isobject && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) {
            return step(value, newKey, currentDepth + 1);
          }
          output[newKey] = value;
        });
      }
      step(target);
      return output;
    }
    function unflatten2(target, opts) {
      opts = opts || {};
      const delimiter = opts.delimiter || ".";
      const overwrite = opts.overwrite || false;
      const transformKey = opts.transformKey || keyIdentity;
      const result = {};
      const isbuffer = isBuffer(target);
      if (isbuffer || Object.prototype.toString.call(target) !== "[object Object]") {
        return target;
      }
      function getkey(key) {
        const parsedKey = Number(key);
        return isNaN(parsedKey) || key.indexOf(".") !== -1 || opts.object ? key : parsedKey;
      }
      function addKeys(keyPrefix, recipient, target2) {
        return Object.keys(target2).reduce(function(result2, key) {
          result2[keyPrefix + delimiter + key] = target2[key];
          return result2;
        }, recipient);
      }
      function isEmpty(val) {
        const type = Object.prototype.toString.call(val);
        const isArray = type === "[object Array]";
        const isObject = type === "[object Object]";
        if (!val) {
          return true;
        } else if (isArray) {
          return !val.length;
        } else if (isObject) {
          return !Object.keys(val).length;
        }
      }
      target = Object.keys(target).reduce(function(result2, key) {
        const type = Object.prototype.toString.call(target[key]);
        const isObject = type === "[object Object]" || type === "[object Array]";
        if (!isObject || isEmpty(target[key])) {
          result2[key] = target[key];
          return result2;
        } else {
          return addKeys(
            key,
            result2,
            flatten3(target[key], opts)
          );
        }
      }, {});
      Object.keys(target).forEach(function(key) {
        const split = key.split(delimiter).map(transformKey);
        let key1 = getkey(split.shift());
        let key2 = getkey(split[0]);
        let recipient = result;
        while (key2 !== void 0) {
          if (key1 === "__proto__") {
            return;
          }
          const type = Object.prototype.toString.call(recipient[key1]);
          const isobject = type === "[object Object]" || type === "[object Array]";
          if (!overwrite && !isobject && typeof recipient[key1] !== "undefined") {
            return;
          }
          if (overwrite && !isobject || !overwrite && recipient[key1] == null) {
            recipient[key1] = typeof key2 === "number" && !opts.object ? [] : {};
          }
          recipient = recipient[key1];
          if (split.length > 0) {
            key1 = getkey(split.shift());
            key2 = getkey(split[0]);
          }
        }
        recipient[key1] = unflatten2(target[key], opts);
      });
      return result;
    }
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a2, b2) {
      if (a2 === b2)
        return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor)
          return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2]))
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf)
          return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString)
          return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length)
          return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i2]))
            return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal(a2[key], b2[key]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !function(e3) {
      var t3;
      "object" == typeof exports ? module.exports = e3() : "function" == typeof define && define.amd ? define(e3) : ("undefined" != typeof window ? t3 = window : "undefined" != typeof global ? t3 = global : "undefined" != typeof self && (t3 = self), t3.objectHash = e3());
    }(function() {
      return function r3(o2, i2, u3) {
        function s2(n3, e4) {
          if (!i2[n3]) {
            if (!o2[n3]) {
              var t3 = "function" == typeof __require && __require;
              if (!e4 && t3)
                return t3(n3, true);
              if (a2)
                return a2(n3, true);
              throw new Error("Cannot find module '" + n3 + "'");
            }
            e4 = i2[n3] = { exports: {} };
            o2[n3][0].call(e4.exports, function(e5) {
              var t4 = o2[n3][1][e5];
              return s2(t4 || e5);
            }, e4, e4.exports, r3, o2, i2, u3);
          }
          return i2[n3].exports;
        }
        for (var a2 = "function" == typeof __require && __require, e3 = 0; e3 < u3.length; e3++)
          s2(u3[e3]);
        return s2;
      }({ 1: [function(w2, b2, m) {
        !(function(e3, n3, s2, c3, d2, h2, p2, g2, y2) {
          "use strict";
          var r3 = w2("crypto");
          function t3(e4, t4) {
            t4 = u3(e4, t4);
            var n4;
            return void 0 === (n4 = "passthrough" !== t4.algorithm ? r3.createHash(t4.algorithm) : new l2()).write && (n4.write = n4.update, n4.end = n4.update), f3(t4, n4).dispatch(e4), n4.update || n4.end(""), n4.digest ? n4.digest("buffer" === t4.encoding ? void 0 : t4.encoding) : (e4 = n4.read(), "buffer" !== t4.encoding ? e4.toString(t4.encoding) : e4);
          }
          (m = b2.exports = t3).sha1 = function(e4) {
            return t3(e4);
          }, m.keys = function(e4) {
            return t3(e4, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m.MD5 = function(e4) {
            return t3(e4, { algorithm: "md5", encoding: "hex" });
          }, m.keysMD5 = function(e4) {
            return t3(e4, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o2 = r3.getHashes ? r3.getHashes().slice() : ["sha1", "md5"], i2 = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u3(e4, t4) {
            var n4 = {};
            if (n4.algorithm = (t4 = t4 || {}).algorithm || "sha1", n4.encoding = t4.encoding || "hex", n4.excludeValues = !!t4.excludeValues, n4.algorithm = n4.algorithm.toLowerCase(), n4.encoding = n4.encoding.toLowerCase(), n4.ignoreUnknown = true === t4.ignoreUnknown, n4.respectType = false !== t4.respectType, n4.respectFunctionNames = false !== t4.respectFunctionNames, n4.respectFunctionProperties = false !== t4.respectFunctionProperties, n4.unorderedArrays = true === t4.unorderedArrays, n4.unorderedSets = false !== t4.unorderedSets, n4.unorderedObjects = false !== t4.unorderedObjects, n4.replacer = t4.replacer || void 0, n4.excludeKeys = t4.excludeKeys || void 0, void 0 === e4)
              throw new Error("Object argument required.");
            for (var r4 = 0; r4 < o2.length; ++r4)
              o2[r4].toLowerCase() === n4.algorithm.toLowerCase() && (n4.algorithm = o2[r4]);
            if (-1 === o2.indexOf(n4.algorithm))
              throw new Error('Algorithm "' + n4.algorithm + '"  not supported. supported values: ' + o2.join(", "));
            if (-1 === i2.indexOf(n4.encoding) && "passthrough" !== n4.algorithm)
              throw new Error('Encoding "' + n4.encoding + '"  not supported. supported values: ' + i2.join(", "));
            return n4;
          }
          function a2(e4) {
            if ("function" == typeof e4)
              return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e4));
          }
          function f3(o3, t4, i3) {
            i3 = i3 || [];
            function u4(e4) {
              return t4.update ? t4.update(e4, "utf8") : t4.write(e4, "utf8");
            }
            return { dispatch: function(e4) {
              return this["_" + (null === (e4 = o3.replacer ? o3.replacer(e4) : e4) ? "null" : typeof e4)](e4);
            }, _object: function(t5) {
              var n4, e4 = Object.prototype.toString.call(t5), r4 = /\[object (.*)\]/i.exec(e4);
              r4 = (r4 = r4 ? r4[1] : "unknown:[" + e4 + "]").toLowerCase();
              if (0 <= (e4 = i3.indexOf(t5)))
                return this.dispatch("[CIRCULAR:" + e4 + "]");
              if (i3.push(t5), void 0 !== s2 && s2.isBuffer && s2.isBuffer(t5))
                return u4("buffer:"), u4(t5);
              if ("object" === r4 || "function" === r4 || "asyncfunction" === r4)
                return e4 = Object.keys(t5), o3.unorderedObjects && (e4 = e4.sort()), false === o3.respectType || a2(t5) || e4.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e4 = e4.filter(function(e5) {
                  return !o3.excludeKeys(e5);
                })), u4("object:" + e4.length + ":"), n4 = this, e4.forEach(function(e5) {
                  n4.dispatch(e5), u4(":"), o3.excludeValues || n4.dispatch(t5[e5]), u4(",");
                });
              if (!this["_" + r4]) {
                if (o3.ignoreUnknown)
                  return u4("[" + r4 + "]");
                throw new Error('Unknown object type "' + r4 + '"');
              }
              this["_" + r4](t5);
            }, _array: function(e4, t5) {
              t5 = void 0 !== t5 ? t5 : false !== o3.unorderedArrays;
              var n4 = this;
              if (u4("array:" + e4.length + ":"), !t5 || e4.length <= 1)
                return e4.forEach(function(e5) {
                  return n4.dispatch(e5);
                });
              var r4 = [], t5 = e4.map(function(e5) {
                var t6 = new l2(), n5 = i3.slice();
                return f3(o3, t6, n5).dispatch(e5), r4 = r4.concat(n5.slice(i3.length)), t6.read().toString();
              });
              return i3 = i3.concat(r4), t5.sort(), this._array(t5, false);
            }, _date: function(e4) {
              return u4("date:" + e4.toJSON());
            }, _symbol: function(e4) {
              return u4("symbol:" + e4.toString());
            }, _error: function(e4) {
              return u4("error:" + e4.toString());
            }, _boolean: function(e4) {
              return u4("bool:" + e4.toString());
            }, _string: function(e4) {
              u4("string:" + e4.length + ":"), u4(e4.toString());
            }, _function: function(e4) {
              u4("fn:"), a2(e4) ? this.dispatch("[native]") : this.dispatch(e4.toString()), false !== o3.respectFunctionNames && this.dispatch("function-name:" + String(e4.name)), o3.respectFunctionProperties && this._object(e4);
            }, _number: function(e4) {
              return u4("number:" + e4.toString());
            }, _xml: function(e4) {
              return u4("xml:" + e4.toString());
            }, _null: function() {
              return u4("Null");
            }, _undefined: function() {
              return u4("Undefined");
            }, _regexp: function(e4) {
              return u4("regex:" + e4.toString());
            }, _uint8array: function(e4) {
              return u4("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _uint8clampedarray: function(e4) {
              return u4("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _int8array: function(e4) {
              return u4("int8array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _uint16array: function(e4) {
              return u4("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _int16array: function(e4) {
              return u4("int16array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _uint32array: function(e4) {
              return u4("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _int32array: function(e4) {
              return u4("int32array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _float32array: function(e4) {
              return u4("float32array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _float64array: function(e4) {
              return u4("float64array:"), this.dispatch(Array.prototype.slice.call(e4));
            }, _arraybuffer: function(e4) {
              return u4("arraybuffer:"), this.dispatch(new Uint8Array(e4));
            }, _url: function(e4) {
              return u4("url:" + e4.toString());
            }, _map: function(e4) {
              u4("map:");
              e4 = Array.from(e4);
              return this._array(e4, false !== o3.unorderedSets);
            }, _set: function(e4) {
              u4("set:");
              e4 = Array.from(e4);
              return this._array(e4, false !== o3.unorderedSets);
            }, _file: function(e4) {
              return u4("file:"), this.dispatch([e4.name, e4.size, e4.type, e4.lastModfied]);
            }, _blob: function() {
              if (o3.ignoreUnknown)
                return u4("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u4("domwindow");
            }, _bigint: function(e4) {
              return u4("bigint:" + e4.toString());
            }, _process: function() {
              return u4("process");
            }, _timer: function() {
              return u4("timer");
            }, _pipe: function() {
              return u4("pipe");
            }, _tcp: function() {
              return u4("tcp");
            }, _udp: function() {
              return u4("udp");
            }, _tty: function() {
              return u4("tty");
            }, _statwatcher: function() {
              return u4("statwatcher");
            }, _securecontext: function() {
              return u4("securecontext");
            }, _connection: function() {
              return u4("connection");
            }, _zlib: function() {
              return u4("zlib");
            }, _context: function() {
              return u4("context");
            }, _nodescript: function() {
              return u4("nodescript");
            }, _httpparser: function() {
              return u4("httpparser");
            }, _dataview: function() {
              return u4("dataview");
            }, _signal: function() {
              return u4("signal");
            }, _fsevent: function() {
              return u4("fsevent");
            }, _tlswrap: function() {
              return u4("tlswrap");
            } };
          }
          function l2() {
            return { buf: "", write: function(e4) {
              this.buf += e4;
            }, end: function(e4) {
              this.buf += e4;
            }, read: function() {
              return this.buf;
            } };
          }
          m.writeToStream = function(e4, t4, n4) {
            return void 0 === n4 && (n4 = t4, t4 = {}), f3(t4 = u3(e4, t4), n4).dispatch(e4);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e3, t3, f3) {
        !(function(e4, t4, n3, r3, o2, i2, u3, s2, a2) {
          !function(e5) {
            "use strict";
            var a3 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t5 = "+".charCodeAt(0), n4 = "/".charCodeAt(0), r4 = "0".charCodeAt(0), o3 = "a".charCodeAt(0), i3 = "A".charCodeAt(0), u4 = "-".charCodeAt(0), s3 = "_".charCodeAt(0);
            function f4(e6) {
              e6 = e6.charCodeAt(0);
              return e6 === t5 || e6 === u4 ? 62 : e6 === n4 || e6 === s3 ? 63 : e6 < r4 ? -1 : e6 < r4 + 10 ? e6 - r4 + 26 + 26 : e6 < i3 + 26 ? e6 - i3 : e6 < o3 + 26 ? e6 - o3 + 26 : void 0;
            }
            e5.toByteArray = function(e6) {
              var t6, n5;
              if (0 < e6.length % 4)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r5 = e6.length, r5 = "=" === e6.charAt(r5 - 2) ? 2 : "=" === e6.charAt(r5 - 1) ? 1 : 0, o4 = new a3(3 * e6.length / 4 - r5), i4 = 0 < r5 ? e6.length - 4 : e6.length, u5 = 0;
              function s4(e7) {
                o4[u5++] = e7;
              }
              for (t6 = 0; t6 < i4; t6 += 4, 0)
                s4((16711680 & (n5 = f4(e6.charAt(t6)) << 18 | f4(e6.charAt(t6 + 1)) << 12 | f4(e6.charAt(t6 + 2)) << 6 | f4(e6.charAt(t6 + 3)))) >> 16), s4((65280 & n5) >> 8), s4(255 & n5);
              return 2 == r5 ? s4(255 & (n5 = f4(e6.charAt(t6)) << 2 | f4(e6.charAt(t6 + 1)) >> 4)) : 1 == r5 && (s4((n5 = f4(e6.charAt(t6)) << 10 | f4(e6.charAt(t6 + 1)) << 4 | f4(e6.charAt(t6 + 2)) >> 2) >> 8 & 255), s4(255 & n5)), o4;
            }, e5.fromByteArray = function(e6) {
              var t6, n5, r5, o4, i4 = e6.length % 3, u5 = "";
              function s4(e7) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e7);
              }
              for (t6 = 0, r5 = e6.length - i4; t6 < r5; t6 += 3)
                n5 = (e6[t6] << 16) + (e6[t6 + 1] << 8) + e6[t6 + 2], u5 += s4((o4 = n5) >> 18 & 63) + s4(o4 >> 12 & 63) + s4(o4 >> 6 & 63) + s4(63 & o4);
              switch (i4) {
                case 1:
                  u5 = (u5 += s4((n5 = e6[e6.length - 1]) >> 2)) + s4(n5 << 4 & 63) + "==";
                  break;
                case 2:
                  u5 = (u5 = (u5 += s4((n5 = (e6[e6.length - 2] << 8) + e6[e6.length - 1]) >> 10)) + s4(n5 >> 4 & 63)) + s4(n5 << 2 & 63) + "=";
              }
              return u5;
            };
          }(void 0 === f3 ? this.base64js = {} : f3);
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e3, H) {
        !(function(e4, n3, f3, r3, h2, p2, g2, y2, w2) {
          var a2 = O("base64-js"), i2 = O("ieee754");
          function f3(e5, t4, n4) {
            if (!(this instanceof f3))
              return new f3(e5, t4, n4);
            var r4, o3, i3, u4, s3 = typeof e5;
            if ("base64" === t4 && "string" == s3)
              for (e5 = (u4 = e5).trim ? u4.trim() : u4.replace(/^\s+|\s+$/g, ""); e5.length % 4 != 0; )
                e5 += "=";
            if ("number" == s3)
              r4 = j(e5);
            else if ("string" == s3)
              r4 = f3.byteLength(e5, t4);
            else {
              if ("object" != s3)
                throw new Error("First argument needs to be a number, array or string.");
              r4 = j(e5.length);
            }
            if (f3._useTypedArrays ? o3 = f3._augment(new Uint8Array(r4)) : ((o3 = this).length = r4, o3._isBuffer = true), f3._useTypedArrays && "number" == typeof e5.byteLength)
              o3._set(e5);
            else if (C(u4 = e5) || f3.isBuffer(u4) || u4 && "object" == typeof u4 && "number" == typeof u4.length)
              for (i3 = 0; i3 < r4; i3++)
                f3.isBuffer(e5) ? o3[i3] = e5.readUInt8(i3) : o3[i3] = e5[i3];
            else if ("string" == s3)
              o3.write(e5, 0, t4);
            else if ("number" == s3 && !f3._useTypedArrays && !n4)
              for (i3 = 0; i3 < r4; i3++)
                o3[i3] = 0;
            return o3;
          }
          function b2(e5, t4, n4, r4) {
            return f3._charsWritten = c3(function(e6) {
              for (var t5 = [], n5 = 0; n5 < e6.length; n5++)
                t5.push(255 & e6.charCodeAt(n5));
              return t5;
            }(t4), e5, n4, r4);
          }
          function m(e5, t4, n4, r4) {
            return f3._charsWritten = c3(function(e6) {
              for (var t5, n5, r5 = [], o3 = 0; o3 < e6.length; o3++)
                n5 = e6.charCodeAt(o3), t5 = n5 >> 8, n5 = n5 % 256, r5.push(n5), r5.push(t5);
              return r5;
            }(t4), e5, n4, r4);
          }
          function v2(e5, t4, n4) {
            var r4 = "";
            n4 = Math.min(e5.length, n4);
            for (var o3 = t4; o3 < n4; o3++)
              r4 += String.fromCharCode(e5[o3]);
            return r4;
          }
          function o2(e5, t4, n4, r4) {
            r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 1 < e5.length, "Trying to read beyond buffer length"));
            var o3, r4 = e5.length;
            if (!(r4 <= t4))
              return n4 ? (o3 = e5[t4], t4 + 1 < r4 && (o3 |= e5[t4 + 1] << 8)) : (o3 = e5[t4] << 8, t4 + 1 < r4 && (o3 |= e5[t4 + 1])), o3;
          }
          function u3(e5, t4, n4, r4) {
            r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 3 < e5.length, "Trying to read beyond buffer length"));
            var o3, r4 = e5.length;
            if (!(r4 <= t4))
              return n4 ? (t4 + 2 < r4 && (o3 = e5[t4 + 2] << 16), t4 + 1 < r4 && (o3 |= e5[t4 + 1] << 8), o3 |= e5[t4], t4 + 3 < r4 && (o3 += e5[t4 + 3] << 24 >>> 0)) : (t4 + 1 < r4 && (o3 = e5[t4 + 1] << 16), t4 + 2 < r4 && (o3 |= e5[t4 + 2] << 8), t4 + 3 < r4 && (o3 |= e5[t4 + 3]), o3 += e5[t4] << 24 >>> 0), o3;
          }
          function _2(e5, t4, n4, r4) {
            if (r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 1 < e5.length, "Trying to read beyond buffer length")), !(e5.length <= t4))
              return r4 = o2(e5, t4, n4, true), 32768 & r4 ? -1 * (65535 - r4 + 1) : r4;
          }
          function E2(e5, t4, n4, r4) {
            if (r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(null != t4, "missing offset"), d2(t4 + 3 < e5.length, "Trying to read beyond buffer length")), !(e5.length <= t4))
              return r4 = u3(e5, t4, n4, true), 2147483648 & r4 ? -1 * (4294967295 - r4 + 1) : r4;
          }
          function I(e5, t4, n4, r4) {
            return r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(t4 + 3 < e5.length, "Trying to read beyond buffer length")), i2.read(e5, t4, n4, 23, 4);
          }
          function A(e5, t4, n4, r4) {
            return r4 || (d2("boolean" == typeof n4, "missing or invalid endian"), d2(t4 + 7 < e5.length, "Trying to read beyond buffer length")), i2.read(e5, t4, n4, 52, 8);
          }
          function s2(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 1 < e5.length, "trying to write beyond buffer length"), Y(t4, 65535));
            o3 = e5.length;
            if (!(o3 <= n4))
              for (var i3 = 0, u4 = Math.min(o3 - n4, 2); i3 < u4; i3++)
                e5[n4 + i3] = (t4 & 255 << 8 * (r4 ? i3 : 1 - i3)) >>> 8 * (r4 ? i3 : 1 - i3);
          }
          function l2(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 3 < e5.length, "trying to write beyond buffer length"), Y(t4, 4294967295));
            o3 = e5.length;
            if (!(o3 <= n4))
              for (var i3 = 0, u4 = Math.min(o3 - n4, 4); i3 < u4; i3++)
                e5[n4 + i3] = t4 >>> 8 * (r4 ? i3 : 3 - i3) & 255;
          }
          function B(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 1 < e5.length, "Trying to write beyond buffer length"), F(t4, 32767, -32768)), e5.length <= n4 || s2(e5, 0 <= t4 ? t4 : 65535 + t4 + 1, n4, r4, o3);
          }
          function L(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 3 < e5.length, "Trying to write beyond buffer length"), F(t4, 2147483647, -2147483648)), e5.length <= n4 || l2(e5, 0 <= t4 ? t4 : 4294967295 + t4 + 1, n4, r4, o3);
          }
          function U(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 3 < e5.length, "Trying to write beyond buffer length"), D(t4, 34028234663852886e22, -34028234663852886e22)), e5.length <= n4 || i2.write(e5, t4, n4, r4, 23, 4);
          }
          function x(e5, t4, n4, r4, o3) {
            o3 || (d2(null != t4, "missing value"), d2("boolean" == typeof r4, "missing or invalid endian"), d2(null != n4, "missing offset"), d2(n4 + 7 < e5.length, "Trying to write beyond buffer length"), D(t4, 17976931348623157e292, -17976931348623157e292)), e5.length <= n4 || i2.write(e5, t4, n4, r4, 52, 8);
          }
          H.Buffer = f3, H.SlowBuffer = f3, H.INSPECT_MAX_BYTES = 50, f3.poolSize = 8192, f3._useTypedArrays = function() {
            try {
              var e5 = new ArrayBuffer(0), t4 = new Uint8Array(e5);
              return t4.foo = function() {
                return 42;
              }, 42 === t4.foo() && "function" == typeof t4.subarray;
            } catch (e6) {
              return false;
            }
          }(), f3.isEncoding = function(e5) {
            switch (String(e5).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f3.isBuffer = function(e5) {
            return !(null == e5 || !e5._isBuffer);
          }, f3.byteLength = function(e5, t4) {
            var n4;
            switch (e5 += "", t4 || "utf8") {
              case "hex":
                n4 = e5.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n4 = T(e5).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n4 = e5.length;
                break;
              case "base64":
                n4 = M(e5).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n4 = 2 * e5.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n4;
          }, f3.concat = function(e5, t4) {
            if (d2(C(e5), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e5.length)
              return new f3(0);
            if (1 === e5.length)
              return e5[0];
            if ("number" != typeof t4)
              for (o3 = t4 = 0; o3 < e5.length; o3++)
                t4 += e5[o3].length;
            for (var n4 = new f3(t4), r4 = 0, o3 = 0; o3 < e5.length; o3++) {
              var i3 = e5[o3];
              i3.copy(n4, r4), r4 += i3.length;
            }
            return n4;
          }, f3.prototype.write = function(e5, t4, n4, r4) {
            isFinite(t4) ? isFinite(n4) || (r4 = n4, n4 = void 0) : (a3 = r4, r4 = t4, t4 = n4, n4 = a3), t4 = Number(t4) || 0;
            var o3, i3, u4, s3, a3 = this.length - t4;
            switch ((!n4 || a3 < (n4 = Number(n4))) && (n4 = a3), r4 = String(r4 || "utf8").toLowerCase()) {
              case "hex":
                o3 = function(e6, t5, n5, r5) {
                  n5 = Number(n5) || 0;
                  var o4 = e6.length - n5;
                  (!r5 || o4 < (r5 = Number(r5))) && (r5 = o4), d2((o4 = t5.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r5 && (r5 = o4 / 2);
                  for (var i4 = 0; i4 < r5; i4++) {
                    var u5 = parseInt(t5.substr(2 * i4, 2), 16);
                    d2(!isNaN(u5), "Invalid hex string"), e6[n5 + i4] = u5;
                  }
                  return f3._charsWritten = 2 * i4, i4;
                }(this, e5, t4, n4);
                break;
              case "utf8":
              case "utf-8":
                i3 = this, u4 = t4, s3 = n4, o3 = f3._charsWritten = c3(T(e5), i3, u4, s3);
                break;
              case "ascii":
              case "binary":
                o3 = b2(this, e5, t4, n4);
                break;
              case "base64":
                i3 = this, u4 = t4, s3 = n4, o3 = f3._charsWritten = c3(M(e5), i3, u4, s3);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o3 = m(this, e5, t4, n4);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o3;
          }, f3.prototype.toString = function(e5, t4, n4) {
            var r4, o3, i3, u4, s3 = this;
            if (e5 = String(e5 || "utf8").toLowerCase(), t4 = Number(t4) || 0, (n4 = void 0 !== n4 ? Number(n4) : s3.length) === t4)
              return "";
            switch (e5) {
              case "hex":
                r4 = function(e6, t5, n5) {
                  var r5 = e6.length;
                  (!t5 || t5 < 0) && (t5 = 0);
                  (!n5 || n5 < 0 || r5 < n5) && (n5 = r5);
                  for (var o4 = "", i4 = t5; i4 < n5; i4++)
                    o4 += k(e6[i4]);
                  return o4;
                }(s3, t4, n4);
                break;
              case "utf8":
              case "utf-8":
                r4 = function(e6, t5, n5) {
                  var r5 = "", o4 = "";
                  n5 = Math.min(e6.length, n5);
                  for (var i4 = t5; i4 < n5; i4++)
                    e6[i4] <= 127 ? (r5 += N(o4) + String.fromCharCode(e6[i4]), o4 = "") : o4 += "%" + e6[i4].toString(16);
                  return r5 + N(o4);
                }(s3, t4, n4);
                break;
              case "ascii":
              case "binary":
                r4 = v2(s3, t4, n4);
                break;
              case "base64":
                o3 = s3, u4 = n4, r4 = 0 === (i3 = t4) && u4 === o3.length ? a2.fromByteArray(o3) : a2.fromByteArray(o3.slice(i3, u4));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r4 = function(e6, t5, n5) {
                  for (var r5 = e6.slice(t5, n5), o4 = "", i4 = 0; i4 < r5.length; i4 += 2)
                    o4 += String.fromCharCode(r5[i4] + 256 * r5[i4 + 1]);
                  return o4;
                }(s3, t4, n4);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r4;
          }, f3.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f3.prototype.copy = function(e5, t4, n4, r4) {
            if (t4 = t4 || 0, (r4 = r4 || 0 === r4 ? r4 : this.length) !== (n4 = n4 || 0) && 0 !== e5.length && 0 !== this.length) {
              d2(n4 <= r4, "sourceEnd < sourceStart"), d2(0 <= t4 && t4 < e5.length, "targetStart out of bounds"), d2(0 <= n4 && n4 < this.length, "sourceStart out of bounds"), d2(0 <= r4 && r4 <= this.length, "sourceEnd out of bounds"), r4 > this.length && (r4 = this.length);
              var o3 = (r4 = e5.length - t4 < r4 - n4 ? e5.length - t4 + n4 : r4) - n4;
              if (o3 < 100 || !f3._useTypedArrays)
                for (var i3 = 0; i3 < o3; i3++)
                  e5[i3 + t4] = this[i3 + n4];
              else
                e5._set(this.subarray(n4, n4 + o3), t4);
            }
          }, f3.prototype.slice = function(e5, t4) {
            var n4 = this.length;
            if (e5 = S(e5, n4, 0), t4 = S(t4, n4, n4), f3._useTypedArrays)
              return f3._augment(this.subarray(e5, t4));
            for (var r4 = t4 - e5, o3 = new f3(r4, void 0, true), i3 = 0; i3 < r4; i3++)
              o3[i3] = this[i3 + e5];
            return o3;
          }, f3.prototype.get = function(e5) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e5);
          }, f3.prototype.set = function(e5, t4) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e5, t4);
          }, f3.prototype.readUInt8 = function(e5, t4) {
            if (t4 || (d2(null != e5, "missing offset"), d2(e5 < this.length, "Trying to read beyond buffer length")), !(e5 >= this.length))
              return this[e5];
          }, f3.prototype.readUInt16LE = function(e5, t4) {
            return o2(this, e5, true, t4);
          }, f3.prototype.readUInt16BE = function(e5, t4) {
            return o2(this, e5, false, t4);
          }, f3.prototype.readUInt32LE = function(e5, t4) {
            return u3(this, e5, true, t4);
          }, f3.prototype.readUInt32BE = function(e5, t4) {
            return u3(this, e5, false, t4);
          }, f3.prototype.readInt8 = function(e5, t4) {
            if (t4 || (d2(null != e5, "missing offset"), d2(e5 < this.length, "Trying to read beyond buffer length")), !(e5 >= this.length))
              return 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
          }, f3.prototype.readInt16LE = function(e5, t4) {
            return _2(this, e5, true, t4);
          }, f3.prototype.readInt16BE = function(e5, t4) {
            return _2(this, e5, false, t4);
          }, f3.prototype.readInt32LE = function(e5, t4) {
            return E2(this, e5, true, t4);
          }, f3.prototype.readInt32BE = function(e5, t4) {
            return E2(this, e5, false, t4);
          }, f3.prototype.readFloatLE = function(e5, t4) {
            return I(this, e5, true, t4);
          }, f3.prototype.readFloatBE = function(e5, t4) {
            return I(this, e5, false, t4);
          }, f3.prototype.readDoubleLE = function(e5, t4) {
            return A(this, e5, true, t4);
          }, f3.prototype.readDoubleBE = function(e5, t4) {
            return A(this, e5, false, t4);
          }, f3.prototype.writeUInt8 = function(e5, t4, n4) {
            n4 || (d2(null != e5, "missing value"), d2(null != t4, "missing offset"), d2(t4 < this.length, "trying to write beyond buffer length"), Y(e5, 255)), t4 >= this.length || (this[t4] = e5);
          }, f3.prototype.writeUInt16LE = function(e5, t4, n4) {
            s2(this, e5, t4, true, n4);
          }, f3.prototype.writeUInt16BE = function(e5, t4, n4) {
            s2(this, e5, t4, false, n4);
          }, f3.prototype.writeUInt32LE = function(e5, t4, n4) {
            l2(this, e5, t4, true, n4);
          }, f3.prototype.writeUInt32BE = function(e5, t4, n4) {
            l2(this, e5, t4, false, n4);
          }, f3.prototype.writeInt8 = function(e5, t4, n4) {
            n4 || (d2(null != e5, "missing value"), d2(null != t4, "missing offset"), d2(t4 < this.length, "Trying to write beyond buffer length"), F(e5, 127, -128)), t4 >= this.length || (0 <= e5 ? this.writeUInt8(e5, t4, n4) : this.writeUInt8(255 + e5 + 1, t4, n4));
          }, f3.prototype.writeInt16LE = function(e5, t4, n4) {
            B(this, e5, t4, true, n4);
          }, f3.prototype.writeInt16BE = function(e5, t4, n4) {
            B(this, e5, t4, false, n4);
          }, f3.prototype.writeInt32LE = function(e5, t4, n4) {
            L(this, e5, t4, true, n4);
          }, f3.prototype.writeInt32BE = function(e5, t4, n4) {
            L(this, e5, t4, false, n4);
          }, f3.prototype.writeFloatLE = function(e5, t4, n4) {
            U(this, e5, t4, true, n4);
          }, f3.prototype.writeFloatBE = function(e5, t4, n4) {
            U(this, e5, t4, false, n4);
          }, f3.prototype.writeDoubleLE = function(e5, t4, n4) {
            x(this, e5, t4, true, n4);
          }, f3.prototype.writeDoubleBE = function(e5, t4, n4) {
            x(this, e5, t4, false, n4);
          }, f3.prototype.fill = function(e5, t4, n4) {
            if (t4 = t4 || 0, n4 = n4 || this.length, d2("number" == typeof (e5 = "string" == typeof (e5 = e5 || 0) ? e5.charCodeAt(0) : e5) && !isNaN(e5), "value is not a number"), d2(t4 <= n4, "end < start"), n4 !== t4 && 0 !== this.length) {
              d2(0 <= t4 && t4 < this.length, "start out of bounds"), d2(0 <= n4 && n4 <= this.length, "end out of bounds");
              for (var r4 = t4; r4 < n4; r4++)
                this[r4] = e5;
            }
          }, f3.prototype.inspect = function() {
            for (var e5 = [], t4 = this.length, n4 = 0; n4 < t4; n4++)
              if (e5[n4] = k(this[n4]), n4 === H.INSPECT_MAX_BYTES) {
                e5[n4 + 1] = "...";
                break;
              }
            return "<Buffer " + e5.join(" ") + ">";
          }, f3.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array)
              throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f3._useTypedArrays)
              return new f3(this).buffer;
            for (var e5 = new Uint8Array(this.length), t4 = 0, n4 = e5.length; t4 < n4; t4 += 1)
              e5[t4] = this[t4];
            return e5.buffer;
          };
          var t3 = f3.prototype;
          function S(e5, t4, n4) {
            return "number" != typeof e5 ? n4 : t4 <= (e5 = ~~e5) ? t4 : 0 <= e5 || 0 <= (e5 += t4) ? e5 : 0;
          }
          function j(e5) {
            return (e5 = ~~Math.ceil(+e5)) < 0 ? 0 : e5;
          }
          function C(e5) {
            return (Array.isArray || function(e6) {
              return "[object Array]" === Object.prototype.toString.call(e6);
            })(e5);
          }
          function k(e5) {
            return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
          }
          function T(e5) {
            for (var t4 = [], n4 = 0; n4 < e5.length; n4++) {
              var r4 = e5.charCodeAt(n4);
              if (r4 <= 127)
                t4.push(e5.charCodeAt(n4));
              else
                for (var o3 = n4, i3 = (55296 <= r4 && r4 <= 57343 && n4++, encodeURIComponent(e5.slice(o3, n4 + 1)).substr(1).split("%")), u4 = 0; u4 < i3.length; u4++)
                  t4.push(parseInt(i3[u4], 16));
            }
            return t4;
          }
          function M(e5) {
            return a2.toByteArray(e5);
          }
          function c3(e5, t4, n4, r4) {
            for (var o3 = 0; o3 < r4 && !(o3 + n4 >= t4.length || o3 >= e5.length); o3++)
              t4[o3 + n4] = e5[o3];
            return o3;
          }
          function N(e5) {
            try {
              return decodeURIComponent(e5);
            } catch (e6) {
              return String.fromCharCode(65533);
            }
          }
          function Y(e5, t4) {
            d2("number" == typeof e5, "cannot write a non-number as a number"), d2(0 <= e5, "specified a negative value for writing an unsigned value"), d2(e5 <= t4, "value is larger than maximum value for type"), d2(Math.floor(e5) === e5, "value has a fractional component");
          }
          function F(e5, t4, n4) {
            d2("number" == typeof e5, "cannot write a non-number as a number"), d2(e5 <= t4, "value larger than maximum allowed value"), d2(n4 <= e5, "value smaller than minimum allowed value"), d2(Math.floor(e5) === e5, "value has a fractional component");
          }
          function D(e5, t4, n4) {
            d2("number" == typeof e5, "cannot write a non-number as a number"), d2(e5 <= t4, "value larger than maximum allowed value"), d2(n4 <= e5, "value smaller than minimum allowed value");
          }
          function d2(e5, t4) {
            if (!e5)
              throw new Error(t4 || "Failed assertion");
          }
          f3._augment = function(e5) {
            return e5._isBuffer = true, e5._get = e5.get, e5._set = e5.set, e5.get = t3.get, e5.set = t3.set, e5.write = t3.write, e5.toString = t3.toString, e5.toLocaleString = t3.toString, e5.toJSON = t3.toJSON, e5.copy = t3.copy, e5.slice = t3.slice, e5.readUInt8 = t3.readUInt8, e5.readUInt16LE = t3.readUInt16LE, e5.readUInt16BE = t3.readUInt16BE, e5.readUInt32LE = t3.readUInt32LE, e5.readUInt32BE = t3.readUInt32BE, e5.readInt8 = t3.readInt8, e5.readInt16LE = t3.readInt16LE, e5.readInt16BE = t3.readInt16BE, e5.readInt32LE = t3.readInt32LE, e5.readInt32BE = t3.readInt32BE, e5.readFloatLE = t3.readFloatLE, e5.readFloatBE = t3.readFloatBE, e5.readDoubleLE = t3.readDoubleLE, e5.readDoubleBE = t3.readDoubleBE, e5.writeUInt8 = t3.writeUInt8, e5.writeUInt16LE = t3.writeUInt16LE, e5.writeUInt16BE = t3.writeUInt16BE, e5.writeUInt32LE = t3.writeUInt32LE, e5.writeUInt32BE = t3.writeUInt32BE, e5.writeInt8 = t3.writeInt8, e5.writeInt16LE = t3.writeInt16LE, e5.writeInt16BE = t3.writeInt16BE, e5.writeInt32LE = t3.writeInt32LE, e5.writeInt32BE = t3.writeInt32BE, e5.writeFloatLE = t3.writeFloatLE, e5.writeFloatBE = t3.writeFloatBE, e5.writeDoubleLE = t3.writeDoubleLE, e5.writeDoubleBE = t3.writeDoubleBE, e5.fill = t3.fill, e5.inspect = t3.inspect, e5.toArrayBuffer = t3.toArrayBuffer, e5;
          };
        }).call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c3, d2, e3) {
        !(function(e4, t3, a2, n3, r3, o2, i2, u3, s2) {
          var a2 = c3("buffer").Buffer, f3 = 4, l2 = new a2(f3);
          l2.fill(0);
          d2.exports = { hash: function(e5, t4, n4, r4) {
            for (var o3 = t4(function(e6, t5) {
              e6.length % f3 != 0 && (n5 = e6.length + (f3 - e6.length % f3), e6 = a2.concat([e6, l2], n5));
              for (var n5, r5 = [], o4 = t5 ? e6.readInt32BE : e6.readInt32LE, i4 = 0; i4 < e6.length; i4 += f3)
                r5.push(o4.call(e6, i4));
              return r5;
            }(e5 = a2.isBuffer(e5) ? e5 : new a2(e5), r4), 8 * e5.length), t4 = r4, i3 = new a2(n4), u4 = t4 ? i3.writeInt32BE : i3.writeInt32LE, s3 = 0; s3 < o3.length; s3++)
              u4.call(i3, o3[s3], 4 * s3, true);
            return i3;
          } };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v2, e3, _2) {
        !(function(l2, c3, u3, d2, h2, p2, g2, y2, w2) {
          var u3 = v2("buffer").Buffer, e4 = v2("./sha"), t3 = v2("./sha256"), n3 = v2("./rng"), b2 = { sha1: e4, sha256: t3, md5: v2("./md5") }, s2 = 64, a2 = new u3(s2);
          function r3(e5, n4) {
            var r4 = b2[e5 = e5 || "sha1"], o3 = [];
            return r4 || i2("algorithm:", e5, "is not yet supported"), { update: function(e6) {
              return u3.isBuffer(e6) || (e6 = new u3(e6)), o3.push(e6), e6.length, this;
            }, digest: function(e6) {
              var t4 = u3.concat(o3), t4 = n4 ? function(e7, t5, n5) {
                u3.isBuffer(t5) || (t5 = new u3(t5)), u3.isBuffer(n5) || (n5 = new u3(n5)), t5.length > s2 ? t5 = e7(t5) : t5.length < s2 && (t5 = u3.concat([t5, a2], s2));
                for (var r5 = new u3(s2), o4 = new u3(s2), i3 = 0; i3 < s2; i3++)
                  r5[i3] = 54 ^ t5[i3], o4[i3] = 92 ^ t5[i3];
                return n5 = e7(u3.concat([r5, n5])), e7(u3.concat([o4, n5]));
              }(r4, n4, t4) : r4(t4);
              return o3 = null, e6 ? t4.toString(e6) : t4;
            } };
          }
          function i2() {
            var e5 = [].slice.call(arguments).join(" ");
            throw new Error([e5, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a2.fill(0), _2.createHash = function(e5) {
            return r3(e5);
          }, _2.createHmac = r3, _2.randomBytes = function(e5, t4) {
            if (!t4 || !t4.call)
              return new u3(n3(e5));
            try {
              t4.call(this, void 0, new u3(n3(e5)));
            } catch (e6) {
              t4(e6);
            }
          };
          var o2, f3 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m = function(e5) {
            _2[e5] = function() {
              i2("sorry,", e5, "is not implemented yet");
            };
          };
          for (o2 in f3)
            m(f3[o2], o2);
        }).call(this, v2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w2, b2, e3) {
        !(function(e4, r3, o2, i2, u3, a2, f3, l2, y2) {
          var t3 = w2("./helpers");
          function n3(e5, t4) {
            e5[t4 >> 5] |= 128 << t4 % 32, e5[14 + (t4 + 64 >>> 9 << 4)] = t4;
            for (var n4 = 1732584193, r4 = -271733879, o3 = -1732584194, i3 = 271733878, u4 = 0; u4 < e5.length; u4 += 16) {
              var s3 = n4, a3 = r4, f4 = o3, l3 = i3, n4 = c3(n4, r4, o3, i3, e5[u4 + 0], 7, -680876936), i3 = c3(i3, n4, r4, o3, e5[u4 + 1], 12, -389564586), o3 = c3(o3, i3, n4, r4, e5[u4 + 2], 17, 606105819), r4 = c3(r4, o3, i3, n4, e5[u4 + 3], 22, -1044525330);
              n4 = c3(n4, r4, o3, i3, e5[u4 + 4], 7, -176418897), i3 = c3(i3, n4, r4, o3, e5[u4 + 5], 12, 1200080426), o3 = c3(o3, i3, n4, r4, e5[u4 + 6], 17, -1473231341), r4 = c3(r4, o3, i3, n4, e5[u4 + 7], 22, -45705983), n4 = c3(n4, r4, o3, i3, e5[u4 + 8], 7, 1770035416), i3 = c3(i3, n4, r4, o3, e5[u4 + 9], 12, -1958414417), o3 = c3(o3, i3, n4, r4, e5[u4 + 10], 17, -42063), r4 = c3(r4, o3, i3, n4, e5[u4 + 11], 22, -1990404162), n4 = c3(n4, r4, o3, i3, e5[u4 + 12], 7, 1804603682), i3 = c3(i3, n4, r4, o3, e5[u4 + 13], 12, -40341101), o3 = c3(o3, i3, n4, r4, e5[u4 + 14], 17, -1502002290), n4 = d2(n4, r4 = c3(r4, o3, i3, n4, e5[u4 + 15], 22, 1236535329), o3, i3, e5[u4 + 1], 5, -165796510), i3 = d2(i3, n4, r4, o3, e5[u4 + 6], 9, -1069501632), o3 = d2(o3, i3, n4, r4, e5[u4 + 11], 14, 643717713), r4 = d2(r4, o3, i3, n4, e5[u4 + 0], 20, -373897302), n4 = d2(n4, r4, o3, i3, e5[u4 + 5], 5, -701558691), i3 = d2(i3, n4, r4, o3, e5[u4 + 10], 9, 38016083), o3 = d2(o3, i3, n4, r4, e5[u4 + 15], 14, -660478335), r4 = d2(r4, o3, i3, n4, e5[u4 + 4], 20, -405537848), n4 = d2(n4, r4, o3, i3, e5[u4 + 9], 5, 568446438), i3 = d2(i3, n4, r4, o3, e5[u4 + 14], 9, -1019803690), o3 = d2(o3, i3, n4, r4, e5[u4 + 3], 14, -187363961), r4 = d2(r4, o3, i3, n4, e5[u4 + 8], 20, 1163531501), n4 = d2(n4, r4, o3, i3, e5[u4 + 13], 5, -1444681467), i3 = d2(i3, n4, r4, o3, e5[u4 + 2], 9, -51403784), o3 = d2(o3, i3, n4, r4, e5[u4 + 7], 14, 1735328473), n4 = h2(n4, r4 = d2(r4, o3, i3, n4, e5[u4 + 12], 20, -1926607734), o3, i3, e5[u4 + 5], 4, -378558), i3 = h2(i3, n4, r4, o3, e5[u4 + 8], 11, -2022574463), o3 = h2(o3, i3, n4, r4, e5[u4 + 11], 16, 1839030562), r4 = h2(r4, o3, i3, n4, e5[u4 + 14], 23, -35309556), n4 = h2(n4, r4, o3, i3, e5[u4 + 1], 4, -1530992060), i3 = h2(i3, n4, r4, o3, e5[u4 + 4], 11, 1272893353), o3 = h2(o3, i3, n4, r4, e5[u4 + 7], 16, -155497632), r4 = h2(r4, o3, i3, n4, e5[u4 + 10], 23, -1094730640), n4 = h2(n4, r4, o3, i3, e5[u4 + 13], 4, 681279174), i3 = h2(i3, n4, r4, o3, e5[u4 + 0], 11, -358537222), o3 = h2(o3, i3, n4, r4, e5[u4 + 3], 16, -722521979), r4 = h2(r4, o3, i3, n4, e5[u4 + 6], 23, 76029189), n4 = h2(n4, r4, o3, i3, e5[u4 + 9], 4, -640364487), i3 = h2(i3, n4, r4, o3, e5[u4 + 12], 11, -421815835), o3 = h2(o3, i3, n4, r4, e5[u4 + 15], 16, 530742520), n4 = p2(n4, r4 = h2(r4, o3, i3, n4, e5[u4 + 2], 23, -995338651), o3, i3, e5[u4 + 0], 6, -198630844), i3 = p2(i3, n4, r4, o3, e5[u4 + 7], 10, 1126891415), o3 = p2(o3, i3, n4, r4, e5[u4 + 14], 15, -1416354905), r4 = p2(r4, o3, i3, n4, e5[u4 + 5], 21, -57434055), n4 = p2(n4, r4, o3, i3, e5[u4 + 12], 6, 1700485571), i3 = p2(i3, n4, r4, o3, e5[u4 + 3], 10, -1894986606), o3 = p2(o3, i3, n4, r4, e5[u4 + 10], 15, -1051523), r4 = p2(r4, o3, i3, n4, e5[u4 + 1], 21, -2054922799), n4 = p2(n4, r4, o3, i3, e5[u4 + 8], 6, 1873313359), i3 = p2(i3, n4, r4, o3, e5[u4 + 15], 10, -30611744), o3 = p2(o3, i3, n4, r4, e5[u4 + 6], 15, -1560198380), r4 = p2(r4, o3, i3, n4, e5[u4 + 13], 21, 1309151649), n4 = p2(n4, r4, o3, i3, e5[u4 + 4], 6, -145523070), i3 = p2(i3, n4, r4, o3, e5[u4 + 11], 10, -1120210379), o3 = p2(o3, i3, n4, r4, e5[u4 + 2], 15, 718787259), r4 = p2(r4, o3, i3, n4, e5[u4 + 9], 21, -343485551), n4 = g2(n4, s3), r4 = g2(r4, a3), o3 = g2(o3, f4), i3 = g2(i3, l3);
            }
            return Array(n4, r4, o3, i3);
          }
          function s2(e5, t4, n4, r4, o3, i3) {
            return g2((t4 = g2(g2(t4, e5), g2(r4, i3))) << o3 | t4 >>> 32 - o3, n4);
          }
          function c3(e5, t4, n4, r4, o3, i3, u4) {
            return s2(t4 & n4 | ~t4 & r4, e5, t4, o3, i3, u4);
          }
          function d2(e5, t4, n4, r4, o3, i3, u4) {
            return s2(t4 & r4 | n4 & ~r4, e5, t4, o3, i3, u4);
          }
          function h2(e5, t4, n4, r4, o3, i3, u4) {
            return s2(t4 ^ n4 ^ r4, e5, t4, o3, i3, u4);
          }
          function p2(e5, t4, n4, r4, o3, i3, u4) {
            return s2(n4 ^ (t4 | ~r4), e5, t4, o3, i3, u4);
          }
          function g2(e5, t4) {
            var n4 = (65535 & e5) + (65535 & t4);
            return (e5 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
          }
          b2.exports = function(e5) {
            return t3.hash(e5, n3, 16);
          };
        }).call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e3, l2, t3) {
        !(function(e4, t4, n3, r3, o2, i2, u3, s2, f3) {
          var a2;
          l2.exports = a2 || function(e5) {
            for (var t5, n4 = new Array(e5), r4 = 0; r4 < e5; r4++)
              0 == (3 & r4) && (t5 = 4294967296 * Math.random()), n4[r4] = t5 >>> ((3 & r4) << 3) & 255;
            return n4;
          };
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c3, d2, e3) {
        !(function(e4, t3, n3, r3, o2, s2, a2, f3, l2) {
          var i2 = c3("./helpers");
          function u3(l3, c4) {
            l3[c4 >> 5] |= 128 << 24 - c4 % 32, l3[15 + (c4 + 64 >> 9 << 4)] = c4;
            for (var e5, t4, n4, r4 = Array(80), o3 = 1732584193, i3 = -271733879, u4 = -1732584194, s3 = 271733878, d3 = -1009589776, h2 = 0; h2 < l3.length; h2 += 16) {
              for (var p2 = o3, g2 = i3, y2 = u4, w2 = s3, b2 = d3, a3 = 0; a3 < 80; a3++) {
                r4[a3] = a3 < 16 ? l3[h2 + a3] : v2(r4[a3 - 3] ^ r4[a3 - 8] ^ r4[a3 - 14] ^ r4[a3 - 16], 1);
                var f4 = m(m(v2(o3, 5), (f4 = i3, t4 = u4, n4 = s3, (e5 = a3) < 20 ? f4 & t4 | ~f4 & n4 : !(e5 < 40) && e5 < 60 ? f4 & t4 | f4 & n4 | t4 & n4 : f4 ^ t4 ^ n4)), m(m(d3, r4[a3]), (e5 = a3) < 20 ? 1518500249 : e5 < 40 ? 1859775393 : e5 < 60 ? -1894007588 : -899497514)), d3 = s3, s3 = u4, u4 = v2(i3, 30), i3 = o3, o3 = f4;
              }
              o3 = m(o3, p2), i3 = m(i3, g2), u4 = m(u4, y2), s3 = m(s3, w2), d3 = m(d3, b2);
            }
            return Array(o3, i3, u4, s3, d3);
          }
          function m(e5, t4) {
            var n4 = (65535 & e5) + (65535 & t4);
            return (e5 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
          }
          function v2(e5, t4) {
            return e5 << t4 | e5 >>> 32 - t4;
          }
          d2.exports = function(e5) {
            return i2.hash(e5, u3, 20, true);
          };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c3, d2, e3) {
        !(function(e4, t3, n3, r3, u3, s2, a2, f3, l2) {
          function b2(e5, t4) {
            var n4 = (65535 & e5) + (65535 & t4);
            return (e5 >> 16) + (t4 >> 16) + (n4 >> 16) << 16 | 65535 & n4;
          }
          function o2(e5, l3) {
            var c4, d3 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t4 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n4 = new Array(64);
            e5[l3 >> 5] |= 128 << 24 - l3 % 32, e5[15 + (l3 + 64 >> 9 << 4)] = l3;
            for (var r4, o3, h2 = 0; h2 < e5.length; h2 += 16) {
              for (var i3 = t4[0], u4 = t4[1], s3 = t4[2], p2 = t4[3], a3 = t4[4], g2 = t4[5], y2 = t4[6], w2 = t4[7], f4 = 0; f4 < 64; f4++)
                n4[f4] = f4 < 16 ? e5[f4 + h2] : b2(b2(b2((o3 = n4[f4 - 2], m(o3, 17) ^ m(o3, 19) ^ v2(o3, 10)), n4[f4 - 7]), (o3 = n4[f4 - 15], m(o3, 7) ^ m(o3, 18) ^ v2(o3, 3))), n4[f4 - 16]), c4 = b2(b2(b2(b2(w2, m(o3 = a3, 6) ^ m(o3, 11) ^ m(o3, 25)), a3 & g2 ^ ~a3 & y2), d3[f4]), n4[f4]), r4 = b2(m(r4 = i3, 2) ^ m(r4, 13) ^ m(r4, 22), i3 & u4 ^ i3 & s3 ^ u4 & s3), w2 = y2, y2 = g2, g2 = a3, a3 = b2(p2, c4), p2 = s3, s3 = u4, u4 = i3, i3 = b2(c4, r4);
              t4[0] = b2(i3, t4[0]), t4[1] = b2(u4, t4[1]), t4[2] = b2(s3, t4[2]), t4[3] = b2(p2, t4[3]), t4[4] = b2(a3, t4[4]), t4[5] = b2(g2, t4[5]), t4[6] = b2(y2, t4[6]), t4[7] = b2(w2, t4[7]);
            }
            return t4;
          }
          var i2 = c3("./helpers"), m = function(e5, t4) {
            return e5 >>> t4 | e5 << 32 - t4;
          }, v2 = function(e5, t4) {
            return e5 >>> t4;
          };
          d2.exports = function(e5) {
            return i2.hash(e5, o2, 32, true);
          };
        }).call(this, c3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e3, t3, f3) {
        !(function(e4, t4, n3, r3, o2, i2, u3, s2, a2) {
          f3.read = function(e5, t5, n4, r4, o3) {
            var i3, u4, l2 = 8 * o3 - r4 - 1, c3 = (1 << l2) - 1, d2 = c3 >> 1, s3 = -7, a3 = n4 ? o3 - 1 : 0, f4 = n4 ? -1 : 1, o3 = e5[t5 + a3];
            for (a3 += f4, i3 = o3 & (1 << -s3) - 1, o3 >>= -s3, s3 += l2; 0 < s3; i3 = 256 * i3 + e5[t5 + a3], a3 += f4, s3 -= 8)
              ;
            for (u4 = i3 & (1 << -s3) - 1, i3 >>= -s3, s3 += r4; 0 < s3; u4 = 256 * u4 + e5[t5 + a3], a3 += f4, s3 -= 8)
              ;
            if (0 === i3)
              i3 = 1 - d2;
            else {
              if (i3 === c3)
                return u4 ? NaN : 1 / 0 * (o3 ? -1 : 1);
              u4 += Math.pow(2, r4), i3 -= d2;
            }
            return (o3 ? -1 : 1) * u4 * Math.pow(2, i3 - r4);
          }, f3.write = function(e5, t5, l2, n4, r4, c3) {
            var o3, i3, u4 = 8 * c3 - r4 - 1, s3 = (1 << u4) - 1, a3 = s3 >> 1, d2 = 23 === r4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n4 ? 0 : c3 - 1, h2 = n4 ? 1 : -1, c3 = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
            for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (i3 = isNaN(t5) ? 1 : 0, o3 = s3) : (o3 = Math.floor(Math.log(t5) / Math.LN2), t5 * (n4 = Math.pow(2, -o3)) < 1 && (o3--, n4 *= 2), 2 <= (t5 += 1 <= o3 + a3 ? d2 / n4 : d2 * Math.pow(2, 1 - a3)) * n4 && (o3++, n4 /= 2), s3 <= o3 + a3 ? (i3 = 0, o3 = s3) : 1 <= o3 + a3 ? (i3 = (t5 * n4 - 1) * Math.pow(2, r4), o3 += a3) : (i3 = t5 * Math.pow(2, a3 - 1) * Math.pow(2, r4), o3 = 0)); 8 <= r4; e5[l2 + f4] = 255 & i3, f4 += h2, i3 /= 256, r4 -= 8)
              ;
            for (o3 = o3 << r4 | i3, u4 += r4; 0 < u4; e5[l2 + f4] = 255 & o3, f4 += h2, o3 /= 256, u4 -= 8)
              ;
            e5[l2 + f4 - h2] |= 128 * c3;
          };
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e3, h2, t3) {
        !(function(e4, t4, n3, r3, o2, f3, l2, c3, d2) {
          var i2, u3, s2;
          function a2() {
          }
          (e4 = h2.exports = {}).nextTick = (u3 = "undefined" != typeof window && window.setImmediate, s2 = "undefined" != typeof window && window.postMessage && window.addEventListener, u3 ? function(e5) {
            return window.setImmediate(e5);
          } : s2 ? (i2 = [], window.addEventListener("message", function(e5) {
            var t5 = e5.source;
            t5 !== window && null !== t5 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < i2.length && i2.shift()());
          }, true), function(e5) {
            i2.push(e5), window.postMessage("process-tick", "*");
          }) : function(e5) {
            setTimeout(e5, 0);
          }), e4.title = "browser", e4.browser = true, e4.env = {}, e4.argv = [], e4.on = a2, e4.addListener = a2, e4.once = a2, e4.off = a2, e4.removeListener = a2, e4.removeAllListeners = a2, e4.emit = a2, e4.binding = function(e5) {
            throw new Error("process.binding is not supported");
          }, e4.cwd = function() {
            return "/";
          }, e4.chdir = function(e5) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/@measured/puck/dist/chunk-62KOMFGG.mjs
var import_react = __toESM(require_react(), 1);
var import_flat = __toESM(require_flat(), 1);
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e3) {
        reject(e3);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var init_react_import = __esm({
  "../tsup-config/react-import.js"() {
    "use strict";
  }
});
init_react_import();
init_react_import();
init_react_import();
var defaultSlots = (value, fields) => Object.keys(fields).reduce(
  (acc, fieldName) => fields[fieldName].type === "slot" ? __spreadValues({ [fieldName]: [] }, acc) : acc,
  value
);
var isPromise = (v2) => !!v2 && typeof v2.then === "function";
var flatten = (values) => values.reduce((acc, item) => __spreadValues(__spreadValues({}, acc), item), {});
var containsPromise = (arr) => arr.some(isPromise);
var walkField = ({
  value,
  fields,
  mappers,
  propKey = "",
  propPath = "",
  id = "",
  config,
  recurseSlots = false
}) => {
  var _a5, _b3, _c4;
  const fieldType = (_a5 = fields[propKey]) == null ? void 0 : _a5.type;
  const map = mappers[fieldType];
  if (map && fieldType === "slot") {
    const content = value || [];
    const mappedContent = recurseSlots ? content.map((el) => {
      var _a23;
      const componentConfig = config.components[el.type];
      if (!componentConfig) {
        throw new Error(`Could not find component config for ${el.type}`);
      }
      const fields2 = (_a23 = componentConfig.fields) != null ? _a23 : {};
      return walkField({
        value: __spreadProps(__spreadValues({}, el), { props: defaultSlots(el.props, fields2) }),
        fields: fields2,
        mappers,
        id: el.props.id,
        config,
        recurseSlots
      });
    }) : content;
    if (containsPromise(mappedContent)) {
      return Promise.all(mappedContent);
    }
    return map({
      value: mappedContent,
      parentId: id,
      propName: propPath,
      field: fields[propKey],
      propPath
    });
  } else if (map && fields[propKey]) {
    return map({
      value,
      parentId: id,
      propName: propKey,
      field: fields[propKey],
      propPath
    });
  }
  if (value && typeof value === "object") {
    if (Array.isArray(value)) {
      const arrayFields = ((_b3 = fields[propKey]) == null ? void 0 : _b3.type) === "array" ? fields[propKey].arrayFields : null;
      if (!arrayFields)
        return value;
      const newValue = value.map(
        (el, idx) => walkField({
          value: el,
          fields: arrayFields,
          mappers,
          propKey,
          propPath: `${propPath}[${idx}]`,
          id,
          config,
          recurseSlots
        })
      );
      if (containsPromise(newValue)) {
        return Promise.all(newValue);
      }
      return newValue;
    } else if ("$$typeof" in value) {
      return value;
    } else {
      const objectFields = ((_c4 = fields[propKey]) == null ? void 0 : _c4.type) === "object" ? fields[propKey].objectFields : fields;
      return walkObject({
        value,
        fields: objectFields,
        mappers,
        id,
        getPropPath: (k) => `${propPath}.${k}`,
        config,
        recurseSlots
      });
    }
  }
  return value;
};
var walkObject = ({
  value,
  fields,
  mappers,
  id,
  getPropPath,
  config,
  recurseSlots
}) => {
  const newProps = Object.entries(value).map(([k, v2]) => {
    const opts = {
      value: v2,
      fields,
      mappers,
      propKey: k,
      propPath: getPropPath(k),
      id,
      config,
      recurseSlots
    };
    const newValue = walkField(opts);
    if (isPromise(newValue)) {
      return newValue.then((resolvedValue) => ({
        [k]: resolvedValue
      }));
    }
    return {
      [k]: newValue
    };
  }, {});
  if (containsPromise(newProps)) {
    return Promise.all(newProps).then(flatten);
  }
  return flatten(newProps);
};
function mapFields(item, mappers, config, recurseSlots = false) {
  var _a5, _b3, _c4, _d2, _e;
  const itemType = "type" in item ? item.type : "root";
  const componentConfig = itemType === "root" ? config.root : (_a5 = config.components) == null ? void 0 : _a5[itemType];
  const newProps = walkObject({
    value: defaultSlots((_b3 = item.props) != null ? _b3 : {}, (_c4 = componentConfig == null ? void 0 : componentConfig.fields) != null ? _c4 : {}),
    fields: (_d2 = componentConfig == null ? void 0 : componentConfig.fields) != null ? _d2 : {},
    mappers,
    id: item.props ? (_e = item.props.id) != null ? _e : "root" : "root",
    getPropPath: (k) => k,
    config,
    recurseSlots
  });
  if (isPromise(newProps)) {
    return newProps.then((resolvedProps) => __spreadProps(__spreadValues({}, item), {
      props: resolvedProps
    }));
  }
  return __spreadProps(__spreadValues({}, item), {
    props: newProps
  });
}
function walkTree(data, config, callbackFn) {
  var _a5, _b3;
  const walkItem = (item) => {
    return mapFields(
      item,
      {
        slot: ({ value, parentId, propName }) => {
          var _a23;
          const content = value;
          return (_a23 = callbackFn(content, { parentId, propName })) != null ? _a23 : content;
        }
      },
      config,
      true
    );
  };
  if ("props" in data) {
    return walkItem(data);
  }
  const _data2 = data;
  const zones = (_a5 = _data2.zones) != null ? _a5 : {};
  const mappedContent = _data2.content.map(walkItem);
  return {
    root: walkItem(_data2.root),
    content: (_b3 = callbackFn(mappedContent, {
      parentId: "root",
      propName: "default-zone"
    })) != null ? _b3 : mappedContent,
    zones: Object.keys(zones).reduce(
      (acc, zoneCompound) => __spreadProps(__spreadValues({}, acc), {
        [zoneCompound]: zones[zoneCompound].map(walkItem)
      }),
      {}
    )
  };
}
init_react_import();
init_react_import();
init_react_import();
var defaultViewports = [
  { width: 360, height: "auto", icon: "Smartphone", label: "Small" },
  { width: 768, height: "auto", icon: "Tablet", label: "Medium" },
  { width: 1280, height: "auto", icon: "Monitor", label: "Large" }
];
var defaultAppState = {
  data: { content: [], root: {}, zones: {} },
  ui: {
    leftSideBarVisible: true,
    rightSideBarVisible: true,
    arrayState: {},
    itemSelector: null,
    componentList: {},
    isDragging: false,
    previewMode: "edit",
    viewports: {
      current: {
        width: defaultViewports[0].width,
        height: defaultViewports[0].height || "auto"
      },
      options: [],
      controlsVisible: true
    },
    field: { focus: null }
  },
  indexes: {
    nodes: {},
    zones: {}
  }
};
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var rootAreaId = "root";
var rootZone = "default-zone";
var rootDroppableId = `${rootAreaId}:${rootZone}`;
var getZoneId = (zoneCompound) => {
  if (!zoneCompound) {
    return [];
  }
  if (zoneCompound && zoneCompound.indexOf(":") > -1) {
    return zoneCompound.split(":");
  }
  return [rootDroppableId, zoneCompound];
};
function forRelatedZones(item, data, cb, path = []) {
  Object.entries(data.zones || {}).forEach(([zoneCompound, content]) => {
    const [parentId] = getZoneId(zoneCompound);
    if (parentId === item.props.id) {
      cb(path, zoneCompound, content);
    }
  });
}
init_react_import();
init_react_import();
var stripSlots = (data, config) => {
  return mapFields(data, { slot: () => null }, config);
};
var { flatten: flatten2, unflatten } = import_flat.default;
var flattenNode = (node, config) => {
  return __spreadProps(__spreadValues({}, node), {
    props: flatten2(stripSlots(node, config).props)
  });
};
var expandNode = (node) => {
  const props = unflatten(node.props);
  return __spreadProps(__spreadValues({}, node), {
    props
  });
};
function walkAppState(state, config, mapContent = (content) => content, mapNodeOrSkip = (item) => item) {
  var _a5;
  let newZones = {};
  const newZoneIndex = {};
  const newNodeIndex = {};
  const processContent = (path, zoneCompound, content, zoneType, newId) => {
    var _a23;
    const [parentId] = zoneCompound.split(":");
    const mappedContent = ((_a23 = mapContent(content, zoneCompound, zoneType)) != null ? _a23 : content) || [];
    const [_22, zone] = zoneCompound.split(":");
    const newZoneCompound = `${newId || parentId}:${zone}`;
    const newContent2 = mappedContent.map(
      (zoneChild, index) => processItem(zoneChild, [...path, newZoneCompound], index)
    );
    newZoneIndex[newZoneCompound] = {
      contentIds: newContent2.map((item) => item.props.id),
      type: zoneType
    };
    return [newZoneCompound, newContent2];
  };
  const processRelatedZones = (item, newId, initialPath) => {
    forRelatedZones(
      item,
      state.data,
      (relatedPath, relatedZoneCompound, relatedContent) => {
        const [zoneCompound, newContent2] = processContent(
          relatedPath,
          relatedZoneCompound,
          relatedContent,
          "dropzone",
          newId
        );
        newZones[zoneCompound] = newContent2;
      },
      initialPath
    );
  };
  const processItem = (item, path, index) => {
    const mappedItem = mapNodeOrSkip(item, path, index);
    if (!mappedItem)
      return item;
    const id = mappedItem.props.id;
    const newProps = __spreadProps(__spreadValues({}, mapFields(
      mappedItem,
      {
        slot: ({ value, parentId: parentId2, propPath }) => {
          const content = value;
          const zoneCompound = `${parentId2}:${propPath}`;
          const [_22, newContent2] = processContent(
            path,
            zoneCompound,
            content,
            "slot",
            parentId2
          );
          return newContent2;
        }
      },
      config
    ).props), {
      id
    });
    processRelatedZones(item, id, path);
    const newItem = __spreadProps(__spreadValues({}, item), { props: newProps });
    const thisZoneCompound = path[path.length - 1];
    const [parentId, zone] = thisZoneCompound ? thisZoneCompound.split(":") : [null, ""];
    newNodeIndex[id] = {
      data: newItem,
      flatData: flattenNode(newItem, config),
      path,
      parentId,
      zone
    };
    const finalData = __spreadProps(__spreadValues({}, newItem), { props: __spreadValues({}, newItem.props) });
    if (newProps.id === "root") {
      delete finalData["type"];
      delete finalData.props["id"];
    }
    return finalData;
  };
  const zones = state.data.zones || {};
  const [_2, newContent] = processContent(
    [],
    rootDroppableId,
    state.data.content,
    "root"
  );
  const processedContent = newContent;
  const zonesAlreadyProcessed = Object.keys(newZones);
  Object.keys(zones || {}).forEach((zoneCompound) => {
    const [parentId] = zoneCompound.split(":");
    if (zonesAlreadyProcessed.includes(zoneCompound)) {
      return;
    }
    const [_22, newContent2] = processContent(
      [rootDroppableId],
      zoneCompound,
      zones[zoneCompound],
      "dropzone",
      parentId
    );
    newZones[zoneCompound] = newContent2;
  }, newZones);
  const processedRoot = processItem(
    {
      type: "root",
      props: __spreadProps(__spreadValues({}, (_a5 = state.data.root.props) != null ? _a5 : state.data.root), { id: "root" })
    },
    [],
    -1
  );
  const root = __spreadProps(__spreadValues({}, state.data.root), {
    props: processedRoot.props
  });
  return __spreadProps(__spreadValues({}, state), {
    data: {
      root,
      content: processedContent,
      zones: __spreadValues(__spreadValues({}, state.data.zones), newZones)
    },
    indexes: {
      nodes: __spreadValues(__spreadValues({}, state.indexes.nodes), newNodeIndex),
      zones: __spreadValues(__spreadValues({}, state.indexes.zones), newZoneIndex)
    }
  });
}
var migrations = [
  // Migrate root to root.props
  (data) => {
    const rootProps = data.root.props || data.root;
    if (Object.keys(data.root).length > 0 && !data.root.props) {
      console.warn(
        "Migration applied: Root props moved from `root` to `root.props`."
      );
      return __spreadProps(__spreadValues({}, data), {
        root: {
          props: __spreadValues({}, rootProps)
        }
      });
    }
    return data;
  },
  // Migrate zones to slots
  (data, config, migrationOptions) => {
    var _a5, _b3;
    if (!config)
      return data;
    console.log("Migrating DropZones to slots...");
    const updatedItems = {};
    const appState = __spreadProps(__spreadValues({}, defaultAppState), { data });
    const { indexes } = walkAppState(appState, config);
    const deletedCompounds = [];
    walkAppState(appState, config, (content, zoneCompound, zoneType) => {
      var _a23, _b22, _c4;
      if (zoneType === "dropzone") {
        const [id, slotName] = zoneCompound.split(":");
        const nodeData = indexes.nodes[id].data;
        const componentType = nodeData.type;
        const configForComponent = id === "root" ? config.root : config.components[componentType];
        if (((_b22 = (_a23 = configForComponent == null ? void 0 : configForComponent.fields) == null ? void 0 : _a23[slotName]) == null ? void 0 : _b22.type) === "slot") {
          updatedItems[id] = __spreadProps(__spreadValues({}, nodeData), {
            props: __spreadProps(__spreadValues(__spreadValues({}, nodeData.props), (_c4 = updatedItems[id]) == null ? void 0 : _c4.props), {
              [slotName]: content
            })
          });
          deletedCompounds.push(zoneCompound);
        }
        return content;
      }
      return content;
    });
    const updated = walkAppState(
      appState,
      config,
      (content) => content,
      (item) => {
        var _a23;
        return (_a23 = updatedItems[item.props.id]) != null ? _a23 : item;
      }
    );
    deletedCompounds.forEach((zoneCompound) => {
      var _a23;
      const [_2, propName] = zoneCompound.split(":");
      console.log(
        `✓ Success: Migrated "${zoneCompound}" from DropZone to slot field "${propName}"`
      );
      (_a23 = updated.data.zones) == null ? true : delete _a23[zoneCompound];
    });
    if (migrationOptions == null ? void 0 : migrationOptions.migrateDynamicZonesForComponent) {
      const unmigratedZonesGrouped = {};
      Object.keys((_a5 = updated.data.zones) != null ? _a5 : {}).forEach((zoneCompound) => {
        var _a23;
        const [componentId, propName] = zoneCompound.split(":");
        const content = (_a23 = updated.data.zones) == null ? void 0 : _a23[zoneCompound];
        if (!content) {
          return;
        }
        if (!unmigratedZonesGrouped[componentId]) {
          unmigratedZonesGrouped[componentId] = {};
        }
        if (!unmigratedZonesGrouped[componentId][propName]) {
          unmigratedZonesGrouped[componentId][propName] = content;
        }
      });
      Object.keys(unmigratedZonesGrouped).forEach((componentId) => {
        updated.data = walkTree(updated.data, config, (content) => {
          return content.map((child) => {
            var _a23;
            if (child.props.id !== componentId) {
              return child;
            }
            const migrateFn = (_a23 = migrationOptions == null ? void 0 : migrationOptions.migrateDynamicZonesForComponent) == null ? void 0 : _a23[child.type];
            if (!migrateFn) {
              return child;
            }
            const zones = unmigratedZonesGrouped[componentId];
            const migratedProps = migrateFn(child.props, zones);
            Object.keys(zones).forEach((propName) => {
              var _a33;
              const zoneCompound = `${componentId}:${propName}`;
              console.log(`✓ Success: Migrated "${zoneCompound}" DropZone`);
              (_a33 = updated.data.zones) == null ? true : delete _a33[zoneCompound];
            });
            return __spreadProps(__spreadValues({}, child), {
              props: migratedProps
            });
          });
        });
      });
    }
    Object.keys((_b3 = updated.data.zones) != null ? _b3 : {}).forEach((zoneCompound) => {
      const [_2, propName] = zoneCompound.split(":");
      throw new Error(
        `Could not migrate DropZone "${zoneCompound}" to slot field. No slot exists with the name "${propName}".`
      );
    });
    delete updated.data.zones;
    return updated.data;
  }
];
function migrate(data, config, migrationOptions) {
  return migrations == null ? void 0 : migrations.reduce(
    (acc, migration) => migration(acc, config, migrationOptions),
    data
  );
}
init_react_import();
init_react_import();
var defaultData = (data) => __spreadProps(__spreadValues({}, data), {
  root: data.root || {},
  content: data.content || []
});
function transformProps(data, propTransforms, config = { components: {} }) {
  const mapItem = (item) => {
    if (propTransforms[item.type]) {
      return __spreadProps(__spreadValues({}, item), {
        props: __spreadValues({
          id: item.props.id
        }, propTransforms[item.type](item.props))
      });
    }
    return item;
  };
  const defaultedData = defaultData(data);
  const rootProps = defaultedData.root.props || defaultedData.root;
  let newRoot = __spreadValues({}, defaultedData.root);
  if (propTransforms["root"]) {
    newRoot.props = propTransforms["root"](rootProps);
  }
  const dataWithUpdatedRoot = __spreadProps(__spreadValues({}, defaultedData), { root: newRoot });
  const updatedData = walkTree(
    dataWithUpdatedRoot,
    config,
    (content) => content.map(mapItem)
  );
  if (!defaultedData.root.props) {
    updatedData.root = updatedData.root.props;
  }
  return updatedData;
}
init_react_import();
init_react_import();
init_react_import();
var getChanged = (newItem, oldItem) => {
  return newItem ? Object.keys(newItem.props || {}).reduce((acc, item) => {
    const newItemProps = (newItem == null ? void 0 : newItem.props) || {};
    const oldItemProps = (oldItem == null ? void 0 : oldItem.props) || {};
    return __spreadProps(__spreadValues({}, acc), {
      [item]: !(0, import_fast_deep_equal.default)(oldItemProps[item], newItemProps[item])
    });
  }, {}) : {};
};
var cache = { lastChange: {} };
var resolveComponentData = (_0, _1, ..._2) => __async(void 0, [_0, _1, ..._2], function* (item, config, metadata = {}, onResolveStart, onResolveEnd, trigger = "replace") {
  const configForItem = "type" in item && item.type !== "root" ? config.components[item.type] : config.root;
  const resolvedItem = __spreadValues({}, item);
  const shouldRunResolver = (configForItem == null ? void 0 : configForItem.resolveData) && item.props;
  const id = "id" in item.props ? item.props.id : "root";
  if (shouldRunResolver) {
    const { item: oldItem = null, resolved = {} } = cache.lastChange[id] || {};
    if (item && (0, import_fast_deep_equal2.default)(item, oldItem)) {
      return { node: resolved, didChange: false };
    }
    const changed = getChanged(item, oldItem);
    if (onResolveStart) {
      onResolveStart(item);
    }
    const { props: resolvedProps, readOnly = {} } = yield configForItem.resolveData(item, {
      changed,
      lastData: oldItem,
      metadata: __spreadValues(__spreadValues({}, metadata), configForItem.metadata),
      trigger
    });
    resolvedItem.props = __spreadValues(__spreadValues({}, item.props), resolvedProps);
    if (Object.keys(readOnly).length) {
      resolvedItem.readOnly = readOnly;
    }
  }
  let itemWithResolvedChildren = yield mapFields(
    resolvedItem,
    {
      slot: (_02) => __async(void 0, [_02], function* ({ value }) {
        const content = value;
        return yield Promise.all(
          content.map(
            (childItem) => __async(void 0, null, function* () {
              return (yield resolveComponentData(
                childItem,
                config,
                metadata,
                onResolveStart,
                onResolveEnd,
                trigger
              )).node;
            })
          )
        );
      })
    },
    config
  );
  if (shouldRunResolver && onResolveEnd) {
    onResolveEnd(resolvedItem);
  }
  cache.lastChange[id] = {
    item,
    resolved: itemWithResolvedChildren
  };
  return {
    node: itemWithResolvedChildren,
    didChange: !(0, import_fast_deep_equal2.default)(item, itemWithResolvedChildren)
  };
});
init_react_import();
var toComponent = (item) => {
  return "type" in item ? item : __spreadProps(__spreadValues({}, item), {
    props: __spreadProps(__spreadValues({}, item.props), { id: "root" }),
    type: "root"
  });
};
function resolveAllData(_0, _1) {
  return __async(this, arguments, function* (data, config, metadata = {}, onResolveStart, onResolveEnd) {
    var _a5;
    const defaultedData = defaultData(data);
    const resolveNode = (_node) => __async(this, null, function* () {
      const node = toComponent(_node);
      onResolveStart == null ? void 0 : onResolveStart(node);
      const resolved = (yield resolveComponentData(
        node,
        config,
        metadata,
        () => {
        },
        () => {
        },
        "force"
      )).node;
      const resolvedDeep = yield mapFields(
        resolved,
        { slot: ({ value }) => processContent(value) },
        config
      );
      onResolveEnd == null ? void 0 : onResolveEnd(toComponent(resolvedDeep));
      return resolvedDeep;
    });
    const processContent = (content) => __async(this, null, function* () {
      return Promise.all(content.map(resolveNode));
    });
    const processZones = () => __async(this, null, function* () {
      var _a23;
      const zones = (_a23 = data.zones) != null ? _a23 : {};
      Object.entries(zones).forEach((_02) => __async(this, [_02], function* ([zoneKey, content]) {
        zones[zoneKey] = yield Promise.all(content.map(resolveNode));
      }));
      return zones;
    });
    const dynamic = {
      root: yield resolveNode(defaultedData.root),
      content: yield processContent(defaultedData.content),
      zones: yield processZones()
    };
    Object.keys((_a5 = defaultedData.zones) != null ? _a5 : {}).forEach((zoneKey) => __async(this, null, function* () {
      const content = defaultedData.zones[zoneKey];
      dynamic.zones[zoneKey] = yield processContent(content);
    }), {});
    return dynamic;
  });
}
init_react_import();
var setupZone = (data, zoneKey) => {
  if (zoneKey === rootDroppableId) {
    return data;
  }
  const newData = __spreadProps(__spreadValues({}, data), {
    zones: data.zones ? __spreadValues({}, data.zones) : {}
  });
  newData.zones[zoneKey] = newData.zones[zoneKey] || [];
  return newData;
};
init_react_import();
function useFieldTransforms(config, item, transforms, readOnly, forceReadOnly) {
  const mappers = (0, import_react2.useMemo)(() => {
    return Object.keys(transforms).reduce((acc, _fieldType) => {
      const fieldType = _fieldType;
      return __spreadProps(__spreadValues({}, acc), {
        [fieldType]: (_a5) => {
          var _b3 = _a5, {
            parentId
          } = _b3, params = __objRest(_b3, [
            "parentId"
          ]);
          const wildcardPath = params.propPath.replace(/\[\d+\]/g, "[*]");
          const isReadOnly = (readOnly == null ? void 0 : readOnly[params.propPath]) || (readOnly == null ? void 0 : readOnly[wildcardPath]) || forceReadOnly || false;
          const fn = transforms[fieldType];
          return fn == null ? void 0 : fn(__spreadProps(__spreadValues({}, params), {
            isReadOnly,
            componentId: parentId
          }));
        }
      });
    }, {});
  }, [transforms, readOnly, forceReadOnly]);
  const transformedProps = (0, import_react2.useMemo)(() => {
    const mapped = mapFields(item, mappers, config).props;
    return mapped;
  }, [config, item, mappers]);
  const mergedProps = (0, import_react2.useMemo)(
    () => __spreadValues(__spreadValues({}, item.props), transformedProps),
    [item.props, transformedProps]
  );
  return mergedProps;
}
init_react_import();
var getSlotTransform = (renderSlotEdit, renderSlotRender = renderSlotEdit) => ({
  slot: ({ value: content, propName, field, isReadOnly }) => {
    const render = isReadOnly ? renderSlotRender : renderSlotEdit;
    const Slot = (dzProps) => render(__spreadProps(__spreadValues({
      allow: (field == null ? void 0 : field.type) === "slot" ? field.allow : [],
      disallow: (field == null ? void 0 : field.type) === "slot" ? field.disallow : []
    }, dzProps), {
      zone: propName,
      content
    }));
    return Slot;
  }
});
init_react_import();
function useSlots(config, item, renderSlotEdit, renderSlotRender = renderSlotEdit, readOnly, forceReadOnly) {
  return useFieldTransforms(
    config,
    item,
    getSlotTransform(renderSlotEdit, renderSlotRender),
    readOnly,
    forceReadOnly
  );
}
init_react_import();
var SlotRenderPure = (props) => (0, import_jsx_runtime.jsx)(SlotRender, __spreadValues({}, props));
var Item = ({
  config,
  item,
  metadata
}) => {
  const Component = config.components[item.type];
  const props = useSlots(config, item, (slotProps) => (0, import_jsx_runtime.jsx)(SlotRenderPure, __spreadProps(__spreadValues({}, slotProps), { config, metadata })));
  return (0, import_jsx_runtime.jsx)(
    Component.render,
    __spreadProps(__spreadValues({}, props), {
      puck: __spreadProps(__spreadValues({}, props.puck), {
        metadata: metadata || {}
      })
    })
  );
};
var SlotRender = (0, import_react3.forwardRef)(
  function SlotRenderInternal({ className, style, content, config, metadata }, ref) {
    return (0, import_jsx_runtime.jsx)("div", { className, style, ref, children: content.map((item) => {
      if (!config.components[item.type]) {
        return null;
      }
      return (0, import_jsx_runtime.jsx)(
        Item,
        {
          config,
          item,
          metadata
        },
        item.props.id
      );
    }) });
  }
);

// node_modules/@measured/puck/dist/chunk-V7Y7BFEC.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v2;
  const arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i2 = 0; i2 < length32; i2 += 8) {
    const x = input[i2 >> 5] >>> i2 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a2 = 1732584193;
  let b2 = -271733879;
  let c3 = -1732584194;
  let d2 = 271733878;
  for (let i2 = 0; i2 < x.length; i2 += 16) {
    const olda = a2;
    const oldb = b2;
    const oldc = c3;
    const oldd = d2;
    a2 = md5ff(a2, b2, c3, d2, x[i2], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c3, x[i2 + 1], 12, -389564586);
    c3 = md5ff(c3, d2, a2, b2, x[i2 + 2], 17, 606105819);
    b2 = md5ff(b2, c3, d2, a2, x[i2 + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c3, d2, x[i2 + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c3, x[i2 + 5], 12, 1200080426);
    c3 = md5ff(c3, d2, a2, b2, x[i2 + 6], 17, -1473231341);
    b2 = md5ff(b2, c3, d2, a2, x[i2 + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c3, d2, x[i2 + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c3, x[i2 + 9], 12, -1958414417);
    c3 = md5ff(c3, d2, a2, b2, x[i2 + 10], 17, -42063);
    b2 = md5ff(b2, c3, d2, a2, x[i2 + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c3, d2, x[i2 + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c3, x[i2 + 13], 12, -40341101);
    c3 = md5ff(c3, d2, a2, b2, x[i2 + 14], 17, -1502002290);
    b2 = md5ff(b2, c3, d2, a2, x[i2 + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c3, d2, x[i2 + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c3, x[i2 + 6], 9, -1069501632);
    c3 = md5gg(c3, d2, a2, b2, x[i2 + 11], 14, 643717713);
    b2 = md5gg(b2, c3, d2, a2, x[i2], 20, -373897302);
    a2 = md5gg(a2, b2, c3, d2, x[i2 + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c3, x[i2 + 10], 9, 38016083);
    c3 = md5gg(c3, d2, a2, b2, x[i2 + 15], 14, -660478335);
    b2 = md5gg(b2, c3, d2, a2, x[i2 + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c3, d2, x[i2 + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c3, x[i2 + 14], 9, -1019803690);
    c3 = md5gg(c3, d2, a2, b2, x[i2 + 3], 14, -187363961);
    b2 = md5gg(b2, c3, d2, a2, x[i2 + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c3, d2, x[i2 + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c3, x[i2 + 2], 9, -51403784);
    c3 = md5gg(c3, d2, a2, b2, x[i2 + 7], 14, 1735328473);
    b2 = md5gg(b2, c3, d2, a2, x[i2 + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c3, d2, x[i2 + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c3, x[i2 + 8], 11, -2022574463);
    c3 = md5hh(c3, d2, a2, b2, x[i2 + 11], 16, 1839030562);
    b2 = md5hh(b2, c3, d2, a2, x[i2 + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c3, d2, x[i2 + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c3, x[i2 + 4], 11, 1272893353);
    c3 = md5hh(c3, d2, a2, b2, x[i2 + 7], 16, -155497632);
    b2 = md5hh(b2, c3, d2, a2, x[i2 + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c3, d2, x[i2 + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c3, x[i2], 11, -358537222);
    c3 = md5hh(c3, d2, a2, b2, x[i2 + 3], 16, -722521979);
    b2 = md5hh(b2, c3, d2, a2, x[i2 + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c3, d2, x[i2 + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c3, x[i2 + 12], 11, -421815835);
    c3 = md5hh(c3, d2, a2, b2, x[i2 + 15], 16, 530742520);
    b2 = md5hh(b2, c3, d2, a2, x[i2 + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c3, d2, x[i2], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c3, x[i2 + 7], 10, 1126891415);
    c3 = md5ii(c3, d2, a2, b2, x[i2 + 14], 15, -1416354905);
    b2 = md5ii(b2, c3, d2, a2, x[i2 + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c3, d2, x[i2 + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c3, x[i2 + 3], 10, -1894986606);
    c3 = md5ii(c3, d2, a2, b2, x[i2 + 10], 15, -1051523);
    b2 = md5ii(b2, c3, d2, a2, x[i2 + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c3, d2, x[i2 + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c3, x[i2 + 15], 10, -30611744);
    c3 = md5ii(c3, d2, a2, b2, x[i2 + 6], 15, -1560198380);
    b2 = md5ii(b2, c3, d2, a2, x[i2 + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c3, d2, x[i2 + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c3, x[i2 + 11], 10, -1120210379);
    c3 = md5ii(c3, d2, a2, b2, x[i2 + 2], 15, 718787259);
    b2 = md5ii(b2, c3, d2, a2, x[i2 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c3 = safeAdd(c3, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c3, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  const lsw = (x & 65535) + (y2 & 65535);
  const msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b2, x, s2, t3) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t3)), s2), b2);
}
function md5ff(a2, b2, c3, d2, x, s2, t3) {
  return md5cmn(b2 & c3 | ~b2 & d2, a2, b2, x, s2, t3);
}
function md5gg(a2, b2, c3, d2, x, s2, t3) {
  return md5cmn(b2 & d2 | c3 & ~d2, a2, b2, x, s2, t3);
}
function md5hh(a2, b2, c3, d2, x, s2, t3) {
  return md5cmn(b2 ^ c3 ^ d2, a2, b2, x, s2, t3);
}
function md5ii(a2, b2, c3, d2, x, s2, t3) {
  return md5cmn(c3 ^ (b2 | ~d2), a2, b2, x, s2, t3);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options2, buf, offset) {
  if (native_default.randomUUID && !buf && !options2) {
    return native_default.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s2, x, y2, z) {
  switch (s2) {
    case 0:
      return x & y2 ^ ~x & z;
    case 1:
      return x ^ y2 ^ z;
    case 2:
      return x & y2 ^ x & z ^ y2 & z;
    case 3:
      return x ^ y2 ^ z;
  }
}
function ROTL(x, n3) {
  return x << n3 | x >>> 32 - n3;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l2 = bytes.length / 4 + 2;
  const N = Math.ceil(l2 / 16);
  const M = new Array(N);
  for (let i2 = 0; i2 < N; ++i2) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];
    }
    M[i2] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i2 = 0; i2 < N; ++i2) {
    const W = new Uint32Array(80);
    for (let t3 = 0; t3 < 16; ++t3) {
      W[t3] = M[i2][t3];
    }
    for (let t3 = 16; t3 < 80; ++t3) {
      W[t3] = ROTL(W[t3 - 3] ^ W[t3 - 8] ^ W[t3 - 14] ^ W[t3 - 16], 1);
    }
    let a2 = H[0];
    let b2 = H[1];
    let c3 = H[2];
    let d2 = H[3];
    let e3 = H[4];
    for (let t3 = 0; t3 < 80; ++t3) {
      const s2 = Math.floor(t3 / 20);
      const T = ROTL(a2, 5) + f(s2, b2, c3, d2) + e3 + K[s2] + W[t3] >>> 0;
      e3 = d2;
      d2 = c3;
      c3 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c3 >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e3 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/zustand/esm/react.mjs
var import_react4 = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react4.default.useSyncExternalStore(
    api.subscribe,
    import_react4.default.useCallback(() => selector(api.getState()), [api, selector]),
    import_react4.default.useCallback(() => selector(api.getInitialState()), [api, selector])
  );
  import_react4.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/zustand/esm/middleware.mjs
var subscribeWithSelectorImpl = (fn) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options2) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options2 == null ? void 0 : options2.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options2 == null ? void 0 : options2.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;

// node_modules/@measured/puck/dist/chunk-V7Y7BFEC.mjs
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);
var import_react20 = __toESM(require_react(), 1);
var import_react21 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);

// node_modules/@measured/puck/node_modules/@dnd-kit/react/index.js
var import_react6 = __toESM(require_react());

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t3 = false;
    while (void 0 !== h) {
      var r3 = h;
      h = void 0;
      f2++;
      while (void 0 !== r3) {
        var o2 = r3.o;
        r3.o = void 0;
        r3.f &= -3;
        if (!(8 & r3.f) && c(r3))
          try {
            r3.c();
          } catch (r4) {
            if (!t3) {
              i2 = r4;
              t3 = true;
            }
          }
        r3 = o2;
      }
    }
    f2 = 0;
    s--;
    if (t3)
      throw i2;
  } else
    s--;
}
function r(i2) {
  if (s > 0)
    return i2();
  s++;
  try {
    return i2();
  } finally {
    t();
  }
}
var o = void 0;
function n(i2) {
  var t3 = o;
  o = void 0;
  try {
    return i2();
  } finally {
    o = t3;
  }
}
var h = void 0;
var s = 0;
var f2 = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t3 = i2.n;
    if (void 0 === t3 || t3.t !== o) {
      t3 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t3 };
      if (void 0 !== o.s)
        o.s.n = t3;
      o.s = t3;
      i2.n = t3;
      if (32 & o.f)
        i2.S(t3);
      return t3;
    } else if (-1 === t3.i) {
      t3.i = 0;
      if (void 0 !== t3.n) {
        t3.n.p = t3.p;
        if (void 0 !== t3.p)
          t3.p.n = t3.n;
        t3.p = o.s;
        t3.n = void 0;
        o.s.n = t3;
        o.s = t3;
      }
      return t3;
    }
  }
}
function u(i2, t3) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
  this.W = null == t3 ? void 0 : t3.watched;
  this.Z = null == t3 ? void 0 : t3.unwatched;
  this.name = null == t3 ? void 0 : t3.name;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  var t3 = this, r3 = this.t;
  if (r3 !== i2 && void 0 === i2.e) {
    i2.x = r3;
    this.t = i2;
    if (void 0 !== r3)
      r3.e = i2;
    else
      n(function() {
        var i3;
        null == (i3 = t3.W) || i3.call(t3);
      });
  }
};
u.prototype.U = function(i2) {
  var t3 = this;
  if (void 0 !== this.t) {
    var r3 = i2.e, o2 = i2.x;
    if (void 0 !== r3) {
      r3.x = o2;
      i2.e = void 0;
    }
    if (void 0 !== o2) {
      o2.e = r3;
      i2.x = void 0;
    }
    if (i2 === this.t) {
      this.t = o2;
      if (void 0 === o2)
        n(function() {
          var i3;
          null == (i3 = t3.Z) || i3.call(t3);
        });
    }
  }
};
u.prototype.subscribe = function(i2) {
  var t3 = this;
  return E(function() {
    var r3 = t3.value, n3 = o;
    o = void 0;
    try {
      i2(r3);
    } finally {
      o = n3;
    }
  }, { name: "sub" });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2)
    i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f2 > 100)
      throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r3 = this.t; void 0 !== r3; r3 = r3.x)
        r3.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2, t3) {
  return new u(i2, t3);
}
function c(i2) {
  for (var t3 = i2.s; void 0 !== t3; t3 = t3.n)
    if (t3.S.i !== t3.i || !t3.S.h() || t3.S.i !== t3.i)
      return true;
  return false;
}
function a(i2) {
  for (var t3 = i2.s; void 0 !== t3; t3 = t3.n) {
    var r3 = t3.S.n;
    if (void 0 !== r3)
      t3.r = r3;
    t3.S.n = t3;
    t3.i = -1;
    if (void 0 === t3.n) {
      i2.s = t3;
      break;
    }
  }
}
function l(i2) {
  var t3 = i2.s, r3 = void 0;
  while (void 0 !== t3) {
    var o2 = t3.p;
    if (-1 === t3.i) {
      t3.S.U(t3);
      if (void 0 !== o2)
        o2.n = t3.n;
      if (void 0 !== t3.n)
        t3.n.p = o2;
    } else
      r3 = t3;
    t3.S.n = t3.r;
    if (void 0 !== t3.r)
      t3.r = void 0;
    t3 = o2;
  }
  i2.s = r3;
}
function y(i2, t3) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
  this.W = null == t3 ? void 0 : t3.watched;
  this.Z = null == t3 ? void 0 : t3.unwatched;
  this.name = null == t3 ? void 0 : t3.name;
}
y.prototype = new u();
y.prototype.h = function() {
  this.f &= -3;
  if (1 & this.f)
    return false;
  if (32 == (36 & this.f))
    return true;
  this.f &= -5;
  if (this.g === v)
    return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t3 = this.x();
    if (16 & this.f || this.v !== t3 || 0 === this.i) {
      this.v = t3;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t3 = this.s; void 0 !== t3; t3 = t3.n)
      t3.S.S(t3);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t3 = this.s; void 0 !== t3; t3 = t3.n)
        t3.S.U(t3);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x)
      i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2)
    i2.i = this.i;
  if (16 & this.f)
    throw this.v;
  return this.v;
} });
function w(i2, t3) {
  return new y(i2, t3);
}
function _(i2) {
  var r3 = i2.u;
  i2.u = void 0;
  if ("function" == typeof r3) {
    s++;
    var n3 = o;
    o = void 0;
    try {
      r3();
    } catch (t3) {
      i2.f &= -2;
      i2.f |= 8;
      b(i2);
      throw t3;
    } finally {
      o = n3;
      t();
    }
  }
}
function b(i2) {
  for (var t3 = i2.s; void 0 !== t3; t3 = t3.n)
    t3.S.U(t3);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function g(i2) {
  if (o !== this)
    throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f)
    b(this);
  t();
}
function p(i2, t3) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
  this.name = null == t3 ? void 0 : t3.name;
}
p.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f)
      return;
    if (void 0 === this.x)
      return;
    var t3 = this.x();
    if ("function" == typeof t3)
      this.u = t3;
  } finally {
    i2();
  }
};
p.prototype.S = function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return g.bind(this, i2);
};
p.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
p.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f))
    b(this);
};
p.prototype.dispose = function() {
  this.d();
};
function E(i2, t3) {
  var r3 = new p(i2, t3);
  try {
    r3.c();
  } catch (i3) {
    r3.d();
    throw i3;
  }
  var o2 = r3.d.bind(r3);
  o2[Symbol.dispose] = o2;
  return o2;
}

// node_modules/@dnd-kit/state/dist/index.mjs
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
var __decoratorStart = (base) => {
  var _a23;
  return [, , , __create2((_a23 = base == null ? void 0 : base[__knownSymbol("metadata")]) != null ? _a23 : null)];
};
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp2(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++)
    flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc2(k < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x) {
    return __privateSet(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p2 ? (x) => (k ^ 1 ? __privateGet : __privateMethod)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p2 ? (x, y2) => __privateSet(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError("Object expected");
    else
      __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata(array, target), desc && __defProp2(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
function computed(compute, comparator) {
  if (comparator) {
    let previousValue;
    return w(() => {
      const value = compute();
      if (value && previousValue && comparator(previousValue, value)) {
        return previousValue;
      }
      previousValue = value;
      return value;
    });
  }
  return w(compute);
}
function deepEqual(a2, b2) {
  if (Object.is(a2, b2)) {
    return true;
  }
  if (a2 === null || b2 === null)
    return false;
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2 === b2;
  }
  if (a2 instanceof Set && b2 instanceof Set) {
    if (a2.size !== b2.size) {
      return false;
    }
    for (const value of a2) {
      if (!b2.has(value)) {
        return false;
      }
    }
    return true;
  }
  if (Array.isArray(a2)) {
    if (!Array.isArray(b2) || a2.length !== b2.length) {
      return false;
    }
    const hasDifferentValues = a2.some(
      (value, index) => !deepEqual(value, b2[index])
    );
    return !hasDifferentValues;
  }
  if (typeof a2 === "object" && typeof b2 === "object") {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b2);
    if (aKeys.length !== bKeys.length)
      return false;
    const hasDifferentValues = aKeys.some(
      (key) => !deepEqual(a2[key], b2[key])
    );
    return !hasDifferentValues;
  }
  return false;
}
function reactive({ get }, _2) {
  return {
    init(value) {
      return d(value);
    },
    get() {
      const current = get.call(this);
      return current.value;
    },
    set(newValue) {
      const current = get.call(this);
      if (current.peek() === newValue) {
        return;
      }
      current.value = newValue;
    }
  };
}
function derived(target, _2) {
  const map = /* @__PURE__ */ new WeakMap();
  return function() {
    let result = map.get(this);
    if (!result) {
      result = computed(target.bind(this));
      map.set(this, result);
    }
    return result.value;
  };
}
function enumerable(enumerable2 = true) {
  return function(_value2, context) {
    context.addInitializer(function() {
      const host = context.kind === "field" ? this : context.static ? this : Object.getPrototypeOf(this);
      const descriptor2 = Object.getOwnPropertyDescriptor(host, context.name);
      if (descriptor2) {
        Object.defineProperty(host, context.name, __spreadProps2(__spreadValues2({}, descriptor2), { enumerable: enumerable2 }));
      }
    });
  };
}
function effects(...entries) {
  const effects2 = entries.map(E);
  return () => effects2.forEach((cleanup) => cleanup());
}
var _previous_dec;
var _initial_dec;
var _current_dec;
var _current_dec2;
var _previous_dec2;
var _initial_dec2;
var _init;
var _initial;
var _a;
var initial_get;
var initial_set;
var _ValueHistory_instances;
var _previous;
var _b;
var previous_get;
var previous_set;
var _current;
var _c;
var current_get;
var current_set;
_initial_dec2 = [reactive], _previous_dec2 = [reactive], _current_dec2 = [reactive], _current_dec = [enumerable()], _initial_dec = [enumerable()], _previous_dec = [enumerable()];
var ValueHistory = class {
  constructor(defaultValue, equals = Object.is) {
    this.defaultValue = defaultValue;
    this.equals = equals;
    __runInitializers(_init, 5, this);
    __privateAdd(this, _ValueHistory_instances);
    __privateAdd(this, _initial, __runInitializers(_init, 8, this)), __runInitializers(_init, 11, this);
    __privateAdd(this, _previous, __runInitializers(_init, 12, this)), __runInitializers(_init, 15, this);
    __privateAdd(this, _current, __runInitializers(_init, 16, this)), __runInitializers(_init, 19, this);
    this.reset = this.reset.bind(this);
    this.reset();
  }
  get current() {
    return __privateGet(this, _ValueHistory_instances, current_get);
  }
  get initial() {
    return __privateGet(this, _ValueHistory_instances, initial_get);
  }
  get previous() {
    return __privateGet(this, _ValueHistory_instances, previous_get);
  }
  /** Set the current value */
  set current(value) {
    const current = n(() => __privateGet(this, _ValueHistory_instances, current_get));
    if (value && current && this.equals(current, value)) {
      return;
    }
    r(() => {
      if (!__privateGet(this, _ValueHistory_instances, initial_get)) {
        __privateSet(this, _ValueHistory_instances, value, initial_set);
      }
      __privateSet(this, _ValueHistory_instances, current, previous_set);
      __privateSet(this, _ValueHistory_instances, value, current_set);
    });
  }
  /** Reset the state to the initial value */
  reset(value = this.defaultValue) {
    r(() => {
      __privateSet(this, _ValueHistory_instances, void 0, previous_set);
      __privateSet(this, _ValueHistory_instances, value, initial_set);
      __privateSet(this, _ValueHistory_instances, value, current_set);
    });
  }
};
_init = __decoratorStart(null);
_initial = /* @__PURE__ */ new WeakMap();
_ValueHistory_instances = /* @__PURE__ */ new WeakSet();
_previous = /* @__PURE__ */ new WeakMap();
_current = /* @__PURE__ */ new WeakMap();
_a = __decorateElement(_init, 20, "#initial", _initial_dec2, _ValueHistory_instances, _initial), initial_get = _a.get, initial_set = _a.set;
_b = __decorateElement(_init, 20, "#previous", _previous_dec2, _ValueHistory_instances, _previous), previous_get = _b.get, previous_set = _b.set;
_c = __decorateElement(_init, 20, "#current", _current_dec2, _ValueHistory_instances, _current), current_get = _c.get, current_set = _c.set;
__decorateElement(_init, 2, "current", _current_dec, ValueHistory);
__decorateElement(_init, 2, "initial", _initial_dec, ValueHistory);
__decorateElement(_init, 2, "previous", _previous_dec, ValueHistory);
__decoratorMetadata(_init, ValueHistory);
function snapshot(value) {
  return n(() => {
    const output = {};
    for (const key in value) {
      output[key] = value[key];
    }
    return output;
  });
}
var _store;
var WeakStore = class {
  constructor() {
    __privateAdd(this, _store, /* @__PURE__ */ new WeakMap());
  }
  get(key, id) {
    var _a23;
    return key ? (_a23 = __privateGet(this, _store).get(key)) == null ? void 0 : _a23.get(id) : void 0;
  }
  set(key, id, value) {
    var _a23;
    if (!key)
      return;
    if (!__privateGet(this, _store).has(key))
      __privateGet(this, _store).set(key, /* @__PURE__ */ new Map());
    return (_a23 = __privateGet(this, _store).get(key)) == null ? void 0 : _a23.set(id, value);
  }
  clear(key) {
    var _a23;
    return key ? (_a23 = __privateGet(this, _store).get(key)) == null ? void 0 : _a23.clear() : void 0;
  }
};
_store = /* @__PURE__ */ new WeakMap();

// node_modules/@dnd-kit/geometry/dist/index.mjs
var __create3 = Object.create;
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __knownSymbol2 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp3.call(b2, prop))
      __defNormalProp3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b2)) {
      if (__propIsEnum3.call(b2, prop))
        __defNormalProp3(a2, prop, b2[prop]);
    }
  return a2;
};
var __name2 = (target, value) => __defProp3(target, "name", { value, configurable: true });
var __decoratorStart2 = (base) => {
  var _a23;
  return [, , , __create3((_a23 = base == null ? void 0 : base[__knownSymbol2("metadata")]) != null ? _a23 : null)];
};
var __decoratorStrings2 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn2 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError2("Function expected") : fn;
var __decoratorContext2 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings2[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError2("Already initialized") : fns.push(__expectFn2(fn || null)) });
var __decoratorMetadata2 = (array, target) => __defNormalProp3(target, __knownSymbol2("metadata"), array[3]);
var __runInitializers2 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++)
    flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement2 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings2[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc3(k < 4 ? target : { get [name]() {
    return __privateGet2(this, extra);
  }, set [name](x) {
    return __privateSet2(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name2(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name2(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext2(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn2(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p2 ? (x) => (k ^ 1 ? __privateGet2 : __privateMethod2)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p2 ? (x, y2) => __privateSet2(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn2(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError2("Object expected");
    else
      __expectFn2(fn = it.get) && (desc.get = fn), __expectFn2(fn = it.set) && (desc.set = fn), __expectFn2(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata2(array, target), desc && __defProp3(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateIn2 = (member, obj) => Object(obj) !== obj ? __typeError2('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var Point = class _Point {
  /**
   * @param {number} Coordinate of the point on the horizontal axis
   * @param {number} Coordinate of the point on the vertical axis
   */
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  /**
   * Returns the delta between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static delta(a2, b2) {
    return new _Point(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns the distance (hypotenuse) between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static distance(a2, b2) {
    return Math.hypot(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns true if both points are equal.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static equals(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y;
  }
  static from({ x, y: y2 }) {
    return new _Point(x, y2);
  }
};
var Rectangle = class _Rectangle {
  constructor(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
    this.scale = {
      x: 1,
      y: 1
    };
  }
  get inverseScale() {
    return {
      x: 1 / this.scale.x,
      y: 1 / this.scale.y
    };
  }
  translate(x, y2) {
    const { top, left, width, height, scale } = this;
    const newShape = new _Rectangle(left + x, top + y2, width, height);
    newShape.scale = __spreadValues3({}, scale);
    return newShape;
  }
  get boundingRectangle() {
    const { width, height, left, top, right, bottom } = this;
    return { width, height, left, top, right, bottom };
  }
  get center() {
    const { left, top, right, bottom } = this;
    return new Point((left + right) / 2, (top + bottom) / 2);
  }
  get area() {
    const { width, height } = this;
    return width * height;
  }
  equals(shape) {
    if (!(shape instanceof _Rectangle)) {
      return false;
    }
    const { left, top, width, height } = this;
    return left === shape.left && top === shape.top && width === shape.width && height === shape.height;
  }
  containsPoint(point) {
    const { top, left, bottom, right } = this;
    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;
  }
  intersectionArea(shape) {
    if (shape instanceof _Rectangle) {
      return rectangleRectangleIntersection(this, shape);
    }
    return 0;
  }
  intersectionRatio(shape) {
    const { area } = this;
    const intersectionArea = this.intersectionArea(shape);
    const intersectionRatio = intersectionArea / (shape.area + area - intersectionArea);
    return intersectionRatio;
  }
  get bottom() {
    const { top, height } = this;
    return top + height;
  }
  get right() {
    const { left, width } = this;
    return left + width;
  }
  get aspectRatio() {
    const { width, height } = this;
    return width / height;
  }
  get corners() {
    return [
      { x: this.left, y: this.top },
      { x: this.right, y: this.top },
      { x: this.left, y: this.bottom },
      { x: this.right, y: this.bottom }
    ];
  }
  static from({ top, left, width, height }) {
    return new _Rectangle(left, top, width, height);
  }
  static delta(a2, b2, alignment = { x: "center", y: "center" }) {
    const getCoordinate = (rect, axis) => {
      const align = alignment[axis];
      const start = axis === "x" ? rect.left : rect.top;
      const size = axis === "x" ? rect.width : rect.height;
      if (align == "start")
        return start;
      if (align == "end")
        return start + size;
      return start + size / 2;
    };
    return Point.delta(
      { x: getCoordinate(a2, "x"), y: getCoordinate(a2, "y") },
      { x: getCoordinate(b2, "x"), y: getCoordinate(b2, "y") }
    );
  }
  static intersectionRatio(a2, b2) {
    return _Rectangle.from(a2).intersectionRatio(_Rectangle.from(b2));
  }
};
function rectangleRectangleIntersection(a2, b2) {
  const top = Math.max(b2.top, a2.top);
  const left = Math.max(b2.left, a2.left);
  const right = Math.min(b2.left + b2.width, a2.left + a2.width);
  const bottom = Math.min(b2.top + b2.height, a2.top + a2.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const intersectionArea = width * height;
    return intersectionArea;
  }
  return 0;
}
var _direction_dec;
var _delta_dec;
var _a2;
var _timestamp;
var _init2;
var Position = class extends (_a2 = ValueHistory, _delta_dec = [derived], _direction_dec = [derived], _a2) {
  constructor(initialValue) {
    const point = Point.from(initialValue);
    super(point, (a2, b2) => Point.equals(a2, b2));
    __runInitializers2(_init2, 5, this);
    __privateAdd2(this, _timestamp, 0);
    this.velocity = { x: 0, y: 0 };
  }
  get delta() {
    return Point.delta(this.current, this.initial);
  }
  get direction() {
    const { current, previous } = this;
    if (!previous)
      return null;
    const delta = {
      x: current.x - previous.x,
      y: current.y - previous.y
    };
    if (!delta.x && !delta.y) {
      return null;
    }
    if (Math.abs(delta.x) > Math.abs(delta.y)) {
      return delta.x > 0 ? "right" : "left";
    }
    return delta.y > 0 ? "down" : "up";
  }
  get current() {
    return super.current;
  }
  set current(coordinates) {
    const { current } = this;
    const point = Point.from(coordinates);
    const delta = {
      x: point.x - current.x,
      y: point.y - current.y
    };
    const timestamp = Date.now();
    const timeDelta = timestamp - __privateGet2(this, _timestamp);
    const velocity = (delta2) => Math.round(delta2 / timeDelta * 100);
    r(() => {
      __privateSet2(this, _timestamp, timestamp);
      this.velocity = {
        x: velocity(delta.x),
        y: velocity(delta.y)
      };
      super.current = point;
    });
  }
  reset(coordinates = this.defaultValue) {
    super.reset(Point.from(coordinates));
    this.velocity = { x: 0, y: 0 };
  }
};
_init2 = __decoratorStart2(_a2);
_timestamp = /* @__PURE__ */ new WeakMap();
__decorateElement2(_init2, 2, "delta", _delta_dec, Position);
__decorateElement2(_init2, 2, "direction", _direction_dec, Position);
__decoratorMetadata2(_init2, Position);
function exceedsDistance({ x, y: y2 }, distance) {
  const dx = Math.abs(x);
  const dy = Math.abs(y2);
  if (typeof distance === "number") {
    return Math.sqrt(__pow(dx, 2) + __pow(dy, 2)) > distance;
  }
  if ("x" in distance && "y" in distance) {
    return dx > distance.x && dy > distance.y;
  }
  if ("x" in distance) {
    return dx > distance.x;
  }
  if ("y" in distance) {
    return dy > distance.y;
  }
  return false;
}
var Axis = ((Axis22) => {
  Axis22["Horizontal"] = "x";
  Axis22["Vertical"] = "y";
  return Axis22;
})(Axis || {});
var Axes = Object.values(Axis);

// node_modules/@dnd-kit/abstract/index.js
var __create4 = Object.create;
var __defProp4 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __knownSymbol3 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp4.call(b2, prop))
      __defNormalProp4(a2, prop, b2[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b2)) {
      if (__propIsEnum4.call(b2, prop))
        __defNormalProp4(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps3 = (a2, b2) => __defProps3(a2, __getOwnPropDescs3(b2));
var __name3 = (target, value) => __defProp4(target, "name", { value, configurable: true });
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart3 = (base) => {
  var _a5;
  return [, , , __create4((_a5 = base == null ? void 0 : base[__knownSymbol3("metadata")]) != null ? _a5 : null)];
};
var __decoratorStrings3 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn3 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError3("Function expected") : fn;
var __decoratorContext3 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings3[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError3("Already initialized") : fns.push(__expectFn3(fn || null)) });
var __decoratorMetadata3 = (array, target) => __defNormalProp4(target, __knownSymbol3("metadata"), array[3]);
var __runInitializers3 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++)
    flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement3 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings3[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc4(k < 4 ? target : { get [name]() {
    return __privateGet3(this, extra);
  }, set [name](x) {
    return __privateSet3(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name3(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name3(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext3(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn3(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p2 ? (x) => (k ^ 1 ? __privateGet3 : __privateMethod3)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p2 ? (x, y2) => __privateSet3(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn3(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError3("Object expected");
    else
      __expectFn3(fn = it.get) && (desc.get = fn), __expectFn3(fn = it.set) && (desc.set = fn), __expectFn3(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata3(array, target), desc && __defProp4(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateIn3 = (member, obj) => Object(obj) !== obj ? __typeError3('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod3 = (obj, member, method) => (__accessCheck3(obj, member, "access private method"), method);
function configure(plugin, options2) {
  return {
    plugin,
    options: options2
  };
}
function configurator(plugin) {
  return (options2) => {
    return configure(plugin, options2);
  };
}
function descriptor(plugin) {
  if (typeof plugin === "function") {
    return {
      plugin,
      options: void 0
    };
  }
  return plugin;
}
var _disabled_dec;
var _init3;
var _disabled;
var _cleanupFunctions;
_disabled_dec = [reactive];
var Plugin = class {
  /**
   * Creates a new plugin instance.
   *
   * @param manager - The drag and drop manager that owns this plugin
   * @param options - Optional configuration for the plugin
   */
  constructor(manager, options2) {
    this.manager = manager;
    this.options = options2;
    __privateAdd3(this, _disabled, __runInitializers3(_init3, 8, this, false)), __runInitializers3(_init3, 11, this);
    __privateAdd3(this, _cleanupFunctions, /* @__PURE__ */ new Set());
  }
  /**
   * Enables a disabled plugin instance.
   *
   * @remarks
   * This method triggers effects when called.
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disables an enabled plugin instance.
   *
   * @remarks
   * This method triggers effects when called.
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Checks if the plugin instance is disabled.
   *
   * @returns true if the plugin is disabled
   * @remarks
   * This method does not trigger effects when accessed.
   */
  isDisabled() {
    return n(() => {
      return this.disabled;
    });
  }
  /**
   * Configures a plugin instance with new options.
   *
   * @param options - The new options to apply
   */
  configure(options2) {
    this.options = options2;
  }
  /**
   * Registers an effect that will be cleaned up when the plugin is destroyed.
   *
   * @param callback - The effect callback to register
   * @returns A function to dispose of the effect
   */
  registerEffect(callback) {
    const dispose = E(callback.bind(this));
    __privateGet3(this, _cleanupFunctions).add(dispose);
    return dispose;
  }
  /**
   * Destroys a plugin instance and cleans up its resources.
   *
   * @remarks
   * This method:
   * - Calls all registered cleanup functions
   * - Should be overridden by subclasses to clean up additional resources
   */
  destroy() {
    __privateGet3(this, _cleanupFunctions).forEach((cleanup) => cleanup());
  }
  /**
   * Configures a plugin constructor with options.
   *
   * @param options - The options to configure the constructor with
   * @returns The configured plugin constructor
   *
   * @remarks
   * This method is used to configure the options that the
   * plugin constructor will use to create plugin instances.
   */
  static configure(options2) {
    return configure(this, options2);
  }
};
_init3 = __decoratorStart3(null);
_disabled = /* @__PURE__ */ new WeakMap();
_cleanupFunctions = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init3, 4, "disabled", _disabled_dec, Plugin, _disabled);
__decoratorMetadata3(_init3, Plugin);
var CorePlugin = class extends Plugin {
};
var _previousValues;
var PluginRegistry = class {
  /**
   * Creates a new plugin registry.
   *
   * @param manager - The drag and drop manager that owns this registry
   */
  constructor(manager) {
    this.manager = manager;
    this.instances = /* @__PURE__ */ new Map();
    __privateAdd3(this, _previousValues, []);
  }
  /**
   * Gets all registered plugin instances.
   *
   * @returns An array of all active plugin instances
   */
  get values() {
    return Array.from(this.instances.values());
  }
  /**
   * Sets the list of plugins to be used by the registry.
   *
   * @param entries - Array of plugin constructors or descriptors
   * @remarks
   * This method:
   * - Filters out duplicate plugins
   * - Unregisters plugins that are no longer in use
   * - Registers new plugins with their options
   */
  set values(entries) {
    const descriptors = entries.map(descriptor).reduceRight((acc, descriptor2) => {
      if (acc.some(({ plugin }) => plugin === descriptor2.plugin)) {
        return acc;
      }
      return [descriptor2, ...acc];
    }, []);
    const constructors = descriptors.map(({ plugin }) => plugin);
    for (const plugin of __privateGet3(this, _previousValues)) {
      if (!constructors.includes(plugin)) {
        if (plugin.prototype instanceof CorePlugin) {
          continue;
        }
        this.unregister(plugin);
      }
    }
    for (const { plugin, options: options2 } of descriptors) {
      this.register(plugin, options2);
    }
    __privateSet3(this, _previousValues, constructors);
  }
  /**
   * Gets a plugin instance by its constructor.
   *
   * @param plugin - The plugin constructor to look up
   * @returns The plugin instance or undefined if not found
   */
  get(plugin) {
    const instance = this.instances.get(plugin);
    return instance;
  }
  /**
   * Registers a new plugin instance.
   *
   * @param plugin - The plugin constructor to register
   * @param options - Optional configuration for the plugin
   * @returns The registered plugin instance
   * @remarks
   * If the plugin is already registered, its options will be updated
   * and the existing instance will be returned.
   */
  register(plugin, options2) {
    const existingInstance = this.instances.get(plugin);
    if (existingInstance) {
      if (existingInstance.options !== options2) {
        existingInstance.options = options2;
      }
      return existingInstance;
    }
    const instance = new plugin(this.manager, options2);
    this.instances.set(plugin, instance);
    return instance;
  }
  /**
   * Unregisters a plugin instance.
   *
   * @param plugin - The plugin constructor to unregister
   * @remarks
   * This method:
   * - Destroys the plugin instance
   * - Removes it from the registry
   */
  unregister(plugin) {
    const instance = this.instances.get(plugin);
    if (instance) {
      instance.destroy();
      this.instances.delete(plugin);
    }
  }
  /**
   * Destroys all registered plugin instances.
   *
   * @remarks
   * This method:
   * - Calls destroy() on all plugin instances
   * - Clears the registry
   */
  destroy() {
    for (const plugin of this.instances.values()) {
      plugin.destroy();
    }
    this.instances.clear();
  }
};
_previousValues = /* @__PURE__ */ new WeakMap();
function sortCollisions(a2, b2) {
  if (a2.priority === b2.priority) {
    if (a2.type === b2.type) {
      return b2.value - a2.value;
    }
    return b2.type - a2.type;
  }
  return b2.priority - a2.priority;
}
var DEFAULT_VALUE = [];
var _previousCoordinates;
var _collisions;
var CollisionObserver = class extends Plugin {
  /**
   * Creates a new CollisionObserver instance.
   *
   * @param manager - The drag drop manager instance
   */
  constructor(manager) {
    super(manager);
    __privateAdd3(this, _previousCoordinates);
    __privateAdd3(this, _collisions);
    this.computeCollisions = this.computeCollisions.bind(this);
    __privateSet3(this, _collisions, d(DEFAULT_VALUE));
    this.destroy = effects(
      () => {
        const collisions = this.computeCollisions();
        const coordinates = n(
          () => this.manager.dragOperation.position.current
        );
        if (collisions !== DEFAULT_VALUE) {
          const previousCoordinates = __privateGet3(this, _previousCoordinates);
          __privateSet3(this, _previousCoordinates, coordinates);
          if (previousCoordinates && coordinates.x == previousCoordinates.x && coordinates.y == previousCoordinates.y) {
            return;
          }
        } else {
          __privateSet3(this, _previousCoordinates, void 0);
        }
        __privateGet3(this, _collisions).value = collisions;
      },
      () => {
        const { dragOperation } = this.manager;
        if (dragOperation.status.initialized) {
          this.forceUpdate();
        }
      }
    );
  }
  /**
   * Forces an immediate update of collision detection.
   *
   * @param immediate - If true, updates collisions immediately. If false, resets previous coordinates.
   */
  forceUpdate(immediate = true) {
    n(() => {
      if (immediate) {
        __privateGet3(this, _collisions).value = this.computeCollisions();
      } else {
        __privateSet3(this, _previousCoordinates, void 0);
      }
    });
  }
  /**
   * Computes collisions between draggable and droppable elements.
   *
   * @param entries - Optional array of droppable elements to check. If not provided, uses all registered droppables.
   * @param collisionDetector - Optional custom collision detector function
   * @returns Array of detected collisions, sorted by priority
   */
  computeCollisions(entries, collisionDetector) {
    const { registry, dragOperation } = this.manager;
    const { source, shape, status } = dragOperation;
    if (!status.initialized || !shape) {
      return DEFAULT_VALUE;
    }
    const collisions = [];
    const potentialTargets = [];
    for (const entry of entries != null ? entries : registry.droppables) {
      if (entry.disabled) {
        continue;
      }
      if (source && !entry.accepts(source)) {
        continue;
      }
      const detectCollision = collisionDetector != null ? collisionDetector : entry.collisionDetector;
      if (!detectCollision) {
        continue;
      }
      potentialTargets.push(entry);
      void entry.shape;
      const collision = n(
        () => detectCollision({
          droppable: entry,
          dragOperation
        })
      );
      if (collision) {
        if (entry.collisionPriority != null) {
          collision.priority = entry.collisionPriority;
        }
        collisions.push(collision);
      }
    }
    if (potentialTargets.length === 0) {
      return DEFAULT_VALUE;
    }
    collisions.sort(sortCollisions);
    return collisions;
  }
  /**
   * Gets the current collisions signal value.
   */
  get collisions() {
    return __privateGet3(this, _collisions).value;
  }
};
_previousCoordinates = /* @__PURE__ */ new WeakMap();
_collisions = /* @__PURE__ */ new WeakMap();
var Monitor = class {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
  }
  /**
   * Adds an event listener for the specified event type.
   *
   * @param name - The name of the event to listen for
   * @param handler - The function to call when the event occurs
   * @returns A function to remove the event listener
   */
  addEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.add(handler);
    registry.set(name, listeners);
    return () => this.removeEventListener(name, handler);
  }
  /**
   * Removes an event listener for the specified event type.
   *
   * @param name - The name of the event
   * @param handler - The function to remove
   */
  removeEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.delete(handler);
    registry.set(name, listeners);
  }
  /**
   * Dispatches an event to all registered listeners.
   *
   * @param name - The name of the event to dispatch
   * @param args - Arguments to pass to the event handlers
   */
  dispatch(name, ...args) {
    const { registry } = this;
    const listeners = registry.get(name);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(...args);
    }
  }
};
var DragDropMonitor = class extends Monitor {
  /**
   * Creates a new drag and drop monitor.
   *
   * @param manager - The drag and drop manager to monitor
   */
  constructor(manager) {
    super();
    this.manager = manager;
  }
  /**
   * Dispatches a drag and drop event.
   *
   * @param type - The type of event to dispatch
   * @param event - The event data to dispatch
   */
  dispatch(type, event) {
    const args = [event, this.manager];
    super.dispatch(type, ...args);
  }
};
function defaultPreventable(event, cancelable = true) {
  let defaultPrevented = false;
  return __spreadProps3(__spreadValues4({}, event), {
    cancelable,
    get defaultPrevented() {
      return defaultPrevented;
    },
    preventDefault() {
      if (!cancelable) {
        return;
      }
      defaultPrevented = true;
    }
  });
}
var CollisionNotifier = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    const isEqual = (a2, b2) => a2.map(({ id }) => id).join("") === b2.map(({ id }) => id).join("");
    let previousCollisions = [];
    this.destroy = effects(
      () => {
        const { dragOperation, collisionObserver } = manager;
        if (dragOperation.status.initializing) {
          previousCollisions = [];
          collisionObserver.enable();
        }
      },
      () => {
        const { collisionObserver, monitor } = manager;
        const { collisions } = collisionObserver;
        if (collisionObserver.isDisabled()) {
          return;
        }
        const event = defaultPreventable({
          collisions
        });
        monitor.dispatch("collision", event);
        if (event.defaultPrevented) {
          return;
        }
        if (isEqual(collisions, previousCollisions)) {
          return;
        } else {
          previousCollisions = collisions;
        }
        const [firstCollision] = collisions;
        n(() => {
          var _a5;
          if ((firstCollision == null ? void 0 : firstCollision.id) !== ((_a5 = manager.dragOperation.target) == null ? void 0 : _a5.id)) {
            collisionObserver.disable();
            manager.actions.setDropTarget(firstCollision == null ? void 0 : firstCollision.id).then(() => {
              collisionObserver.enable();
            });
          }
        });
      }
    );
  }
};
var CollisionPriority = ((CollisionPriority2) => {
  CollisionPriority2[CollisionPriority2["Lowest"] = 0] = "Lowest";
  CollisionPriority2[CollisionPriority2["Low"] = 1] = "Low";
  CollisionPriority2[CollisionPriority2["Normal"] = 2] = "Normal";
  CollisionPriority2[CollisionPriority2["High"] = 3] = "High";
  CollisionPriority2[CollisionPriority2["Highest"] = 4] = "Highest";
  return CollisionPriority2;
})(CollisionPriority || {});
var CollisionType = ((CollisionType2) => {
  CollisionType2[CollisionType2["Collision"] = 0] = "Collision";
  CollisionType2[CollisionType2["ShapeIntersection"] = 1] = "ShapeIntersection";
  CollisionType2[CollisionType2["PointerIntersection"] = 2] = "PointerIntersection";
  return CollisionType2;
})(CollisionType || {});
var _dropped_dec;
var _dragging_dec;
var _initialized_dec;
var _initializing_dec;
var _idle_dec;
var _current_dec3;
var _value_dec;
var _init22;
var _value;
_value_dec = [reactive], _current_dec3 = [derived], _idle_dec = [derived], _initializing_dec = [derived], _initialized_dec = [derived], _dragging_dec = [derived], _dropped_dec = [derived];
var Status = class {
  constructor() {
    __runInitializers3(_init22, 5, this);
    __privateAdd3(this, _value, __runInitializers3(
      _init22,
      8,
      this,
      "idle"
      /* Idle */
    )), __runInitializers3(_init22, 11, this);
  }
  get current() {
    return this.value;
  }
  get idle() {
    return this.value === "idle";
  }
  get initializing() {
    return this.value === "initializing";
  }
  get initialized() {
    const { value } = this;
    return value !== "idle" && value !== "initialization-pending";
  }
  get dragging() {
    return this.value === "dragging";
  }
  get dropped() {
    return this.value === "dropped";
  }
  /**
   * Sets the current status value.
   *
   * @param value - The new status value
   */
  set(value) {
    this.value = value;
  }
};
_init22 = __decoratorStart3(null);
_value = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init22, 4, "value", _value_dec, Status, _value);
__decorateElement3(_init22, 2, "current", _current_dec3, Status);
__decorateElement3(_init22, 2, "idle", _idle_dec, Status);
__decorateElement3(_init22, 2, "initializing", _initializing_dec, Status);
__decorateElement3(_init22, 2, "initialized", _initialized_dec, Status);
__decorateElement3(_init22, 2, "dragging", _dragging_dec, Status);
__decorateElement3(_init22, 2, "dropped", _dropped_dec, Status);
__decoratorMetadata3(_init22, Status);
var DragActions = class {
  /**
   * Creates a new instance of drag actions.
   *
   * @param manager - The drag and drop manager instance
   */
  constructor(manager) {
    this.manager = manager;
  }
  /**
   * Sets the source of the drag operation.
   *
   * @param source - The draggable entity or its unique identifier
   */
  setDragSource(source) {
    const { dragOperation } = this.manager;
    dragOperation.sourceIdentifier = typeof source === "string" || typeof source === "number" ? source : source.id;
  }
  /**
   * Sets the target of the drop operation.
   *
   * @param identifier - The unique identifier of the droppable entity or null/undefined
   * @returns A promise that resolves to true if the drop was prevented
   */
  setDropTarget(identifier) {
    return n(() => {
      const { dragOperation } = this.manager;
      const id = identifier != null ? identifier : null;
      if (dragOperation.targetIdentifier === id) {
        return Promise.resolve(false);
      }
      dragOperation.targetIdentifier = id;
      const event = defaultPreventable({
        operation: dragOperation.snapshot()
      });
      if (dragOperation.status.dragging) {
        this.manager.monitor.dispatch("dragover", event);
      }
      return this.manager.renderer.rendering.then(() => event.defaultPrevented);
    });
  }
  /**
   * Starts a new drag operation.
   *
   * @param args - Configuration for the drag operation
   * @param args.event - The event that initiated the drag
   * @param args.source - The source draggable entity or its identifier
   * @param args.coordinates - The initial coordinates of the drag
   * @returns true if the drag operation started successfully
   * @throws {Error} If there is no drag source or another operation is active
   */
  start(args) {
    return n(() => {
      const { dragOperation } = this.manager;
      if (args.source != null) {
        this.setDragSource(args.source);
      }
      const sourceInstance = dragOperation.source;
      if (!sourceInstance) {
        throw new Error("Cannot start a drag operation without a drag source");
      }
      if (!dragOperation.status.idle) {
        throw new Error(
          "Cannot start a drag operation while another is active"
        );
      }
      const controller = new AbortController();
      const { event: nativeEvent, coordinates } = args;
      r(() => {
        dragOperation.status.set(
          "initialization-pending"
          /* InitializationPending */
        );
        dragOperation.shape = null;
        dragOperation.canceled = false;
        dragOperation.activatorEvent = nativeEvent != null ? nativeEvent : null;
        dragOperation.position.reset(coordinates);
      });
      const beforeStartEvent = defaultPreventable({
        operation: dragOperation.snapshot()
      });
      this.manager.monitor.dispatch("beforedragstart", beforeStartEvent);
      if (beforeStartEvent.defaultPrevented) {
        dragOperation.reset();
        controller.abort();
        return controller;
      }
      dragOperation.status.set(
        "initializing"
        /* Initializing */
      );
      dragOperation.controller = controller;
      this.manager.renderer.rendering.then(() => {
        if (controller.signal.aborted)
          return;
        const { status } = dragOperation;
        if (status.current !== "initializing")
          return;
        dragOperation.status.set(
          "dragging"
          /* Dragging */
        );
        this.manager.monitor.dispatch("dragstart", {
          nativeEvent,
          operation: dragOperation.snapshot(),
          cancelable: false
        });
      });
      return controller;
    });
  }
  /**
   * Moves the dragged entity to a new position.
   *
   * @param args - Configuration for the move operation
   * @param args.by - Relative coordinates to move by
   * @param args.to - Absolute coordinates to move to
   * @param args.event - The event that triggered the move
   * @param args.cancelable - Whether the move can be canceled
   * @param args.propagate - Whether to dispatch dragmove events
   */
  move(args) {
    return n(() => {
      var _a5, _b3;
      const { dragOperation } = this.manager;
      const { status, controller } = dragOperation;
      if (!status.dragging || !controller || controller.signal.aborted) {
        return;
      }
      const event = defaultPreventable(
        {
          nativeEvent: args.event,
          operation: dragOperation.snapshot(),
          by: args.by,
          to: args.to
        },
        (_a5 = args.cancelable) != null ? _a5 : true
      );
      if ((_b3 = args.propagate) != null ? _b3 : true) {
        this.manager.monitor.dispatch("dragmove", event);
      }
      queueMicrotask(() => {
        var _a23, _b22, _c32, _d2, _e;
        if (event.defaultPrevented) {
          return;
        }
        const coordinates = (_e = args.to) != null ? _e : {
          x: dragOperation.position.current.x + ((_b22 = (_a23 = args.by) == null ? void 0 : _a23.x) != null ? _b22 : 0),
          y: dragOperation.position.current.y + ((_d2 = (_c32 = args.by) == null ? void 0 : _c32.y) != null ? _d2 : 0)
        };
        dragOperation.position.current = coordinates;
      });
    });
  }
  /**
   * Stops the current drag operation.
   *
   * @param args - Configuration for stopping the operation
   * @param args.event - The event that triggered the stop
   * @param args.canceled - Whether the operation was canceled
   * @remarks
   * This method:
   * - Dispatches a dragend event
   * - Allows suspension of the operation
   * - Handles cleanup of the operation state
   */
  stop(args = {}) {
    return n(() => {
      var _a5, _b3;
      const { dragOperation } = this.manager;
      const { controller } = dragOperation;
      if (!controller || controller.signal.aborted)
        return;
      let promise;
      const suspend = () => {
        const output = {
          resume: () => {
          },
          abort: () => {
          }
        };
        promise = new Promise((resolve, reject) => {
          output.resume = resolve;
          output.abort = reject;
        });
        return output;
      };
      controller.abort();
      const end = () => {
        this.manager.renderer.rendering.then(() => {
          dragOperation.status.set(
            "dropped"
            /* Dropped */
          );
          const dropping = n(
            () => {
              var _a23;
              return ((_a23 = dragOperation.source) == null ? void 0 : _a23.status) === "dropping";
            }
          );
          const cleanup = () => {
            if (dragOperation.controller === controller) {
              dragOperation.controller = void 0;
            }
            dragOperation.reset();
          };
          if (dropping) {
            const { source } = dragOperation;
            const dispose = E(() => {
              if ((source == null ? void 0 : source.status) === "idle") {
                dispose();
                cleanup();
              }
            });
          } else {
            this.manager.renderer.rendering.then(cleanup);
          }
        });
      };
      dragOperation.canceled = (_a5 = args.canceled) != null ? _a5 : false;
      this.manager.monitor.dispatch("dragend", {
        nativeEvent: args.event,
        operation: dragOperation.snapshot(),
        canceled: (_b3 = args.canceled) != null ? _b3 : false,
        suspend
      });
      if (promise) {
        promise.then(end).catch(() => dragOperation.reset());
      } else {
        end();
      }
    });
  }
};
var _disabled_dec2;
var _data_dec;
var _id_dec;
var _manager_dec;
var _init32;
var _manager;
var _id;
var _data;
var _disabled2;
_manager_dec = [reactive], _id_dec = [reactive], _data_dec = [reactive], _disabled_dec2 = [reactive];
var Entity = class {
  /**
   * Creates a new instance of the `Entity` class.
   *
   * @param input - An object containing the initial properties of the entity.
   * @param manager - The manager that controls the drag and drop operations.
   */
  constructor(input, manager) {
    __privateAdd3(this, _manager, __runInitializers3(_init32, 8, this)), __runInitializers3(_init32, 11, this);
    __privateAdd3(this, _id, __runInitializers3(_init32, 12, this)), __runInitializers3(_init32, 15, this);
    __privateAdd3(this, _data, __runInitializers3(_init32, 16, this)), __runInitializers3(_init32, 19, this);
    __privateAdd3(this, _disabled2, __runInitializers3(_init32, 20, this)), __runInitializers3(_init32, 23, this);
    const { effects: effects6, id, data = {}, disabled = false, register = true } = input;
    let previousId = id;
    this.manager = manager;
    this.id = id;
    this.data = data;
    this.disabled = disabled;
    this.effects = () => {
      var _a5;
      return [
        () => {
          const { id: id2, manager: manager2 } = this;
          if (id2 === previousId) {
            return;
          }
          manager2 == null ? void 0 : manager2.registry.register(this);
          return () => manager2 == null ? void 0 : manager2.registry.unregister(this);
        },
        ...(_a5 = effects6 == null ? void 0 : effects6()) != null ? _a5 : []
      ];
    };
    this.register = this.register.bind(this);
    this.unregister = this.unregister.bind(this);
    this.destroy = this.destroy.bind(this);
    if (manager && register) {
      queueMicrotask(this.register);
    }
  }
  /**
   * A method that registers the entity with the manager.
   * @returns CleanupFunction | void
   */
  register() {
    var _a5;
    return (_a5 = this.manager) == null ? void 0 : _a5.registry.register(this);
  }
  /**
   * A method that unregisters the entity from the manager.
   * @returns void
   */
  unregister() {
    var _a5;
    (_a5 = this.manager) == null ? void 0 : _a5.registry.unregister(this);
  }
  /**
   * A method that cleans up the entity when it is no longer needed.
   * @returns void
   */
  destroy() {
    var _a5;
    (_a5 = this.manager) == null ? void 0 : _a5.registry.unregister(this);
  }
};
_init32 = __decoratorStart3(null);
_manager = /* @__PURE__ */ new WeakMap();
_id = /* @__PURE__ */ new WeakMap();
_data = /* @__PURE__ */ new WeakMap();
_disabled2 = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init32, 4, "manager", _manager_dec, Entity, _manager);
__decorateElement3(_init32, 4, "id", _id_dec, Entity, _id);
__decorateElement3(_init32, 4, "data", _data_dec, Entity, _data);
__decorateElement3(_init32, 4, "disabled", _disabled_dec2, Entity, _disabled2);
__decoratorMetadata3(_init32, Entity);
var EntityRegistry = class {
  constructor() {
    this.map = d(/* @__PURE__ */ new Map());
    this.cleanupFunctions = /* @__PURE__ */ new WeakMap();
    this.register = (key, value) => {
      const current = this.map.peek();
      const currentValue2 = current.get(key);
      const unregister = () => this.unregister(key, value);
      if (currentValue2 === value)
        return unregister;
      if (currentValue2) {
        const cleanup2 = this.cleanupFunctions.get(currentValue2);
        cleanup2 == null ? void 0 : cleanup2();
        this.cleanupFunctions.delete(currentValue2);
      }
      const updatedMap = new Map(current);
      updatedMap.set(key, value);
      this.map.value = updatedMap;
      const cleanup = effects(...value.effects());
      this.cleanupFunctions.set(value, cleanup);
      return unregister;
    };
    this.unregister = (key, value) => {
      const current = this.map.peek();
      if (current.get(key) !== value) {
        return;
      }
      const cleanup = this.cleanupFunctions.get(value);
      cleanup == null ? void 0 : cleanup();
      this.cleanupFunctions.delete(value);
      const updatedMap = new Map(current);
      updatedMap.delete(key);
      this.map.value = updatedMap;
    };
  }
  /**
   * Iterator for the EntityRegistry class.
   * @returns An iterator for the values in the map.
   */
  [Symbol.iterator]() {
    return this.map.peek().values();
  }
  get value() {
    return this.map.value.values();
  }
  /**
   * Checks if a entity with the given identifier exists in the registry.
   * @param identifier - The unique identifier of the entity.
   * @returns True if the entity exists, false otherwise.
   */
  has(identifier) {
    return this.map.value.has(identifier);
  }
  /**
   * Retrieves a entity from the registry using its identifier.
   * @param identifier - The unique identifier of the entity.
   * @returns The entity if it exists, undefined otherwise.
   */
  get(identifier) {
    return this.map.value.get(identifier);
  }
  /**
   * Destroys all entries in the registry and clears the registry.
   */
  destroy() {
    for (const entry of this) {
      const cleanup = this.cleanupFunctions.get(entry);
      cleanup == null ? void 0 : cleanup();
      entry.destroy();
    }
    this.map.value = /* @__PURE__ */ new Map();
  }
};
var _isDragSource_dec;
var _isDragging_dec;
var _isDropping_dec;
var _status_dec;
var _modifiers_dec;
var _type_dec;
var _c2;
var _init4;
var _type;
var _modifiers;
var _status;
var Draggable = class extends (_c2 = Entity, _type_dec = [reactive], _modifiers_dec = [reactive], _status_dec = [reactive], _isDropping_dec = [derived], _isDragging_dec = [derived], _isDragSource_dec = [derived], _c2) {
  constructor(_a5, manager) {
    var _b3 = _a5, { modifiers, type, sensors } = _b3, input = __objRest2(_b3, ["modifiers", "type", "sensors"]);
    super(input, manager);
    __runInitializers3(_init4, 5, this);
    __privateAdd3(this, _type, __runInitializers3(_init4, 8, this)), __runInitializers3(_init4, 11, this);
    __privateAdd3(this, _modifiers, __runInitializers3(_init4, 12, this)), __runInitializers3(_init4, 15, this);
    __privateAdd3(this, _status, __runInitializers3(_init4, 16, this, this.isDragSource ? "dragging" : "idle")), __runInitializers3(_init4, 19, this);
    this.type = type;
    this.sensors = sensors;
    this.modifiers = modifiers;
    this.alignment = input.alignment;
  }
  get isDropping() {
    return this.status === "dropping" && this.isDragSource;
  }
  get isDragging() {
    return this.status === "dragging" && this.isDragSource;
  }
  get isDragSource() {
    var _a5, _b3;
    return ((_b3 = (_a5 = this.manager) == null ? void 0 : _a5.dragOperation.source) == null ? void 0 : _b3.id) === this.id;
  }
};
_init4 = __decoratorStart3(_c2);
_type = /* @__PURE__ */ new WeakMap();
_modifiers = /* @__PURE__ */ new WeakMap();
_status = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init4, 4, "type", _type_dec, Draggable, _type);
__decorateElement3(_init4, 4, "modifiers", _modifiers_dec, Draggable, _modifiers);
__decorateElement3(_init4, 4, "status", _status_dec, Draggable, _status);
__decorateElement3(_init4, 2, "isDropping", _isDropping_dec, Draggable);
__decorateElement3(_init4, 2, "isDragging", _isDragging_dec, Draggable);
__decorateElement3(_init4, 2, "isDragSource", _isDragSource_dec, Draggable);
__decoratorMetadata3(_init4, Draggable);
var _isDropTarget_dec;
var _shape_dec;
var _collisionPriority_dec;
var _collisionDetector_dec;
var _type_dec2;
var _accept_dec;
var _c22;
var _init5;
var _accept;
var _type2;
var _collisionDetector;
var _collisionPriority;
var _shape;
var Droppable = class extends (_c22 = Entity, _accept_dec = [reactive], _type_dec2 = [reactive], _collisionDetector_dec = [reactive], _collisionPriority_dec = [reactive], _shape_dec = [reactive], _isDropTarget_dec = [derived], _c22) {
  constructor(_a5, manager) {
    var _b3 = _a5, { accept, collisionDetector, collisionPriority, type } = _b3, input = __objRest2(_b3, ["accept", "collisionDetector", "collisionPriority", "type"]);
    super(input, manager);
    __runInitializers3(_init5, 5, this);
    __privateAdd3(this, _accept, __runInitializers3(_init5, 8, this)), __runInitializers3(_init5, 11, this);
    __privateAdd3(this, _type2, __runInitializers3(_init5, 12, this)), __runInitializers3(_init5, 15, this);
    __privateAdd3(this, _collisionDetector, __runInitializers3(_init5, 16, this)), __runInitializers3(_init5, 19, this);
    __privateAdd3(this, _collisionPriority, __runInitializers3(_init5, 20, this)), __runInitializers3(_init5, 23, this);
    __privateAdd3(this, _shape, __runInitializers3(_init5, 24, this)), __runInitializers3(_init5, 27, this);
    this.accept = accept;
    this.collisionDetector = collisionDetector;
    this.collisionPriority = collisionPriority;
    this.type = type;
  }
  /**
   * Checks whether or not the droppable accepts a given draggable.
   *
   * @param draggable - The draggable to check
   * @returns true if the draggable can be dropped here
   */
  accepts(draggable) {
    const { accept } = this;
    if (!accept) {
      return true;
    }
    if (typeof accept === "function") {
      return accept(draggable);
    }
    if (!draggable.type) {
      return false;
    }
    if (Array.isArray(accept)) {
      return accept.includes(draggable.type);
    }
    return draggable.type === accept;
  }
  get isDropTarget() {
    var _a5, _b3;
    return ((_b3 = (_a5 = this.manager) == null ? void 0 : _a5.dragOperation.target) == null ? void 0 : _b3.id) === this.id;
  }
};
_init5 = __decoratorStart3(_c22);
_accept = /* @__PURE__ */ new WeakMap();
_type2 = /* @__PURE__ */ new WeakMap();
_collisionDetector = /* @__PURE__ */ new WeakMap();
_collisionPriority = /* @__PURE__ */ new WeakMap();
_shape = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init5, 4, "accept", _accept_dec, Droppable, _accept);
__decorateElement3(_init5, 4, "type", _type_dec2, Droppable, _type2);
__decorateElement3(_init5, 4, "collisionDetector", _collisionDetector_dec, Droppable, _collisionDetector);
__decorateElement3(_init5, 4, "collisionPriority", _collisionPriority_dec, Droppable, _collisionPriority);
__decorateElement3(_init5, 4, "shape", _shape_dec, Droppable, _shape);
__decorateElement3(_init5, 2, "isDropTarget", _isDropTarget_dec, Droppable);
__decoratorMetadata3(_init5, Droppable);
var Sensor = class extends Plugin {
  /**
   * Creates a new sensor instance.
   *
   * @param manager - The drag drop manager instance
   * @param options - Optional sensor configuration
   */
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.options = options2;
  }
};
var Modifier = class extends Plugin {
  /**
   * Creates a new modifier instance.
   *
   * @param manager - The drag and drop manager that owns this modifier
   * @param options - Optional configuration for the modifier
   */
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.options = options2;
  }
  /**
   * Applies the modifier to the current drag operation.
   *
   * @param operation - The current state of the drag operation
   * @returns The transformed coordinates
   *
   * @remarks
   * Override this method to implement custom transformation logic.
   * The default implementation returns the original transform unchanged.
   */
  apply(operation) {
    return operation.transform;
  }
};
var DragDropRegistry = class {
  /**
   * Creates a new registry instance.
   *
   * @param manager - The drag and drop manager that owns this registry
   */
  constructor(manager) {
    this.draggables = new EntityRegistry();
    this.droppables = new EntityRegistry();
    this.plugins = new PluginRegistry(manager);
    this.sensors = new PluginRegistry(manager);
    this.modifiers = new PluginRegistry(manager);
  }
  register(input, options2) {
    if (input instanceof Draggable) {
      return this.draggables.register(input.id, input);
    }
    if (input instanceof Droppable) {
      return this.droppables.register(input.id, input);
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.register(input, options2);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.register(input, options2);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.register(input, options2);
    }
    throw new Error("Invalid instance type");
  }
  unregister(input) {
    if (input instanceof Entity) {
      if (input instanceof Draggable) {
        return this.draggables.unregister(input.id, input);
      }
      if (input instanceof Droppable) {
        return this.droppables.unregister(input.id, input);
      }
      return () => {
      };
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.unregister(input);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.unregister(input);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.unregister(input);
    }
    throw new Error("Invalid instance type");
  }
  /**
   * Destroys all registered entities and cleans up resources.
   *
   * @remarks
   * This method:
   * - Destroys all draggable and droppable entities
   * - Destroys all plugins, sensors, and modifiers
   * - Cleans up any associated resources
   */
  destroy() {
    this.draggables.destroy();
    this.droppables.destroy();
    this.plugins.destroy();
    this.sensors.destroy();
    this.modifiers.destroy();
  }
};
var _transform_dec;
var _target_dec;
var _source_dec;
var _modifiers_dec2;
var _targetIdentifier_dec;
var _sourceIdentifier_dec;
var _activatorEvent_dec;
var _canceled_dec;
var _shape_dec2;
var _manager2;
var _previousSource;
var _shape2;
var _init6;
var _canceled;
var _activatorEvent;
var _sourceIdentifier;
var _targetIdentifier;
var _modifiers2;
var _transform;
_shape_dec2 = [derived], _canceled_dec = [reactive], _activatorEvent_dec = [reactive], _sourceIdentifier_dec = [reactive], _targetIdentifier_dec = [reactive], _modifiers_dec2 = [reactive], _source_dec = [derived], _target_dec = [derived], _transform_dec = [derived];
var DragOperation = class {
  /**
   * Creates a new drag operation instance.
   *
   * @param manager - The drag and drop manager that owns this operation
   */
  constructor(manager) {
    __runInitializers3(_init6, 5, this);
    __privateAdd3(this, _manager2);
    __privateAdd3(this, _previousSource);
    __privateAdd3(this, _shape2, new ValueHistory(
      void 0,
      (a2, b2) => a2 && b2 ? a2.equals(b2) : a2 === b2
    ));
    this.status = new Status();
    __privateAdd3(this, _canceled, __runInitializers3(_init6, 8, this, false)), __runInitializers3(_init6, 11, this);
    __privateAdd3(this, _activatorEvent, __runInitializers3(_init6, 12, this, null)), __runInitializers3(_init6, 15, this);
    __privateAdd3(this, _sourceIdentifier, __runInitializers3(_init6, 16, this, null)), __runInitializers3(_init6, 19, this);
    __privateAdd3(this, _targetIdentifier, __runInitializers3(_init6, 20, this, null)), __runInitializers3(_init6, 23, this);
    __privateAdd3(this, _modifiers2, __runInitializers3(_init6, 24, this, [])), __runInitializers3(_init6, 27, this);
    this.position = new Position({ x: 0, y: 0 });
    __privateAdd3(this, _transform, { x: 0, y: 0 });
    __privateSet3(this, _manager2, manager);
  }
  get shape() {
    const { current, initial, previous } = __privateGet3(this, _shape2);
    if (!current || !initial) {
      return null;
    }
    return { current, initial, previous };
  }
  /**
   * Sets the shape of the dragged entity.
   *
   * @param value - The new shape or null to reset
   */
  set shape(value) {
    if (!value) {
      __privateGet3(this, _shape2).reset();
    } else {
      __privateGet3(this, _shape2).current = value;
    }
  }
  get source() {
    var _a5;
    const identifier = this.sourceIdentifier;
    if (identifier == null)
      return null;
    const value = __privateGet3(this, _manager2).registry.draggables.get(identifier);
    if (value) {
      __privateSet3(this, _previousSource, value);
    }
    return (_a5 = value != null ? value : __privateGet3(this, _previousSource)) != null ? _a5 : null;
  }
  get target() {
    var _a5;
    const identifier = this.targetIdentifier;
    return identifier != null ? (_a5 = __privateGet3(this, _manager2).registry.droppables.get(identifier)) != null ? _a5 : null : null;
  }
  get transform() {
    const { x, y: y2 } = this.position.delta;
    let transform = { x, y: y2 };
    for (const modifier of this.modifiers) {
      transform = modifier.apply(__spreadProps3(__spreadValues4({}, this.snapshot()), {
        transform
      }));
    }
    __privateSet3(this, _transform, transform);
    return transform;
  }
  /**
   * Creates a snapshot of the current drag operation state.
   *
   * @returns An immutable snapshot of the current operation state
   */
  snapshot() {
    return n(() => ({
      source: this.source,
      target: this.target,
      activatorEvent: this.activatorEvent,
      transform: __privateGet3(this, _transform),
      shape: this.shape ? snapshot(this.shape) : null,
      position: snapshot(this.position),
      status: snapshot(this.status),
      canceled: this.canceled
    }));
  }
  /**
   * Resets the drag operation to its initial state.
   *
   * @remarks
   * This method:
   * - Sets status to idle
   * - Clears source and target identifiers
   * - Resets shape history
   * - Resets position and transform
   * - Clears modifiers
   */
  reset() {
    r(() => {
      this.status.set(
        "idle"
        /* Idle */
      );
      this.sourceIdentifier = null;
      this.targetIdentifier = null;
      __privateGet3(this, _shape2).reset();
      this.position.reset({ x: 0, y: 0 });
      __privateSet3(this, _transform, { x: 0, y: 0 });
      this.modifiers = [];
    });
  }
};
_init6 = __decoratorStart3(null);
_manager2 = /* @__PURE__ */ new WeakMap();
_previousSource = /* @__PURE__ */ new WeakMap();
_shape2 = /* @__PURE__ */ new WeakMap();
_canceled = /* @__PURE__ */ new WeakMap();
_activatorEvent = /* @__PURE__ */ new WeakMap();
_sourceIdentifier = /* @__PURE__ */ new WeakMap();
_targetIdentifier = /* @__PURE__ */ new WeakMap();
_modifiers2 = /* @__PURE__ */ new WeakMap();
_transform = /* @__PURE__ */ new WeakMap();
__decorateElement3(_init6, 2, "shape", _shape_dec2, DragOperation);
__decorateElement3(_init6, 4, "canceled", _canceled_dec, DragOperation, _canceled);
__decorateElement3(_init6, 4, "activatorEvent", _activatorEvent_dec, DragOperation, _activatorEvent);
__decorateElement3(_init6, 4, "sourceIdentifier", _sourceIdentifier_dec, DragOperation, _sourceIdentifier);
__decorateElement3(_init6, 4, "targetIdentifier", _targetIdentifier_dec, DragOperation, _targetIdentifier);
__decorateElement3(_init6, 4, "modifiers", _modifiers_dec2, DragOperation, _modifiers2);
__decorateElement3(_init6, 2, "source", _source_dec, DragOperation);
__decorateElement3(_init6, 2, "target", _target_dec, DragOperation);
__decorateElement3(_init6, 2, "transform", _transform_dec, DragOperation);
__decoratorMetadata3(_init6, DragOperation);
var defaultRenderer = {
  get rendering() {
    return Promise.resolve();
  }
};
var DragDropManager = class {
  /**
   * Creates a new drag and drop manager instance.
   *
   * @param config - Optional configuration for plugins, sensors, modifiers, and renderer
   */
  constructor(config) {
    this.destroy = () => {
      if (!this.dragOperation.status.idle) {
        this.actions.stop({ canceled: true });
      }
      this.dragOperation.modifiers.forEach((modifier) => modifier.destroy());
      this.registry.destroy();
      this.collisionObserver.destroy();
    };
    const {
      plugins = [],
      sensors = [],
      modifiers = [],
      renderer = defaultRenderer
    } = config != null ? config : {};
    const monitor = new DragDropMonitor(this);
    const registry = new DragDropRegistry(this);
    this.registry = registry;
    this.monitor = monitor;
    this.renderer = renderer;
    this.actions = new DragActions(this);
    this.dragOperation = new DragOperation(this);
    this.collisionObserver = new CollisionObserver(this);
    this.plugins = [CollisionNotifier, ...plugins];
    this.modifiers = modifiers;
    this.sensors = sensors;
    const { destroy } = this;
    const cleanup = effects(() => {
      var _a5, _b3, _c32;
      const currentModifiers = n(() => this.dragOperation.modifiers);
      const managerModifiers = this.modifiers;
      if (currentModifiers !== managerModifiers) {
        currentModifiers.forEach((modifier) => modifier.destroy());
      }
      this.dragOperation.modifiers = (_c32 = (_b3 = (_a5 = this.dragOperation.source) == null ? void 0 : _a5.modifiers) == null ? void 0 : _b3.map((modifier) => {
        const { plugin, options: options2 } = descriptor(modifier);
        return new plugin(this, options2);
      })) != null ? _c32 : managerModifiers;
    });
    this.destroy = () => {
      cleanup();
      destroy();
    };
  }
  /**
   * Gets the list of active plugins.
   *
   * @returns Array of active plugin instances
   */
  get plugins() {
    return this.registry.plugins.values;
  }
  /**
   * Sets the list of plugins to be used by the manager.
   *
   * @param plugins - Array of plugin constructors or instances
   */
  set plugins(plugins) {
    this.registry.plugins.values = plugins;
  }
  /**
   * Gets the list of active modifiers.
   *
   * @returns Array of active modifier instances
   */
  get modifiers() {
    return this.registry.modifiers.values;
  }
  /**
   * Sets the list of modifiers to be used by the manager.
   *
   * @param modifiers - Array of modifier constructors or instances
   */
  set modifiers(modifiers) {
    this.registry.modifiers.values = modifiers;
  }
  /**
   * Gets the list of active sensors.
   *
   * @returns Array of active sensor instances
   */
  get sensors() {
    return this.registry.sensors.values;
  }
  /**
   * Sets the list of sensors to be used by the manager.
   *
   * @param sensors - Array of sensor constructors or instances
   */
  set sensors(sensors) {
    this.registry.sensors.values = sensors;
  }
};

// node_modules/@dnd-kit/dom/utilities.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod4 = (obj, member, method) => (__accessCheck4(obj, member, "access private method"), method);
function isKeyframeEffect(effect) {
  if (!effect)
    return false;
  if (effect instanceof KeyframeEffect)
    return true;
  return "getKeyframes" in effect && typeof effect.getKeyframes === "function";
}
function getFinalKeyframe(element, match) {
  const animations2 = element.getAnimations();
  if (animations2.length > 0) {
    for (const animation of animations2) {
      if (animation.playState !== "running")
        continue;
      const { effect } = animation;
      const keyframes = isKeyframeEffect(effect) ? effect.getKeyframes() : [];
      const matchedKeyframes = keyframes.filter(match);
      if (matchedKeyframes.length > 0) {
        return [matchedKeyframes[matchedKeyframes.length - 1], animation];
      }
    }
  }
  return null;
}
function getBoundingRectangle(element) {
  const { width, height, top, left, bottom, right } = element.getBoundingClientRect();
  return { width, height, top, left, bottom, right };
}
var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
  elementString === "[object global]";
}
function isNode(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _a5, _b3, _c4;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  if ("defaultView" in target) {
    return (_a5 = target.defaultView) != null ? _a5 : window;
  }
  return (_c4 = (_b3 = target.ownerDocument) == null ? void 0 : _b3.defaultView) != null ? _c4 : window;
}
function isDocument(node) {
  const { Document } = getWindow(node);
  return node instanceof Document || "nodeType" in node && node.nodeType === Node.DOCUMENT_NODE;
}
function isHTMLElement(node) {
  if (!node || isWindow(node))
    return false;
  return node instanceof getWindow(node).HTMLElement || "namespaceURI" in node && typeof node.namespaceURI === "string" && node.namespaceURI.endsWith("html");
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement || "namespaceURI" in node && typeof node.namespaceURI === "string" && node.namespaceURI.endsWith("svg");
}
function getDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target) || isSVGElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
function getViewportBoundingRectangle(element) {
  const { documentElement } = getDocument(element);
  const width = documentElement.clientWidth;
  const height = documentElement.clientHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isOverflowVisible(element, style) {
  if (isDetailsElement(element) && element.open === false) {
    return false;
  }
  const { overflow, overflowX, overflowY } = getComputedStyle(element);
  return overflow === "visible" && overflowX === "visible" && overflowY === "visible";
}
function isDetailsElement(element) {
  return element.tagName === "DETAILS";
}
function getVisibleBoundingRectangle(element, boundingClientRect = element.getBoundingClientRect(), margin = 0) {
  var _a5;
  let rect = boundingClientRect;
  const { ownerDocument } = element;
  const ownerWindow = (_a5 = ownerDocument.defaultView) != null ? _a5 : window;
  let ancestor = element.parentElement;
  while (ancestor && ancestor !== ownerDocument.documentElement) {
    if (!isOverflowVisible(ancestor)) {
      const ancestorRect = ancestor.getBoundingClientRect();
      const marginTop = margin * (ancestorRect.bottom - ancestorRect.top);
      const marginRight = margin * (ancestorRect.right - ancestorRect.left);
      const marginBottom = margin * (ancestorRect.bottom - ancestorRect.top);
      const marginLeft = margin * (ancestorRect.right - ancestorRect.left);
      rect = {
        top: Math.max(rect.top, ancestorRect.top - marginTop),
        right: Math.min(rect.right, ancestorRect.right + marginRight),
        bottom: Math.min(rect.bottom, ancestorRect.bottom + marginBottom),
        left: Math.max(rect.left, ancestorRect.left - marginLeft),
        width: 0,
        // Will be calculated next
        height: 0
        // Will be calculated next
      };
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;
    }
    ancestor = ancestor.parentElement;
  }
  const viewportWidth = ownerWindow.innerWidth;
  const viewportHeight = ownerWindow.innerHeight;
  const viewportMarginY = margin * viewportHeight;
  const viewportMarginX = margin * viewportWidth;
  rect = {
    top: Math.max(rect.top, 0 - viewportMarginY),
    right: Math.min(rect.right, viewportWidth + viewportMarginX),
    bottom: Math.min(rect.bottom, viewportHeight + viewportMarginY),
    left: Math.max(rect.left, 0 - viewportMarginX),
    width: 0,
    // Will be calculated next
    height: 0
    // Will be calculated next
  };
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  if (rect.width < 0) {
    rect.width = 0;
  }
  if (rect.height < 0) {
    rect.height = 0;
  }
  return rect;
}
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function cloneElement(element) {
  const selector = "input, textarea, select, canvas, [contenteditable]";
  const clonedElement = element.cloneNode(true);
  const fields = Array.from(element.querySelectorAll(selector));
  const clonedFields = Array.from(clonedElement.querySelectorAll(selector));
  clonedFields.forEach((field, index) => {
    const originalField = fields[index];
    if (isField(field) && isField(originalField)) {
      if (field.type !== "file") {
        field.value = originalField.value;
      }
      if (field.type === "radio" && field.name) {
        field.name = `Cloned__${field.name}`;
      }
    }
    if (isCanvasElement(field) && isCanvasElement(originalField) && originalField.width > 0 && originalField.height > 0) {
      const destCtx = field.getContext("2d");
      destCtx == null ? void 0 : destCtx.drawImage(originalField, 0, 0);
    }
  });
  return clonedElement;
}
function isField(element) {
  return "value" in element;
}
function isCanvasElement(element) {
  return element.tagName === "CANVAS";
}
function getElementFromPoint(document2, { x, y: y2 }) {
  const element = document2.elementFromPoint(x, y2);
  if (isIFrameElement(element)) {
    const { contentDocument } = element;
    if (contentDocument) {
      const { left, top } = element.getBoundingClientRect();
      return getElementFromPoint(contentDocument, {
        x: x - left,
        y: y2 - top
      });
    }
  }
  return element;
}
function isIFrameElement(element) {
  return (element == null ? void 0 : element.tagName) === "IFRAME";
}
var ProxiedElements = /* @__PURE__ */ new WeakMap();
var Listeners = class {
  constructor() {
    this.entries = /* @__PURE__ */ new Set();
    this.clear = () => {
      for (const entry of this.entries) {
        const [target, { type, listener, options: options2 }] = entry;
        target.removeEventListener(type, listener, options2);
      }
      this.entries.clear();
    };
  }
  bind(target, input) {
    const listeners = Array.isArray(input) ? input : [input];
    const entries = [];
    for (const descriptor2 of listeners) {
      const { type, listener, options: options2 } = descriptor2;
      const entry = [target, descriptor2];
      target.addEventListener(type, listener, options2);
      this.entries.add(entry);
      entries.push(entry);
    }
    return function cleanup() {
      for (const [target2, { type, listener, options: options2 }] of entries) {
        target2.removeEventListener(type, listener, options2);
      }
    };
  }
};
function getFrameElement(el) {
  const refWindow = el == null ? void 0 : el.ownerDocument.defaultView;
  if (refWindow && refWindow.self !== refWindow.parent) {
    return refWindow.frameElement;
  }
}
function getFrameElements(el) {
  const frames = /* @__PURE__ */ new Set();
  let frame = getFrameElement(el);
  while (frame) {
    frames.add(frame);
    frame = getFrameElement(frame);
  }
  return frames;
}
function timeout(callback, duration) {
  const id = setTimeout(callback, duration);
  return () => clearTimeout(id);
}
function throttle(func, limit) {
  const time = () => performance.now();
  let cancel;
  let lastRan;
  return function(...args) {
    const context = this;
    if (!lastRan) {
      func.apply(context, args);
      lastRan = time();
    } else {
      cancel == null ? void 0 : cancel();
      cancel = timeout(
        () => {
          func.apply(context, args);
          lastRan = time();
        },
        limit - (time() - lastRan)
      );
    }
  };
}
function isRectEqual(a2, b2) {
  if (a2 === b2)
    return true;
  if (!a2 || !b2)
    return false;
  return a2.top == b2.top && a2.left == b2.left && a2.right == b2.right && a2.bottom == b2.bottom;
}
function isVisible(element, boundingClientRect = element.getBoundingClientRect()) {
  const { width, height } = getVisibleBoundingRectangle(
    element,
    boundingClientRect
  );
  return width > 0 && height > 0;
}
var Observer = canUseDOM ? ResizeObserver : class MockResizeObserver {
  observe() {
  }
  unobserve() {
  }
  disconnect() {
  }
};
var _initialized;
var ResizeNotifier = class extends Observer {
  constructor(callback) {
    super((entries) => {
      if (!__privateGet4(this, _initialized)) {
        __privateSet4(this, _initialized, true);
        return;
      }
      callback(entries, this);
    });
    __privateAdd4(this, _initialized, false);
  }
};
_initialized = /* @__PURE__ */ new WeakMap();
var threshold = Array.from({ length: 100 }, (_2, index) => index / 100);
var THROTTLE_INTERVAL = 75;
var _visible;
var _previousBoundingClientRect;
var _resizeObserver;
var _positionObserver;
var _visibilityObserver;
var _debug;
var _disconnected;
var _observePosition;
var _PositionObserver_instances;
var notify_fn;
var updateDebug_fn;
var PositionObserver = class {
  constructor(element, callback, options2 = {
    debug: false,
    skipInitial: false
  }) {
    this.element = element;
    this.callback = callback;
    __privateAdd4(this, _PositionObserver_instances);
    this.disconnect = () => {
      var _a5, _b3, _c4;
      __privateSet4(this, _disconnected, true);
      (_a5 = __privateGet4(this, _resizeObserver)) == null ? void 0 : _a5.disconnect();
      (_b3 = __privateGet4(this, _positionObserver)) == null ? void 0 : _b3.disconnect();
      __privateGet4(this, _visibilityObserver).disconnect();
      (_c4 = __privateGet4(this, _debug)) == null ? void 0 : _c4.remove();
    };
    __privateAdd4(this, _visible, true);
    __privateAdd4(this, _previousBoundingClientRect);
    __privateAdd4(this, _resizeObserver);
    __privateAdd4(this, _positionObserver);
    __privateAdd4(this, _visibilityObserver);
    __privateAdd4(this, _debug);
    __privateAdd4(this, _disconnected, false);
    __privateAdd4(this, _observePosition, throttle(() => {
      var _a5, _b3, _c4;
      const { element: element2 } = this;
      (_a5 = __privateGet4(this, _positionObserver)) == null ? void 0 : _a5.disconnect();
      if (__privateGet4(this, _disconnected) || !__privateGet4(this, _visible) || !element2.isConnected) {
        return;
      }
      const root2 = (_b3 = element2.ownerDocument) != null ? _b3 : document;
      const { innerHeight, innerWidth } = (_c4 = root2.defaultView) != null ? _c4 : window;
      const clientRect = element2.getBoundingClientRect();
      const visibleRect = getVisibleBoundingRectangle(element2, clientRect);
      const { top, left, bottom, right } = visibleRect;
      const insetTop = -Math.floor(top);
      const insetLeft = -Math.floor(left);
      const insetRight = -Math.floor(innerWidth - right);
      const insetBottom = -Math.floor(innerHeight - bottom);
      const rootMargin = `${insetTop}px ${insetRight}px ${insetBottom}px ${insetLeft}px`;
      this.boundingClientRect = clientRect;
      __privateSet4(this, _positionObserver, new IntersectionObserver(
        (entries) => {
          const [entry] = entries;
          const { intersectionRect } = entry;
          const intersectionRatio = entry.intersectionRatio !== 1 ? entry.intersectionRatio : Rectangle.intersectionRatio(
            intersectionRect,
            getVisibleBoundingRectangle(element2)
          );
          if (intersectionRatio !== 1) {
            __privateGet4(this, _observePosition).call(this);
          }
        },
        {
          threshold,
          rootMargin,
          root: root2
        }
      ));
      __privateGet4(this, _positionObserver).observe(element2);
      __privateMethod4(this, _PositionObserver_instances, notify_fn).call(this);
    }, THROTTLE_INTERVAL));
    this.boundingClientRect = element.getBoundingClientRect();
    __privateSet4(this, _visible, isVisible(element, this.boundingClientRect));
    let initial = true;
    this.callback = (boundingClientRect) => {
      if (initial) {
        initial = false;
        if (options2.skipInitial)
          return;
      }
      callback(boundingClientRect);
    };
    const root = element.ownerDocument;
    if (options2 == null ? void 0 : options2.debug) {
      __privateSet4(this, _debug, document.createElement("div"));
      __privateGet4(this, _debug).style.background = "rgba(0,0,0,0.15)";
      __privateGet4(this, _debug).style.position = "fixed";
      __privateGet4(this, _debug).style.pointerEvents = "none";
      root.body.appendChild(__privateGet4(this, _debug));
    }
    __privateSet4(this, _visibilityObserver, new IntersectionObserver(
      (entries) => {
        var _a5, _b3;
        const entry = entries[entries.length - 1];
        const { boundingClientRect, isIntersecting: visible } = entry;
        const { width, height } = boundingClientRect;
        const previousVisible = __privateGet4(this, _visible);
        __privateSet4(this, _visible, visible);
        if (!width && !height)
          return;
        if (previousVisible && !visible) {
          (_a5 = __privateGet4(this, _positionObserver)) == null ? void 0 : _a5.disconnect();
          this.callback(null);
          (_b3 = __privateGet4(this, _resizeObserver)) == null ? void 0 : _b3.disconnect();
          __privateSet4(this, _resizeObserver, void 0);
          if (__privateGet4(this, _debug))
            __privateGet4(this, _debug).style.visibility = "hidden";
        } else {
          __privateGet4(this, _observePosition).call(this);
        }
        if (visible && !__privateGet4(this, _resizeObserver)) {
          __privateSet4(this, _resizeObserver, new ResizeNotifier(__privateGet4(this, _observePosition)));
          __privateGet4(this, _resizeObserver).observe(element);
        }
      },
      {
        threshold,
        root
      }
    ));
    if (__privateGet4(this, _visible) && !options2.skipInitial) {
      this.callback(this.boundingClientRect);
    }
    __privateGet4(this, _visibilityObserver).observe(element);
  }
};
_visible = /* @__PURE__ */ new WeakMap();
_previousBoundingClientRect = /* @__PURE__ */ new WeakMap();
_resizeObserver = /* @__PURE__ */ new WeakMap();
_positionObserver = /* @__PURE__ */ new WeakMap();
_visibilityObserver = /* @__PURE__ */ new WeakMap();
_debug = /* @__PURE__ */ new WeakMap();
_disconnected = /* @__PURE__ */ new WeakMap();
_observePosition = /* @__PURE__ */ new WeakMap();
_PositionObserver_instances = /* @__PURE__ */ new WeakSet();
notify_fn = function() {
  if (__privateGet4(this, _disconnected))
    return;
  __privateMethod4(this, _PositionObserver_instances, updateDebug_fn).call(this);
  if (isRectEqual(this.boundingClientRect, __privateGet4(this, _previousBoundingClientRect)))
    return;
  this.callback(this.boundingClientRect);
  __privateSet4(this, _previousBoundingClientRect, this.boundingClientRect);
};
updateDebug_fn = function() {
  if (__privateGet4(this, _debug)) {
    const { top, left, width, height } = getVisibleBoundingRectangle(
      this.element
    );
    __privateGet4(this, _debug).style.overflow = "hidden";
    __privateGet4(this, _debug).style.visibility = "visible";
    __privateGet4(this, _debug).style.top = `${Math.floor(top)}px`;
    __privateGet4(this, _debug).style.left = `${Math.floor(left)}px`;
    __privateGet4(this, _debug).style.width = `${Math.floor(width)}px`;
    __privateGet4(this, _debug).style.height = `${Math.floor(height)}px`;
  }
};
var framePositionObservers = /* @__PURE__ */ new WeakMap();
var scrollListeners = /* @__PURE__ */ new WeakMap();
function addFrameListener(frame, callback) {
  let cached = framePositionObservers.get(frame);
  if (!cached) {
    const observer = new PositionObserver(
      frame,
      (boundingClientRect) => {
        const cached2 = framePositionObservers.get(frame);
        if (!cached2)
          return;
        cached2.callbacks.forEach((callback2) => callback2(boundingClientRect));
      },
      { skipInitial: true }
    );
    cached = { disconnect: observer.disconnect, callbacks: /* @__PURE__ */ new Set() };
  }
  cached.callbacks.add(callback);
  framePositionObservers.set(frame, cached);
  return () => {
    cached.callbacks.delete(callback);
    if (cached.callbacks.size === 0) {
      framePositionObservers.delete(frame);
      cached.disconnect();
    }
  };
}
function observeParentFrames(frames, callback) {
  const cleanup = /* @__PURE__ */ new Set();
  for (const frame of frames) {
    const remove2 = addFrameListener(frame, callback);
    cleanup.add(remove2);
  }
  return () => cleanup.forEach((remove2) => remove2());
}
function addScrollListener(element, callback) {
  var _a5;
  const doc = element.ownerDocument;
  if (!scrollListeners.has(doc)) {
    const controller = new AbortController();
    const listeners2 = /* @__PURE__ */ new Set();
    document.addEventListener(
      "scroll",
      (event) => listeners2.forEach((listener) => listener(event)),
      {
        capture: true,
        passive: true,
        signal: controller.signal
      }
    );
    scrollListeners.set(doc, { disconnect: () => controller.abort(), listeners: listeners2 });
  }
  const { listeners, disconnect } = (_a5 = scrollListeners.get(doc)) != null ? _a5 : {};
  if (!listeners || !disconnect)
    return () => {
    };
  listeners.add(callback);
  return () => {
    listeners.delete(callback);
    if (listeners.size === 0) {
      disconnect();
      scrollListeners.delete(doc);
    }
  };
}
var _elementObserver;
var _disconnected2;
var _frames;
var _handleScroll;
var FrameObserver = class {
  constructor(element, callback, options2) {
    this.callback = callback;
    __privateAdd4(this, _elementObserver);
    __privateAdd4(this, _disconnected2, false);
    __privateAdd4(this, _frames);
    __privateAdd4(this, _handleScroll, throttle((event) => {
      if (__privateGet4(this, _disconnected2))
        return;
      if (!event.target)
        return;
      if ("contains" in event.target && typeof event.target.contains === "function") {
        for (const frame of __privateGet4(this, _frames)) {
          if (event.target.contains(frame)) {
            this.callback(__privateGet4(this, _elementObserver).boundingClientRect);
            break;
          }
        }
      }
    }, THROTTLE_INTERVAL));
    const frames = getFrameElements(element);
    const unobserveParentFrames = observeParentFrames(frames, callback);
    const removeScrollListener = addScrollListener(element, __privateGet4(this, _handleScroll));
    __privateSet4(this, _frames, frames);
    __privateSet4(this, _elementObserver, new PositionObserver(element, callback, options2));
    this.disconnect = () => {
      if (__privateGet4(this, _disconnected2))
        return;
      __privateSet4(this, _disconnected2, true);
      unobserveParentFrames();
      removeScrollListener();
      __privateGet4(this, _elementObserver).disconnect();
    };
  }
};
_elementObserver = /* @__PURE__ */ new WeakMap();
_disconnected2 = /* @__PURE__ */ new WeakMap();
_frames = /* @__PURE__ */ new WeakMap();
_handleScroll = /* @__PURE__ */ new WeakMap();
function supportsPopover(element) {
  return "showPopover" in element && "hidePopover" in element && typeof element.showPopover === "function" && typeof element.hidePopover === "function";
}
function showPopover(element) {
  try {
    if (supportsPopover(element) && element.isConnected && element.hasAttribute("popover") && // This selector can throw an error in browsers that don't support it
    !element.matches(":popover-open")) {
      element.showPopover();
    }
  } catch (error) {
  }
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === getDocument(element).scrollingElement;
}
function getScrollPosition(scrollableElement) {
  const window2 = getWindow(scrollableElement);
  const rect = isDocumentScrollingElement(scrollableElement) ? getViewportBoundingRectangle(scrollableElement) : getBoundingRectangle(scrollableElement);
  const dimensions = isDocumentScrollingElement(scrollableElement) ? {
    height: window2.innerHeight,
    width: window2.innerWidth
  } : {
    height: scrollableElement.clientHeight,
    width: scrollableElement.clientWidth
  };
  const position = {
    current: {
      x: scrollableElement.scrollLeft,
      y: scrollableElement.scrollTop
    },
    max: {
      x: scrollableElement.scrollWidth - dimensions.width,
      y: scrollableElement.scrollHeight - dimensions.height
    }
  };
  const isTop = position.current.y <= 0;
  const isLeft = position.current.x <= 0;
  const isBottom = position.current.y >= position.max.y;
  const isRight = position.current.x >= position.max.x;
  return {
    rect,
    position,
    isTop,
    isLeft,
    isBottom,
    isRight
  };
}
function canScroll(scrollableElement, by) {
  const { isTop, isBottom, isLeft, isRight, position } = getScrollPosition(scrollableElement);
  const { x, y: y2 } = by != null ? by : { x: 0, y: 0 };
  const top = !isTop && position.current.y + y2 > 0;
  const bottom = !isBottom && position.current.y + y2 < position.max.y;
  const left = !isLeft && position.current.x + x > 0;
  const right = !isRight && position.current.x + x < position.max.x;
  return {
    top,
    bottom,
    left,
    right,
    x: left || right,
    y: top || bottom
  };
}
var Scheduler = class {
  constructor(scheduler4) {
    this.scheduler = scheduler4;
    this.pending = false;
    this.tasks = /* @__PURE__ */ new Set();
    this.resolvers = /* @__PURE__ */ new Set();
    this.flush = () => {
      const { tasks, resolvers } = this;
      this.pending = false;
      this.tasks = /* @__PURE__ */ new Set();
      this.resolvers = /* @__PURE__ */ new Set();
      for (const task of tasks) {
        task();
      }
      for (const resolve of resolvers) {
        resolve();
      }
    };
  }
  schedule(task) {
    this.tasks.add(task);
    if (!this.pending) {
      this.pending = true;
      this.scheduler(this.flush);
    }
    return new Promise((resolve) => this.resolvers.add(resolve));
  }
};
var scheduler = new Scheduler((callback) => {
  if (typeof requestAnimationFrame === "function") {
    requestAnimationFrame(callback);
  } else {
    callback();
  }
});
var scheduler2 = new Scheduler((callback) => setTimeout(callback, 50));
var cachedStyles = /* @__PURE__ */ new Map();
var clear = cachedStyles.clear.bind(cachedStyles);
function getComputedStyles(element, cached = false) {
  if (!cached)
    return computeStyles(element);
  let styles2 = cachedStyles.get(element);
  if (styles2)
    return styles2;
  styles2 = computeStyles(element);
  cachedStyles.set(element, styles2);
  scheduler2.schedule(clear);
  return styles2;
}
function computeStyles(element) {
  return getWindow(element).getComputedStyle(element);
}
function isFixed(node, computedStyle = getComputedStyles(node, true)) {
  return computedStyle.position === "fixed" || computedStyle.position === "sticky";
}
function isScrollable(element, computedStyle = getComputedStyles(element, true)) {
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
var defaultOptions = {
  excludeElement: true
};
function getScrollableAncestors(element, options2 = defaultOptions) {
  const { limit, excludeElement } = options2;
  const scrollParents = /* @__PURE__ */ new Set();
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.size >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.has(node.scrollingElement)) {
      scrollParents.add(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node)) {
      if (isSVGElement(node)) {
        return findScrollableAncestors(node.parentElement);
      }
      return scrollParents;
    }
    if (scrollParents.has(node)) {
      return scrollParents;
    }
    const computedStyle = getComputedStyles(node, true);
    if (excludeElement && node === element)
      ;
    else if (isScrollable(node, computedStyle)) {
      scrollParents.add(node);
    }
    if (isFixed(node, computedStyle)) {
      const { scrollingElement } = node.ownerDocument;
      if (scrollingElement)
        scrollParents.add(scrollingElement);
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, { limit: 1 });
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getFrameTransform(el, boundary = window.frameElement) {
  const transform = {
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1
  };
  if (!el)
    return transform;
  let frame = getFrameElement(el);
  while (frame) {
    if (frame === boundary) {
      return transform;
    }
    const rect = getBoundingRectangle(frame);
    const { x: scaleX, y: scaleY } = getScale(frame, rect);
    transform.x = transform.x + rect.left;
    transform.y = transform.y + rect.top;
    transform.scaleX = transform.scaleX * scaleX;
    transform.scaleY = transform.scaleY * scaleY;
    frame = getFrameElement(frame);
  }
  return transform;
}
function getScale(element, boundingRectangle = getBoundingRectangle(element)) {
  const width = Math.round(boundingRectangle.width);
  const height = Math.round(boundingRectangle.height);
  if (isHTMLElement(element)) {
    return {
      x: width / element.offsetWidth,
      y: height / element.offsetHeight
    };
  }
  const styles2 = getComputedStyles(element, true);
  return {
    x: (parseFloat(styles2.width) || width) / width,
    y: (parseFloat(styles2.height) || height) / height
  };
}
function parseScale(scale) {
  if (scale === "none") {
    return null;
  }
  const values = scale.split(" ");
  const x = parseFloat(values[0]);
  const y2 = parseFloat(values[1]);
  if (isNaN(x) && isNaN(y2)) {
    return null;
  }
  return {
    x: isNaN(x) ? y2 : x,
    y: isNaN(y2) ? x : y2
  };
}
function parseTranslate(translate) {
  if (translate === "none") {
    return null;
  }
  const [x, y2, z = "0"] = translate.split(" ");
  const output = { x: parseFloat(x), y: parseFloat(y2), z: parseInt(z, 10) };
  if (isNaN(output.x) && isNaN(output.y)) {
    return null;
  }
  return {
    x: isNaN(output.x) ? 0 : output.x,
    y: isNaN(output.y) ? 0 : output.y,
    z: isNaN(output.z) ? 0 : output.z
  };
}
function parseTransform(computedStyles) {
  var _a5, _b3, _c4, _d2, _e, _f, _g, _h, _i;
  const { scale, transform, translate } = computedStyles;
  const parsedScale = parseScale(scale);
  const parsedTranslate = parseTranslate(translate);
  const parsedMatrix = parseTransformMatrix(transform);
  if (!parsedMatrix && !parsedScale && !parsedTranslate) {
    return null;
  }
  const normalizedScale = {
    x: (_a5 = parsedScale == null ? void 0 : parsedScale.x) != null ? _a5 : 1,
    y: (_b3 = parsedScale == null ? void 0 : parsedScale.y) != null ? _b3 : 1
  };
  const normalizedTranslate = {
    x: (_c4 = parsedTranslate == null ? void 0 : parsedTranslate.x) != null ? _c4 : 0,
    y: (_d2 = parsedTranslate == null ? void 0 : parsedTranslate.y) != null ? _d2 : 0
  };
  const normalizedMatrix = {
    x: (_e = parsedMatrix == null ? void 0 : parsedMatrix.x) != null ? _e : 0,
    y: (_f = parsedMatrix == null ? void 0 : parsedMatrix.y) != null ? _f : 0,
    scaleX: (_g = parsedMatrix == null ? void 0 : parsedMatrix.scaleX) != null ? _g : 1,
    scaleY: (_h = parsedMatrix == null ? void 0 : parsedMatrix.scaleY) != null ? _h : 1
  };
  return {
    x: normalizedTranslate.x + normalizedMatrix.x,
    y: normalizedTranslate.y + normalizedMatrix.y,
    z: (_i = parsedTranslate == null ? void 0 : parsedTranslate.z) != null ? _i : 0,
    scaleX: normalizedScale.x * normalizedMatrix.scaleX,
    scaleY: normalizedScale.y * normalizedMatrix.scaleY
  };
}
function parseTransformMatrix(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
var ScrollDirection = ((ScrollDirection2) => {
  ScrollDirection2[ScrollDirection2["Idle"] = 0] = "Idle";
  ScrollDirection2[ScrollDirection2["Forward"] = 1] = "Forward";
  ScrollDirection2[ScrollDirection2["Reverse"] = -1] = "Reverse";
  return ScrollDirection2;
})(ScrollDirection || {});
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
var defaultTolerance = {
  x: 10,
  y: 10
};
function detectScrollIntent(scrollableElement, coordinates, intent, acceleration = 25, thresholdPercentage = defaultThreshold, tolerance = defaultTolerance) {
  const { x, y: y2 } = coordinates;
  const { rect, isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollableElement);
  const frameTransform = getFrameTransform(scrollableElement);
  const computedStyles = getComputedStyles(scrollableElement, true);
  const parsedTransform = parseTransform(computedStyles);
  const isXAxisInverted = parsedTransform !== null ? (parsedTransform == null ? void 0 : parsedTransform.scaleX) < 0 : false;
  const isYAxisInverted = parsedTransform !== null ? (parsedTransform == null ? void 0 : parsedTransform.scaleY) < 0 : false;
  const scrollContainerRect = new Rectangle(
    rect.left * frameTransform.scaleX + frameTransform.x,
    rect.top * frameTransform.scaleY + frameTransform.y,
    rect.width * frameTransform.scaleX,
    rect.height * frameTransform.scaleY
  );
  const direction = {
    x: 0,
    y: 0
    /* Idle */
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold2 = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if ((!isTop || isYAxisInverted && !isBottom) && y2 <= scrollContainerRect.top + threshold2.height && (intent == null ? void 0 : intent.y) !== 1 && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {
    direction.y = isYAxisInverted ? 1 : -1;
    speed.y = acceleration * Math.abs(
      (scrollContainerRect.top + threshold2.height - y2) / threshold2.height
    );
  } else if ((!isBottom || isYAxisInverted && !isTop) && y2 >= scrollContainerRect.bottom - threshold2.height && (intent == null ? void 0 : intent.y) !== -1 && x >= scrollContainerRect.left - tolerance.x && x <= scrollContainerRect.right + tolerance.x) {
    direction.y = isYAxisInverted ? -1 : 1;
    speed.y = acceleration * Math.abs(
      (scrollContainerRect.bottom - threshold2.height - y2) / threshold2.height
    );
  }
  if ((!isRight || isXAxisInverted && !isLeft) && x >= scrollContainerRect.right - threshold2.width && (intent == null ? void 0 : intent.x) !== -1 && y2 >= scrollContainerRect.top - tolerance.y && y2 <= scrollContainerRect.bottom + tolerance.y) {
    direction.x = isXAxisInverted ? -1 : 1;
    speed.x = acceleration * Math.abs(
      (scrollContainerRect.right - threshold2.width - x) / threshold2.width
    );
  } else if ((!isLeft || isXAxisInverted && !isRight) && x <= scrollContainerRect.left + threshold2.width && (intent == null ? void 0 : intent.x) !== 1 && y2 >= scrollContainerRect.top - tolerance.y && y2 <= scrollContainerRect.bottom + tolerance.y) {
    direction.x = isXAxisInverted ? 1 : -1;
    speed.x = acceleration * Math.abs(
      (scrollContainerRect.left + threshold2.width - x) / threshold2.width
    );
  }
  return {
    direction,
    speed
  };
}
function supportsScrollIntoViewIfNeeded(element) {
  return "scrollIntoViewIfNeeded" in element && typeof element.scrollIntoViewIfNeeded === "function";
}
function scrollIntoViewIfNeeded(el, centerIfNeeded = false) {
  if (supportsScrollIntoViewIfNeeded(el)) {
    el.scrollIntoViewIfNeeded(centerIfNeeded);
    return;
  }
  if (!isHTMLElement(el)) {
    return el.scrollIntoView();
  }
  var parent = getFirstScrollableAncestor(el);
  if (!isHTMLElement(parent)) {
    return;
  }
  const parentComputedStyle = getComputedStyles(parent, true), parentBorderTopWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-top-width")
  ), parentBorderLeftWidth = parseInt(
    parentComputedStyle.getPropertyValue("border-left-width")
  ), overTop = el.offsetTop - parent.offsetTop < parent.scrollTop, overBottom = el.offsetTop - parent.offsetTop + el.clientHeight - parentBorderTopWidth > parent.scrollTop + parent.clientHeight, overLeft = el.offsetLeft - parent.offsetLeft < parent.scrollLeft, overRight = el.offsetLeft - parent.offsetLeft + el.clientWidth - parentBorderLeftWidth > parent.scrollLeft + parent.clientWidth, alignWithTop = overTop && !overBottom;
  if ((overTop || overBottom) && centerIfNeeded) {
    parent.scrollTop = el.offsetTop - parent.offsetTop - parent.clientHeight / 2 - parentBorderTopWidth + el.clientHeight / 2;
  }
  if ((overLeft || overRight) && centerIfNeeded) {
    parent.scrollLeft = el.offsetLeft - parent.offsetLeft - parent.clientWidth / 2 - parentBorderLeftWidth + el.clientWidth / 2;
  }
  if ((overTop || overBottom || overLeft || overRight) && !centerIfNeeded) {
    el.scrollIntoView(alignWithTop);
  }
}
function applyTransform(rect, parsedTransform, transformOrigin) {
  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;
  const x = rect.left + translateX + (1 - scaleX) * parseFloat(transformOrigin);
  const y2 = rect.top + translateY + (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX ? rect.width * scaleX : rect.width;
  const h2 = scaleY ? rect.height * scaleY : rect.height;
  return {
    width: w2,
    height: h2,
    top: y2,
    right: x + w2,
    bottom: y2 + h2,
    left: x
  };
}
function inverseTransform(rect, parsedTransform, transformOrigin) {
  const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;
  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y2 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w2 = scaleX ? rect.width / scaleX : rect.width;
  const h2 = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w2,
    height: h2,
    top: y2,
    right: x + w2,
    bottom: y2 + h2,
    left: x
  };
}
function animateTransform({ element, keyframes, options: options2 }) {
  return element.animate(keyframes, options2).finished;
}
function computeTranslate(element, translate = getComputedStyles(element).translate, projected = true) {
  if (projected) {
    const keyframe = getFinalKeyframe(
      element,
      (keyframe2) => "translate" in keyframe2
    );
    if (keyframe) {
      const { translate: translate2 = "" } = keyframe[0];
      if (typeof translate2 === "string") {
        const finalTranslate = parseTranslate(translate2);
        if (finalTranslate) {
          return finalTranslate;
        }
      }
    }
  }
  if (translate) {
    const finalTranslate = parseTranslate(translate);
    if (finalTranslate) {
      return finalTranslate;
    }
  }
  return { x: 0, y: 0, z: 0 };
}
var scheduler3 = new Scheduler((callback) => setTimeout(callback, 0));
var animations = /* @__PURE__ */ new Map();
var clear2 = animations.clear.bind(animations);
function getDocumentAnimations(element) {
  const document2 = element.ownerDocument;
  let documentAnimations = animations.get(document2);
  if (documentAnimations)
    return documentAnimations;
  documentAnimations = document2.getAnimations();
  animations.set(document2, documentAnimations);
  scheduler3.schedule(clear2);
  const elementAnimations = documentAnimations.filter(
    (animation) => isKeyframeEffect(animation.effect) && animation.effect.target === element
  );
  animations.set(element, elementAnimations);
  return documentAnimations;
}
function forceFinishAnimations(element, options2) {
  const animations2 = getDocumentAnimations(element).filter((animation) => {
    var _a5, _b3;
    if (isKeyframeEffect(animation.effect)) {
      const { target } = animation.effect;
      const isValidTarget = (_b3 = target && ((_a5 = options2.isValidTarget) == null ? void 0 : _a5.call(options2, target))) != null ? _b3 : true;
      if (isValidTarget) {
        return animation.effect.getKeyframes().some((keyframe) => {
          for (const property of options2.properties) {
            if (keyframe[property])
              return true;
          }
        });
      }
    }
  }).map((animation) => {
    const { effect, currentTime } = animation;
    const duration = effect == null ? void 0 : effect.getComputedTiming().duration;
    if (animation.pending || animation.playState === "finished")
      return;
    if (typeof duration == "number" && typeof currentTime == "number" && currentTime < duration) {
      animation.currentTime = duration;
      return () => {
        animation.currentTime = currentTime;
      };
    }
  });
  if (animations2.length > 0) {
    return () => animations2.forEach((reset) => reset == null ? void 0 : reset());
  }
}
var DOMRectangle = class extends Rectangle {
  constructor(element, options2 = {}) {
    var _a5, _b3, _c4, _d2;
    const {
      frameTransform = getFrameTransform(element),
      ignoreTransforms,
      getBoundingClientRect = getBoundingRectangle
    } = options2;
    const resetAnimations = forceFinishAnimations(element, {
      properties: ["transform", "translate", "scale", "width", "height"],
      isValidTarget: (target) => (target !== element || isSafari()) && target.contains(element)
    });
    const boundingRectangle = getBoundingClientRect(element);
    let { top, left, width, height } = boundingRectangle;
    let updated;
    const computedStyles = getComputedStyles(element);
    const parsedTransform = parseTransform(computedStyles);
    const scale = {
      x: (_a5 = parsedTransform == null ? void 0 : parsedTransform.scaleX) != null ? _a5 : 1,
      y: (_b3 = parsedTransform == null ? void 0 : parsedTransform.scaleY) != null ? _b3 : 1
    };
    const projectedTransform = getProjectedTransform(element, computedStyles);
    resetAnimations == null ? void 0 : resetAnimations();
    if (parsedTransform) {
      updated = inverseTransform(
        boundingRectangle,
        parsedTransform,
        computedStyles.transformOrigin
      );
      if (ignoreTransforms || projectedTransform) {
        top = updated.top;
        left = updated.left;
        width = updated.width;
        height = updated.height;
      }
    }
    const intrinsic = {
      width: (_c4 = updated == null ? void 0 : updated.width) != null ? _c4 : width,
      height: (_d2 = updated == null ? void 0 : updated.height) != null ? _d2 : height
    };
    if (projectedTransform && !ignoreTransforms && updated) {
      const projected = applyTransform(
        updated,
        projectedTransform,
        computedStyles.transformOrigin
      );
      top = projected.top;
      left = projected.left;
      width = projected.width;
      height = projected.height;
      scale.x = projectedTransform.scaleX;
      scale.y = projectedTransform.scaleY;
    }
    if (frameTransform) {
      if (!ignoreTransforms) {
        left *= frameTransform.scaleX;
        width *= frameTransform.scaleX;
        top *= frameTransform.scaleY;
        height *= frameTransform.scaleY;
      }
      left += frameTransform.x;
      top += frameTransform.y;
    }
    super(left, top, width, height);
    this.scale = scale;
    this.intrinsicWidth = intrinsic.width;
    this.intrinsicHeight = intrinsic.height;
  }
};
function getProjectedTransform(element, computedStyles) {
  var _a5;
  const animations2 = element.getAnimations();
  let projectedTransform = null;
  if (!animations2.length)
    return null;
  for (const animation of animations2) {
    if (animation.playState !== "running")
      continue;
    const keyframes = isKeyframeEffect(animation.effect) ? animation.effect.getKeyframes() : [];
    const keyframe = keyframes[keyframes.length - 1];
    if (!keyframe)
      continue;
    const { transform, translate, scale } = keyframe;
    if (transform || translate || scale) {
      const parsedTransform = parseTransform({
        transform: typeof transform === "string" && transform ? transform : computedStyles.transform,
        translate: typeof translate === "string" && translate ? translate : computedStyles.translate,
        scale: typeof scale === "string" && scale ? scale : computedStyles.scale
      });
      if (parsedTransform) {
        projectedTransform = projectedTransform ? {
          x: projectedTransform.x + parsedTransform.x,
          y: projectedTransform.y + parsedTransform.y,
          z: (_a5 = projectedTransform.z) != null ? _a5 : parsedTransform.z,
          scaleX: projectedTransform.scaleX * parsedTransform.scaleX,
          scaleY: projectedTransform.scaleY * parsedTransform.scaleY
        } : parsedTransform;
      }
    }
  }
  return projectedTransform;
}
function supportsStyle(element) {
  return "style" in element && typeof element.style === "object" && element.style !== null && "setProperty" in element.style && "removeProperty" in element.style && typeof element.style.setProperty === "function" && typeof element.style.removeProperty === "function";
}
var Styles = class {
  constructor(element) {
    this.element = element;
    this.initial = /* @__PURE__ */ new Map();
  }
  set(properties, prefix2 = "") {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const [key, value] of Object.entries(properties)) {
      const property = `${prefix2}${key}`;
      if (!this.initial.has(property)) {
        this.initial.set(property, element.style.getPropertyValue(property));
      }
      element.style.setProperty(
        property,
        typeof value === "string" ? value : `${value}px`
      );
    }
  }
  remove(properties, prefix2 = "") {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const key of properties) {
      const property = `${prefix2}${key}`;
      element.style.removeProperty(property);
    }
  }
  reset() {
    const { element } = this;
    if (!supportsStyle(element)) {
      return;
    }
    for (const [key, value] of this.initial) {
      element.style.setProperty(key, value);
    }
    if (element.getAttribute("style") === "") {
      element.removeAttribute("style");
    }
  }
};
function isElement(target) {
  if (!target)
    return false;
  return target instanceof getWindow(target).Element || isNode(target) && target.nodeType === Node.ELEMENT_NODE;
}
function isKeyboardEvent(event) {
  if (!event)
    return false;
  const { KeyboardEvent } = getWindow(event.target);
  return event instanceof KeyboardEvent;
}
function isPointerEvent(event) {
  if (!event)
    return false;
  const { PointerEvent: PointerEvent2 } = getWindow(event.target);
  return event instanceof PointerEvent2;
}
function isTextInput(target) {
  if (!isElement(target))
    return false;
  const { tagName } = target;
  return tagName === "INPUT" || tagName === "TEXTAREA" || isContentEditable(target);
}
function isContentEditable(element) {
  return element.hasAttribute("contenteditable") && element.getAttribute("contenteditable") !== "false";
}
var ids = {};
function generateUniqueId(prefix2) {
  const id = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
  ids[prefix2] = id;
  return `${prefix2}-${id}`;
}

// node_modules/@dnd-kit/collision/dist/index.js
var pointerIntersection = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var shapeIntersection = ({
  dragOperation,
  droppable
}) => {
  const { shape } = dragOperation;
  if (!droppable.shape || !(shape == null ? void 0 : shape.current)) {
    return null;
  }
  const intersectionArea = shape.current.intersectionArea(droppable.shape);
  if (intersectionArea) {
    const { position } = dragOperation;
    const distance = Point.distance(droppable.shape.center, position.current);
    const intersectionRatio = intersectionArea / (shape.current.area + droppable.shape.area - intersectionArea);
    const value = intersectionRatio / distance;
    return {
      id: droppable.id,
      value,
      type: CollisionType.ShapeIntersection,
      priority: CollisionPriority.Normal
    };
  }
  return null;
};
var defaultCollisionDetection = (args) => {
  var _a5;
  return (_a5 = pointerIntersection(args)) != null ? _a5 : shapeIntersection(args);
};
var closestCorners = (input) => {
  const { dragOperation, droppable } = input;
  const { shape, position } = dragOperation;
  if (!droppable.shape) {
    return null;
  }
  const shapeCorners = shape ? Rectangle.from(shape.current.boundingRectangle).corners : void 0;
  const distance = Rectangle.from(
    droppable.shape.boundingRectangle
  ).corners.reduce(
    (acc, corner, index) => {
      var _a5;
      return acc + Point.distance(
        Point.from(corner),
        (_a5 = shapeCorners == null ? void 0 : shapeCorners[index]) != null ? _a5 : position.current
      );
    },
    0
  );
  const value = distance / 4;
  return {
    id: droppable.id,
    value: 1 / value,
    type: CollisionType.Collision,
    priority: CollisionPriority.Normal
  };
};

// node_modules/@dnd-kit/dom/index.js
var __create5 = Object.create;
var __defProp5 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __knownSymbol4 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp5.call(b2, prop))
      __defNormalProp5(a2, prop, b2[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b2)) {
      if (__propIsEnum5.call(b2, prop))
        __defNormalProp5(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps4 = (a2, b2) => __defProps4(a2, __getOwnPropDescs4(b2));
var __name4 = (target, value) => __defProp5(target, "name", { value, configurable: true });
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart4 = (base) => {
  var _a42;
  return [, , , __create5((_a42 = base == null ? void 0 : base[__knownSymbol4("metadata")]) != null ? _a42 : null)];
};
var __decoratorStrings4 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn4 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError5("Function expected") : fn;
var __decoratorContext4 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings4[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError5("Already initialized") : fns.push(__expectFn4(fn || null)) });
var __decoratorMetadata4 = (array, target) => __defNormalProp5(target, __knownSymbol4("metadata"), array[3]);
var __runInitializers4 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++)
    flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement4 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = !!(flags & 8), p2 = !!(flags & 16);
  var j = k > 3 ? array.length + 1 : k ? s2 ? 1 : 2 : 0, key = __decoratorStrings4[k + 5];
  var initializers = k > 3 && (array[j - 1] = []), extraInitializers = array[j] || (array[j] = []);
  var desc = k && (!p2 && !s2 && (target = target.prototype), k < 5 && (k > 3 || !p2) && __getOwnPropDesc5(k < 4 ? target : { get [name]() {
    return __privateGet5(this, extra);
  }, set [name](x) {
    return __privateSet5(this, extra, x);
  } }, name));
  k ? p2 && k < 4 && __name4(extra, (k > 2 ? "set " : k > 1 ? "get " : "") + name) : __name4(target, name);
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext4(k, name, done = {}, array[3], extraInitializers);
    if (k) {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: p2 ? (x) => __privateIn4(target, x) : (x) => name in x };
      if (k ^ 3)
        access.get = p2 ? (x) => (k ^ 1 ? __privateGet5 : __privateMethod5)(x, target, k ^ 4 ? extra : desc.get) : (x) => x[name];
      if (k > 2)
        access.set = p2 ? (x, y2) => __privateSet5(x, target, y2, k ^ 4 ? extra : desc.set) : (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])(k ? k < 4 ? p2 ? extra : desc[key] : k > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k ^ 4 || it === void 0)
      __expectFn4(it) && (k > 4 ? initializers.unshift(it) : k ? p2 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null)
      __typeError5("Object expected");
    else
      __expectFn4(fn = it.get) && (desc.get = fn), __expectFn4(fn = it.set) && (desc.set = fn), __expectFn4(fn = it.init) && initializers.unshift(fn);
  }
  return k || __decoratorMetadata4(array, target), desc && __defProp5(target, name, desc), p2 ? k ^ 4 ? extra : desc : target;
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateIn4 = (member, obj) => Object(obj) !== obj ? __typeError5('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet5 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod5 = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var defaultAttributes = {
  role: "button",
  roleDescription: "draggable"
};
var defaultDescriptionIdPrefix = `dnd-kit-description`;
var defaultAnnouncementIdPrefix = `dnd-kit-announcement`;
var defaultScreenReaderInstructions = {
  draggable: `To pick up a draggable item, press the space bar. While dragging, use the arrow keys to move the item in a given direction. Press space again to drop the item in its new position, or press escape to cancel.`
};
var defaultAnnouncements = {
  dragstart({ operation: { source } }) {
    if (!source)
      return;
    return `Picked up draggable item ${source.id}.`;
  },
  dragover({ operation: { source, target } }) {
    if (!source || source.id === (target == null ? void 0 : target.id))
      return;
    if (target) {
      return `Draggable item ${source.id} was moved over droppable target ${target.id}.`;
    }
    return `Draggable item ${source.id} is no longer over a droppable target.`;
  },
  dragend({ operation: { source, target }, canceled }) {
    if (!source)
      return;
    if (canceled) {
      return `Dragging was cancelled. Draggable item ${source.id} was dropped.`;
    }
    if (target) {
      return `Draggable item ${source.id} was dropped over droppable target ${target.id}`;
    }
    return `Draggable item ${source.id} was dropped.`;
  }
};
function isFocusable(element) {
  const tagName = element.tagName.toLowerCase();
  return ["input", "select", "textarea", "a", "button"].includes(tagName);
}
function createHiddenText(id, value) {
  const element = document.createElement("div");
  element.id = id;
  element.style.setProperty("display", "none");
  element.textContent = value;
  return element;
}
function createLiveRegion(id) {
  const element = document.createElement("div");
  element.id = id;
  element.setAttribute("role", "status");
  element.setAttribute("aria-live", "polite");
  element.setAttribute("aria-atomic", "true");
  element.style.setProperty("position", "fixed");
  element.style.setProperty("width", "1px");
  element.style.setProperty("height", "1px");
  element.style.setProperty("margin", "-1px");
  element.style.setProperty("border", "0");
  element.style.setProperty("padding", "0");
  element.style.setProperty("overflow", "hidden");
  element.style.setProperty("clip", "rect(0 0 0 0)");
  element.style.setProperty("clip-path", "inset(100%)");
  element.style.setProperty("white-space", "nowrap");
  return element;
}
var debouncedEvents = ["dragover", "dragmove"];
var Accessibility = class extends Plugin {
  constructor(manager, options2) {
    super(manager);
    const {
      id,
      idPrefix: {
        description: descriptionPrefix = defaultDescriptionIdPrefix,
        announcement: announcementPrefix = defaultAnnouncementIdPrefix
      } = {},
      announcements = defaultAnnouncements,
      screenReaderInstructions = defaultScreenReaderInstructions,
      debounce: debounceMs = 500
    } = options2 != null ? options2 : {};
    const descriptionId = id ? `${descriptionPrefix}-${id}` : generateUniqueId(descriptionPrefix);
    const announcementId = id ? `${announcementPrefix}-${id}` : generateUniqueId(announcementPrefix);
    let hiddenTextElement;
    let liveRegionElement;
    let liveRegionTextNode;
    let latestAnnouncement;
    const updateAnnouncement = (value = latestAnnouncement) => {
      if (!liveRegionTextNode || !value)
        return;
      if ((liveRegionTextNode == null ? void 0 : liveRegionTextNode.nodeValue) !== value) {
        liveRegionTextNode.nodeValue = value;
      }
    };
    const scheduleUpdateAnnouncement = () => scheduler.schedule(updateAnnouncement);
    const debouncedUpdateAnnouncement = debounce(
      scheduleUpdateAnnouncement,
      debounceMs
    );
    const eventListeners = Object.entries(announcements).map(
      ([eventName, getAnnouncement]) => {
        return this.manager.monitor.addEventListener(
          eventName,
          (event, manager2) => {
            const element = liveRegionTextNode;
            if (!element)
              return;
            const announcement = getAnnouncement == null ? void 0 : getAnnouncement(event, manager2);
            if (announcement && element.nodeValue !== announcement) {
              latestAnnouncement = announcement;
              if (debouncedEvents.includes(eventName)) {
                debouncedUpdateAnnouncement();
              } else {
                scheduleUpdateAnnouncement();
                debouncedUpdateAnnouncement.cancel();
              }
            }
          }
        );
      }
    );
    const initialize = () => {
      let elements = [];
      if (!(hiddenTextElement == null ? void 0 : hiddenTextElement.isConnected)) {
        hiddenTextElement = createHiddenText(
          descriptionId,
          screenReaderInstructions.draggable
        );
        elements.push(hiddenTextElement);
      }
      if (!(liveRegionElement == null ? void 0 : liveRegionElement.isConnected)) {
        liveRegionElement = createLiveRegion(announcementId);
        liveRegionTextNode = document.createTextNode("");
        liveRegionElement.appendChild(liveRegionTextNode);
        elements.push(liveRegionElement);
      }
      if (elements.length > 0) {
        document.body.append(...elements);
      }
    };
    const mutations = /* @__PURE__ */ new Set();
    function executeMutations() {
      for (const operation of mutations) {
        operation();
      }
    }
    this.registerEffect(() => {
      var _a42;
      mutations.clear();
      for (const draggable of this.manager.registry.draggables.value) {
        const activator = (_a42 = draggable.handle) != null ? _a42 : draggable.element;
        if (activator) {
          if (!hiddenTextElement || !liveRegionElement) {
            mutations.add(initialize);
          }
          if ((!isFocusable(activator) || isSafari()) && !activator.hasAttribute("tabindex")) {
            mutations.add(() => activator.setAttribute("tabindex", "0"));
          }
          if (!activator.hasAttribute("role") && !(activator.tagName.toLowerCase() === "button")) {
            mutations.add(
              () => activator.setAttribute("role", defaultAttributes.role)
            );
          }
          if (!activator.hasAttribute("aria-roledescription")) {
            mutations.add(
              () => activator.setAttribute(
                "aria-roledescription",
                defaultAttributes.roleDescription
              )
            );
          }
          if (!activator.hasAttribute("aria-describedby")) {
            mutations.add(
              () => activator.setAttribute("aria-describedby", descriptionId)
            );
          }
          for (const key of ["aria-pressed", "aria-grabbed"]) {
            const value = String(draggable.isDragging);
            if (activator.getAttribute(key) !== value) {
              mutations.add(() => activator.setAttribute(key, value));
            }
          }
          const disabled = String(draggable.disabled);
          if (activator.getAttribute("aria-disabled") !== disabled) {
            mutations.add(
              () => activator.setAttribute("aria-disabled", disabled)
            );
          }
        }
      }
      if (mutations.size > 0) {
        scheduler.schedule(executeMutations);
      }
    });
    this.destroy = () => {
      super.destroy();
      hiddenTextElement == null ? void 0 : hiddenTextElement.remove();
      liveRegionElement == null ? void 0 : liveRegionElement.remove();
      eventListeners.forEach((unsubscribe) => unsubscribe());
    };
  }
};
function debounce(fn, wait) {
  let timeout3;
  const debounced = () => {
    clearTimeout(timeout3);
    timeout3 = setTimeout(fn, wait);
  };
  debounced.cancel = () => clearTimeout(timeout3);
  return debounced;
}
var Cursor = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    const doc = computed(
      () => {
        var _a42;
        return getDocument((_a42 = this.manager.dragOperation.source) == null ? void 0 : _a42.element);
      }
    );
    this.destroy = E(() => {
      var _a42;
      const { dragOperation } = this.manager;
      const { cursor = "grabbing", nonce } = (_a42 = this.options) != null ? _a42 : {};
      if (dragOperation.status.initialized) {
        const document2 = doc.value;
        const style = document2.createElement("style");
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
        style.textContent = `* { cursor: ${cursor} !important; }`;
        document2.head.appendChild(style);
        return () => style.remove();
      }
    });
  }
};
var ATTR_PREFIX = "data-dnd-";
var DROPPING_ATTRIBUTE = `${ATTR_PREFIX}dropping`;
var CSS_PREFIX = "--dnd-";
var ATTRIBUTE = `${ATTR_PREFIX}dragging`;
var PLACEHOLDER_ATTRIBUTE = `${ATTR_PREFIX}placeholder`;
var IGNORED_ATTRIBUTES = [
  ATTRIBUTE,
  PLACEHOLDER_ATTRIBUTE,
  "popover",
  "aria-pressed",
  "aria-grabbing"
];
var IGNORED_STYLES = ["view-transition-name"];
var CSS_RULES = `
  :root [${ATTRIBUTE}] {
    position: fixed !important;
    pointer-events: none !important;
    touch-action: none;
    z-index: calc(infinity);
    will-change: translate;
    top: var(${CSS_PREFIX}top, 0px) !important;
    left: var(${CSS_PREFIX}left, 0px) !important;
    right: unset !important;
    bottom: unset !important;
    width: var(${CSS_PREFIX}width, auto);
    max-width: var(${CSS_PREFIX}width, auto);
    height: var(${CSS_PREFIX}height, auto);
    max-height: var(${CSS_PREFIX}height, auto);
    transition: var(${CSS_PREFIX}transition) !important;
  }

  :root [${PLACEHOLDER_ATTRIBUTE}] {
    transition: none;
  }

  :root [${PLACEHOLDER_ATTRIBUTE}='hidden'] {
    visibility: hidden;
  }

  [${ATTRIBUTE}] * {
    pointer-events: none !important;
  }

  [${ATTRIBUTE}]:not([${DROPPING_ATTRIBUTE}]) {
    translate: var(${CSS_PREFIX}translate) !important;
  }

  [${ATTRIBUTE}][style*='${CSS_PREFIX}scale'] {
    scale: var(${CSS_PREFIX}scale) !important;
    transform-origin: var(${CSS_PREFIX}transform-origin) !important;
  }

  @layer {
    :where([${ATTRIBUTE}][popover]) {
      overflow: visible;
      background: unset;
      border: unset;
      margin: unset;
      padding: unset;
      color: inherit;

      &:is(input, button) {
        border: revert;
        background: revert;
      }
    }
  }
  [${ATTRIBUTE}]::backdrop, [${ATTR_PREFIX}overlay]:not([${ATTRIBUTE}]) {
    display: none;
    visibility: hidden;
  }
`.replace(/\n+/g, " ").replace(/\s+/g, " ").trim();
function createPlaceholder(source, type = "hidden") {
  return n(() => {
    const { element, manager } = source;
    if (!element || !manager)
      return;
    const containedDroppables = findContainedDroppables(
      element,
      manager.registry.droppables
    );
    const cleanup = [];
    const placeholder = cloneElement(element);
    const { remove: remove2 } = placeholder;
    proxyDroppableElements(containedDroppables, placeholder, cleanup);
    configurePlaceholder(placeholder, type);
    placeholder.remove = () => {
      cleanup.forEach((fn) => fn());
      remove2.call(placeholder);
    };
    return placeholder;
  });
}
function findContainedDroppables(element, droppables) {
  const containedDroppables = /* @__PURE__ */ new Map();
  for (const droppable of droppables) {
    if (!droppable.element)
      continue;
    if (element === droppable.element || element.contains(droppable.element)) {
      const identifierAttribute = `${ATTR_PREFIX}${generateUniqueId("dom-id")}`;
      droppable.element.setAttribute(identifierAttribute, "");
      containedDroppables.set(droppable, identifierAttribute);
    }
  }
  return containedDroppables;
}
function proxyDroppableElements(containedDroppables, placeholder, cleanup) {
  for (const [droppable, identifierAttribute] of containedDroppables) {
    if (!droppable.element)
      continue;
    const selector = `[${identifierAttribute}]`;
    const clonedElement = placeholder.matches(selector) ? placeholder : placeholder.querySelector(selector);
    droppable.element.removeAttribute(identifierAttribute);
    if (!clonedElement)
      continue;
    const originalElement = droppable.element;
    droppable.proxy = clonedElement;
    clonedElement.removeAttribute(identifierAttribute);
    ProxiedElements.set(originalElement, clonedElement);
    cleanup.push(() => {
      ProxiedElements.delete(originalElement);
      droppable.proxy = void 0;
    });
  }
}
function configurePlaceholder(placeholder, type = "hidden") {
  placeholder.setAttribute("inert", "true");
  placeholder.setAttribute("tab-index", "-1");
  placeholder.setAttribute("aria-hidden", "true");
  placeholder.setAttribute(PLACEHOLDER_ATTRIBUTE, type);
}
function isSameFrame(element, target) {
  if (element === target)
    return true;
  return getFrameElement(element) === getFrameElement(target);
}
function preventPopoverClose(event) {
  const { target } = event;
  if ("newState" in event && event.newState === "closed" && isElement(target) && target.hasAttribute("popover")) {
    requestAnimationFrame(() => showPopover(target));
  }
}
function isTableRow(element) {
  return element.tagName === "TR";
}
var styleSheetRegistry = /* @__PURE__ */ new Map();
var _overlay_dec;
var _a3;
var _init7;
var _overlay;
var _Feedback_instances;
var render_fn;
var injectStyles_fn;
var _Feedback = class _Feedback2 extends (_a3 = Plugin, _overlay_dec = [reactive], _a3) {
  constructor(manager, options2) {
    super(manager, options2);
    __privateAdd5(this, _Feedback_instances);
    __privateAdd5(this, _overlay, __runInitializers4(_init7, 8, this)), __runInitializers4(_init7, 11, this);
    this.state = {
      initial: {},
      current: {}
    };
    this.registerEffect(__privateMethod5(this, _Feedback_instances, injectStyles_fn));
    this.registerEffect(__privateMethod5(this, _Feedback_instances, render_fn));
  }
  destroy() {
    super.destroy();
    for (const [doc, registration] of styleSheetRegistry.entries()) {
      if (registration.instances.has(this)) {
        registration.instances.delete(this);
        if (registration.instances.size === 0) {
          registration.cleanup();
          styleSheetRegistry.delete(doc);
        }
      }
    }
  }
};
_init7 = __decoratorStart4(_a3);
_overlay = /* @__PURE__ */ new WeakMap();
_Feedback_instances = /* @__PURE__ */ new WeakSet();
render_fn = function() {
  var _a42, _b22, _c32;
  const { state, manager, options: options2 } = this;
  const { dragOperation } = manager;
  const { position, source, status } = dragOperation;
  if (status.idle) {
    state.current = {};
    state.initial = {};
    return;
  }
  if (!source)
    return;
  const { element, feedback } = source;
  if (!element || feedback === "none" || !status.initialized || status.initializing) {
    return;
  }
  const { initial } = state;
  const feedbackElement = (_a42 = this.overlay) != null ? _a42 : element;
  const frameTransform = getFrameTransform(feedbackElement);
  const elementFrameTransform = getFrameTransform(element);
  const crossFrame = !isSameFrame(element, feedbackElement);
  const shape = new DOMRectangle(element, {
    frameTransform: crossFrame ? elementFrameTransform : null,
    ignoreTransforms: !crossFrame
  });
  const scaleDelta = {
    x: elementFrameTransform.scaleX / frameTransform.scaleX,
    y: elementFrameTransform.scaleY / frameTransform.scaleY
  };
  let { width, height, top, left } = shape;
  if (crossFrame) {
    width = width / scaleDelta.x;
    height = height / scaleDelta.y;
  }
  let elementMutationObserver;
  let documentMutationObserver;
  const styles2 = new Styles(feedbackElement);
  const {
    transition,
    translate,
    boxSizing,
    paddingBlockStart,
    paddingBlockEnd,
    paddingInlineStart,
    paddingInlineEnd,
    borderInlineStartWidth,
    borderInlineEndWidth,
    borderBlockStartWidth,
    borderBlockEndWidth
  } = getComputedStyles(element);
  const clone = feedback === "clone";
  const contentBox = boxSizing === "content-box";
  const widthOffset = contentBox ? parseInt(paddingInlineStart) + parseInt(paddingInlineEnd) + parseInt(borderInlineStartWidth) + parseInt(borderInlineEndWidth) : 0;
  const heightOffset = contentBox ? parseInt(paddingBlockStart) + parseInt(paddingBlockEnd) + parseInt(borderBlockStartWidth) + parseInt(borderBlockEndWidth) : 0;
  const placeholder = feedback !== "move" && !this.overlay ? createPlaceholder(source, clone ? "clone" : "hidden") : null;
  const isKeyboardOperation = n(
    () => isKeyboardEvent(manager.dragOperation.activatorEvent)
  );
  if (translate !== "none") {
    const parsedTranslate = parseTranslate(translate);
    if (parsedTranslate && !initial.translate) {
      initial.translate = parsedTranslate;
    }
  }
  if (!initial.transformOrigin) {
    const current = n(() => position.current);
    initial.transformOrigin = {
      x: (current.x - left * frameTransform.scaleX - frameTransform.x) / (width * frameTransform.scaleX),
      y: (current.y - top * frameTransform.scaleY - frameTransform.y) / (height * frameTransform.scaleY)
    };
  }
  const { transformOrigin } = initial;
  const relativeTop = top * frameTransform.scaleY + frameTransform.y;
  const relativeLeft = left * frameTransform.scaleX + frameTransform.x;
  if (!initial.coordinates) {
    initial.coordinates = {
      x: relativeLeft,
      y: relativeTop
    };
    if (scaleDelta.x !== 1 || scaleDelta.y !== 1) {
      const { scaleX, scaleY } = elementFrameTransform;
      const { x: tX2, y: tY2 } = transformOrigin;
      initial.coordinates.x += (width * scaleX - width) * tX2;
      initial.coordinates.y += (height * scaleY - height) * tY2;
    }
  }
  if (!initial.dimensions) {
    initial.dimensions = { width, height };
  }
  if (!initial.frameTransform) {
    initial.frameTransform = frameTransform;
  }
  const coordinatesDelta = {
    x: initial.coordinates.x - relativeLeft,
    y: initial.coordinates.y - relativeTop
  };
  const sizeDelta = {
    width: (initial.dimensions.width * initial.frameTransform.scaleX - width * frameTransform.scaleX) * transformOrigin.x,
    height: (initial.dimensions.height * initial.frameTransform.scaleY - height * frameTransform.scaleY) * transformOrigin.y
  };
  const delta = {
    x: coordinatesDelta.x / frameTransform.scaleX + sizeDelta.width,
    y: coordinatesDelta.y / frameTransform.scaleY + sizeDelta.height
  };
  const projected = {
    left: left + delta.x,
    top: top + delta.y
  };
  feedbackElement.setAttribute(ATTRIBUTE, "true");
  const transform = n(() => dragOperation.transform);
  const initialTranslate = (_b22 = initial.translate) != null ? _b22 : { x: 0, y: 0 };
  const tX = transform.x * frameTransform.scaleX + initialTranslate.x;
  const tY = transform.y * frameTransform.scaleY + initialTranslate.y;
  const translateString = `${tX}px ${tY}px 0`;
  const transitionString = transition ? `${transition}, translate 0ms linear` : "";
  styles2.set(
    {
      width: width - widthOffset,
      height: height - heightOffset,
      top: projected.top,
      left: projected.left,
      translate: translateString,
      transition: transitionString,
      scale: crossFrame ? `${scaleDelta.x} ${scaleDelta.y}` : "",
      "transform-origin": `${transformOrigin.x * 100}% ${transformOrigin.y * 100}%`
    },
    CSS_PREFIX
  );
  if (placeholder) {
    element.insertAdjacentElement("afterend", placeholder);
    if (options2 == null ? void 0 : options2.rootElement) {
      const root = typeof options2.rootElement === "function" ? options2.rootElement(source) : options2.rootElement;
      root.appendChild(element);
    }
  }
  if (supportsPopover(feedbackElement)) {
    if (!feedbackElement.hasAttribute("popover")) {
      feedbackElement.setAttribute("popover", "manual");
    }
    showPopover(feedbackElement);
    feedbackElement.addEventListener("beforetoggle", preventPopoverClose);
  }
  const resizeObserver = new ResizeObserver(() => {
    if (!placeholder)
      return;
    const placeholderShape = new DOMRectangle(placeholder, {
      frameTransform,
      ignoreTransforms: true
    });
    const origin = transformOrigin != null ? transformOrigin : { x: 1, y: 1 };
    const dX = (width - placeholderShape.width) * origin.x + delta.x;
    const dY = (height - placeholderShape.height) * origin.y + delta.y;
    styles2.set(
      {
        width: placeholderShape.width - widthOffset,
        height: placeholderShape.height - heightOffset,
        top: top + dY,
        left: left + dX
      },
      CSS_PREFIX
    );
    elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();
    if (isTableRow(element) && isTableRow(placeholder)) {
      const cells = Array.from(element.cells);
      const placeholderCells = Array.from(placeholder.cells);
      for (const [index, cell] of cells.entries()) {
        const placeholderCell = placeholderCells[index];
        cell.style.width = `${placeholderCell.offsetWidth}px`;
      }
    }
    dragOperation.shape = new DOMRectangle(feedbackElement);
  });
  const initialShape = new DOMRectangle(feedbackElement);
  n(() => dragOperation.shape = initialShape);
  const feedbackWindow = getWindow(feedbackElement);
  const handleWindowResize = (event) => {
    this.manager.actions.stop({ event });
  };
  if (isKeyboardOperation) {
    feedbackWindow.addEventListener("resize", handleWindowResize);
  }
  if (n(() => source.status) === "idle") {
    requestAnimationFrame(() => source.status = "dragging");
  }
  if (placeholder) {
    resizeObserver.observe(placeholder);
    elementMutationObserver = new MutationObserver((mutations) => {
      let hasChildrenMutations = false;
      for (const mutation of mutations) {
        if (mutation.target !== element) {
          hasChildrenMutations = true;
          continue;
        }
        if (mutation.type !== "attributes") {
          continue;
        }
        const attributeName = mutation.attributeName;
        if (attributeName.startsWith("aria-") || IGNORED_ATTRIBUTES.includes(attributeName)) {
          continue;
        }
        const attributeValue = element.getAttribute(attributeName);
        if (attributeName === "style") {
          if (supportsStyle(element) && supportsStyle(placeholder)) {
            const styles22 = element.style;
            for (const key of Array.from(placeholder.style)) {
              if (styles22.getPropertyValue(key) === "") {
                placeholder.style.removeProperty(key);
              }
            }
            for (const key of Array.from(styles22)) {
              if (IGNORED_STYLES.includes(key) || key.startsWith(CSS_PREFIX)) {
                continue;
              }
              const value = styles22.getPropertyValue(key);
              placeholder.style.setProperty(key, value);
            }
          }
        } else if (attributeValue !== null) {
          placeholder.setAttribute(attributeName, attributeValue);
        } else {
          placeholder.removeAttribute(attributeName);
        }
      }
      if (hasChildrenMutations && clone) {
        placeholder.innerHTML = element.innerHTML;
      }
    });
    elementMutationObserver.observe(element, {
      attributes: true,
      subtree: true,
      childList: true
    });
    documentMutationObserver = new MutationObserver((entries) => {
      for (const entry of entries) {
        if (entry.addedNodes.length === 0)
          continue;
        for (const node of Array.from(entry.addedNodes)) {
          if (node.contains(element) && element.nextElementSibling !== placeholder) {
            element.insertAdjacentElement("afterend", placeholder);
            showPopover(feedbackElement);
            return;
          }
          if (node.contains(placeholder) && placeholder.previousElementSibling !== element) {
            placeholder.insertAdjacentElement("beforebegin", element);
            showPopover(feedbackElement);
            return;
          }
        }
      }
    });
    documentMutationObserver.observe(element.ownerDocument.body, {
      childList: true,
      subtree: true
    });
  }
  const id = (_c32 = manager.dragOperation.source) == null ? void 0 : _c32.id;
  const restoreFocus = () => {
    var _a5;
    if (!isKeyboardOperation || id == null) {
      return;
    }
    const draggable = manager.registry.draggables.get(id);
    const element2 = (_a5 = draggable == null ? void 0 : draggable.handle) != null ? _a5 : draggable == null ? void 0 : draggable.element;
    if (isHTMLElement(element2)) {
      element2.focus();
    }
  };
  const cleanup = () => {
    elementMutationObserver == null ? void 0 : elementMutationObserver.disconnect();
    documentMutationObserver == null ? void 0 : documentMutationObserver.disconnect();
    resizeObserver.disconnect();
    feedbackWindow.removeEventListener("resize", handleWindowResize);
    if (supportsPopover(feedbackElement)) {
      feedbackElement.removeEventListener(
        "beforetoggle",
        preventPopoverClose
      );
      feedbackElement.removeAttribute("popover");
    }
    feedbackElement.removeAttribute(ATTRIBUTE);
    styles2.reset();
    source.status = "idle";
    const moved = state.current.translate != null;
    if (placeholder && (moved || placeholder.parentElement !== feedbackElement.parentElement) && feedbackElement.isConnected) {
      placeholder.replaceWith(feedbackElement);
    }
    placeholder == null ? void 0 : placeholder.remove();
  };
  const cleanupEffects = effects(
    // Update transform on move
    () => {
      var _a5;
      const { transform: transform2, status: status2 } = dragOperation;
      if (!transform2.x && !transform2.y && !state.current.translate) {
        return;
      }
      if (status2.dragging) {
        const initialTranslate2 = (_a5 = initial.translate) != null ? _a5 : { x: 0, y: 0 };
        const translate2 = {
          x: transform2.x / frameTransform.scaleX + initialTranslate2.x,
          y: transform2.y / frameTransform.scaleY + initialTranslate2.y
        };
        const previousTranslate = state.current.translate;
        const modifiers = n(() => dragOperation.modifiers);
        const currentShape = n(() => {
          var _a6;
          return (_a6 = dragOperation.shape) == null ? void 0 : _a6.current;
        });
        const translateTransition = isKeyboardOperation ? "250ms cubic-bezier(0.25, 1, 0.5, 1)" : "0ms linear";
        styles2.set(
          {
            transition: `${transition}, translate ${translateTransition}`,
            translate: `${translate2.x}px ${translate2.y}px 0`
          },
          CSS_PREFIX
        );
        elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();
        if (currentShape && currentShape !== initialShape && previousTranslate && !modifiers.length) {
          const delta2 = Point.delta(translate2, previousTranslate);
          dragOperation.shape = Rectangle.from(
            currentShape.boundingRectangle
          ).translate(
            // Need to take into account frame transform when optimistically updating shape
            delta2.x * frameTransform.scaleX,
            delta2.y * frameTransform.scaleY
          );
        } else {
          dragOperation.shape = new DOMRectangle(feedbackElement);
        }
        state.current.translate = translate2;
      }
    },
    // Drop animation
    function() {
      if (dragOperation.status.dropped) {
        this.dispose();
        source.status = "dropping";
        let translate2 = state.current.translate;
        const moved = translate2 != null;
        if (!translate2 && element !== feedbackElement) {
          translate2 = {
            x: 0,
            y: 0
          };
        }
        if (!translate2) {
          cleanup();
          return;
        }
        const dropAnimation = () => {
          var _a5, _b3;
          {
            showPopover(feedbackElement);
            const [, animation] = (_a5 = getFinalKeyframe(
              feedbackElement,
              (keyframe) => "translate" in keyframe
            )) != null ? _a5 : [];
            animation == null ? void 0 : animation.pause();
            const target = placeholder != null ? placeholder : element;
            const options22 = {
              frameTransform: isSameFrame(feedbackElement, target) ? null : void 0
            };
            const current = new DOMRectangle(feedbackElement, options22);
            const currentTranslate = (_b3 = parseTranslate(getComputedStyles(feedbackElement).translate)) != null ? _b3 : translate2;
            const final = new DOMRectangle(target, options22);
            const delta2 = Rectangle.delta(current, final, source.alignment);
            const finalTranslate = {
              x: currentTranslate.x - delta2.x,
              y: currentTranslate.y - delta2.y
            };
            const heightKeyframes = Math.round(current.intrinsicHeight) !== Math.round(final.intrinsicHeight) ? {
              minHeight: [
                `${current.intrinsicHeight}px`,
                `${final.intrinsicHeight}px`
              ],
              maxHeight: [
                `${current.intrinsicHeight}px`,
                `${final.intrinsicHeight}px`
              ]
            } : {};
            const widthKeyframes = Math.round(current.intrinsicWidth) !== Math.round(final.intrinsicWidth) ? {
              minWidth: [
                `${current.intrinsicWidth}px`,
                `${final.intrinsicWidth}px`
              ],
              maxWidth: [
                `${current.intrinsicWidth}px`,
                `${final.intrinsicWidth}px`
              ]
            } : {};
            styles2.set({ transition }, CSS_PREFIX);
            feedbackElement.setAttribute(DROPPING_ATTRIBUTE, "");
            elementMutationObserver == null ? void 0 : elementMutationObserver.takeRecords();
            animateTransform({
              element: feedbackElement,
              keyframes: __spreadProps4(__spreadValues5(__spreadValues5({}, heightKeyframes), widthKeyframes), {
                translate: [
                  `${currentTranslate.x}px ${currentTranslate.y}px 0`,
                  `${finalTranslate.x}px ${finalTranslate.y}px 0`
                ]
              }),
              options: {
                duration: moved || feedbackElement !== element ? 250 : 0,
                easing: "ease"
              }
            }).then(() => {
              feedbackElement.removeAttribute(DROPPING_ATTRIBUTE);
              animation == null ? void 0 : animation.finish();
              cleanup();
              requestAnimationFrame(restoreFocus);
            });
          }
        };
        manager.renderer.rendering.then(dropAnimation);
      }
    }
  );
  return () => {
    cleanup();
    cleanupEffects();
  };
};
injectStyles_fn = function() {
  var _a42, _b22, _c32;
  const { status, source, target } = this.manager.dragOperation;
  const { nonce } = (_a42 = this.options) != null ? _a42 : {};
  if (status.initializing) {
    const sourceDocument = getDocument((_b22 = source == null ? void 0 : source.element) != null ? _b22 : null);
    const targetDocument = getDocument((_c32 = target == null ? void 0 : target.element) != null ? _c32 : null);
    const documents = /* @__PURE__ */ new Set([sourceDocument, targetDocument]);
    for (const doc of documents) {
      let registration = styleSheetRegistry.get(doc);
      if (!registration) {
        const style = document.createElement("style");
        style.textContent = CSS_RULES;
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
        doc.head.prepend(style);
        const mutationObserver = new MutationObserver((entries) => {
          for (const entry of entries) {
            if (entry.type === "childList") {
              const removedNodes = Array.from(entry.removedNodes);
              if (removedNodes.length > 0 && removedNodes.includes(style)) {
                doc.head.prepend(style);
              }
            }
          }
        });
        mutationObserver.observe(doc.head, { childList: true });
        registration = {
          cleanup: () => {
            mutationObserver.disconnect();
            style.remove();
          },
          instances: /* @__PURE__ */ new Set()
        };
        styleSheetRegistry.set(doc, registration);
      }
      registration.instances.add(this);
    }
  }
};
__decorateElement4(_init7, 4, "overlay", _overlay_dec, _Feedback, _overlay);
__decoratorMetadata4(_init7, _Feedback);
_Feedback.configure = configurator(_Feedback);
var Feedback = _Feedback;
var LOCKED = true;
var UNLOCKED = false;
var _dec;
var _a22;
var _dec2;
var _b2;
var _init23;
var __b;
var __a;
_b2 = (_dec2 = [reactive], ScrollDirection.Forward), _a22 = (_dec = [reactive], ScrollDirection.Reverse);
var ScrollLock = class {
  constructor() {
    __privateAdd5(this, __b, __runInitializers4(_init23, 8, this, LOCKED)), __runInitializers4(_init23, 11, this);
    __privateAdd5(this, __a, __runInitializers4(_init23, 12, this, LOCKED)), __runInitializers4(_init23, 15, this);
  }
  isLocked(direction) {
    if (direction === ScrollDirection.Idle) {
      return false;
    }
    if (direction == null) {
      return this[ScrollDirection.Forward] === LOCKED && this[ScrollDirection.Reverse] === LOCKED;
    }
    return this[direction] === LOCKED;
  }
  unlock(direction) {
    if (direction === ScrollDirection.Idle) {
      return;
    }
    this[direction] = UNLOCKED;
  }
};
_init23 = __decoratorStart4(null);
__b = /* @__PURE__ */ new WeakMap();
__a = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init23, 4, _b2, _dec2, ScrollLock, __b);
__decorateElement4(_init23, 4, _a22, _dec, ScrollLock, __a);
__decoratorMetadata4(_init23, ScrollLock);
var DIRECTIONS = [ScrollDirection.Forward, ScrollDirection.Reverse];
var ScrollIntent = class {
  constructor() {
    this.x = new ScrollLock();
    this.y = new ScrollLock();
  }
  isLocked() {
    return this.x.isLocked() && this.y.isLocked();
  }
};
var ScrollIntentTracker = class extends Plugin {
  constructor(manager) {
    super(manager);
    const scrollIntent = d(new ScrollIntent());
    let previousDelta = null;
    this.signal = scrollIntent;
    E(() => {
      const { status } = manager.dragOperation;
      if (!status.initialized) {
        previousDelta = null;
        scrollIntent.value = new ScrollIntent();
        return;
      }
      const { delta } = manager.dragOperation.position;
      if (previousDelta) {
        const directions = {
          x: getDirection(delta.x, previousDelta.x),
          y: getDirection(delta.y, previousDelta.y)
        };
        const intent = scrollIntent.peek();
        r(() => {
          for (const axis of Axes) {
            for (const direction of DIRECTIONS) {
              if (directions[axis] === direction) {
                intent[axis].unlock(direction);
              }
            }
          }
          scrollIntent.value = intent;
        });
      }
      previousDelta = delta;
    });
  }
  get current() {
    return this.signal.peek();
  }
};
function getDirection(a2, b2) {
  return Math.sign(a2 - b2);
}
var _autoScrolling_dec;
var _a32;
var _init33;
var _autoScrolling;
var _meta;
var _scroll;
var Scroller = class extends (_a32 = CorePlugin, _autoScrolling_dec = [reactive], _a32) {
  constructor(manager) {
    super(manager);
    __privateAdd5(this, _autoScrolling, __runInitializers4(_init33, 8, this, false)), __runInitializers4(_init33, 11, this);
    __privateAdd5(this, _meta);
    __privateAdd5(this, _scroll, () => {
      if (!__privateGet5(this, _meta)) {
        return;
      }
      const { element, by } = __privateGet5(this, _meta);
      if (by.y)
        element.scrollTop += by.y;
      if (by.x)
        element.scrollLeft += by.x;
    });
    this.scroll = (options2) => {
      var _a42;
      if (this.disabled) {
        return false;
      }
      const elements = this.getScrollableElements();
      if (!elements) {
        __privateSet5(this, _meta, void 0);
        return false;
      }
      const { position } = this.manager.dragOperation;
      const currentPosition = position == null ? void 0 : position.current;
      if (currentPosition) {
        const { by } = options2 != null ? options2 : {};
        const intent = by ? {
          x: getScrollIntent(by.x),
          y: getScrollIntent(by.y)
        } : void 0;
        const scrollIntent = intent ? void 0 : this.scrollIntentTracker.current;
        if (scrollIntent == null ? void 0 : scrollIntent.isLocked()) {
          return false;
        }
        for (const scrollableElement of elements) {
          const elementCanScroll = canScroll(scrollableElement, by);
          if (elementCanScroll.x || elementCanScroll.y) {
            const { speed, direction } = detectScrollIntent(
              scrollableElement,
              currentPosition,
              intent
            );
            if (scrollIntent) {
              for (const axis of Axes) {
                if (scrollIntent[axis].isLocked(direction[axis])) {
                  speed[axis] = 0;
                  direction[axis] = 0;
                }
              }
            }
            if (direction.x || direction.y) {
              const { x, y: y2 } = by != null ? by : direction;
              const scrollLeftBy = x * speed.x;
              const scrollTopBy = y2 * speed.y;
              if (scrollLeftBy || scrollTopBy) {
                const previousScrollBy = (_a42 = __privateGet5(this, _meta)) == null ? void 0 : _a42.by;
                if (this.autoScrolling && previousScrollBy) {
                  const scrollIntentMismatch = previousScrollBy.x && !scrollLeftBy || previousScrollBy.y && !scrollTopBy;
                  if (scrollIntentMismatch)
                    continue;
                }
                __privateSet5(this, _meta, {
                  element: scrollableElement,
                  by: {
                    x: scrollLeftBy,
                    y: scrollTopBy
                  }
                });
                scheduler.schedule(__privateGet5(this, _scroll));
                return true;
              }
            }
          }
        }
      }
      __privateSet5(this, _meta, void 0);
      return false;
    };
    let previousElementFromPoint = null;
    let previousScrollableElements = null;
    const elementFromPoint = computed(() => {
      const { position, source } = manager.dragOperation;
      if (!position) {
        return null;
      }
      const element = getElementFromPoint(
        getDocument(source == null ? void 0 : source.element),
        position.current
      );
      if (element) {
        previousElementFromPoint = element;
      }
      return element != null ? element : previousElementFromPoint;
    });
    const scrollableElements = computed(() => {
      const element = elementFromPoint.value;
      const { documentElement } = getDocument(element);
      if (!element || element === documentElement) {
        const { target } = manager.dragOperation;
        const targetElement = target == null ? void 0 : target.element;
        if (targetElement) {
          const elements = getScrollableAncestors(targetElement, {
            excludeElement: false
          });
          previousScrollableElements = elements;
          return elements;
        }
      }
      if (element) {
        const elements = getScrollableAncestors(element, {
          excludeElement: false
        });
        if (this.autoScrolling && previousScrollableElements && elements.size < (previousScrollableElements == null ? void 0 : previousScrollableElements.size)) {
          return previousScrollableElements;
        }
        previousScrollableElements = elements;
        return elements;
      }
      previousScrollableElements = null;
      return null;
    }, deepEqual);
    this.getScrollableElements = () => {
      return scrollableElements.value;
    };
    this.scrollIntentTracker = new ScrollIntentTracker(manager);
    this.destroy = manager.monitor.addEventListener("dragmove", (event) => {
      if (this.disabled || event.defaultPrevented || !isKeyboardEvent(manager.dragOperation.activatorEvent) || !event.by) {
        return;
      }
      if (this.scroll({ by: event.by })) {
        event.preventDefault();
      }
    });
  }
};
_init33 = __decoratorStart4(_a32);
_autoScrolling = /* @__PURE__ */ new WeakMap();
_meta = /* @__PURE__ */ new WeakMap();
_scroll = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init33, 4, "autoScrolling", _autoScrolling_dec, Scroller, _autoScrolling);
__decoratorMetadata4(_init33, Scroller);
function getScrollIntent(value) {
  if (value > 0) {
    return ScrollDirection.Forward;
  }
  if (value < 0) {
    return ScrollDirection.Reverse;
  }
  return ScrollDirection.Idle;
}
var Scheduler2 = class {
  constructor(scheduler5) {
    this.scheduler = scheduler5;
    this.pending = false;
    this.tasks = /* @__PURE__ */ new Set();
    this.resolvers = /* @__PURE__ */ new Set();
    this.flush = () => {
      const { tasks, resolvers } = this;
      this.pending = false;
      this.tasks = /* @__PURE__ */ new Set();
      this.resolvers = /* @__PURE__ */ new Set();
      for (const task of tasks) {
        task();
      }
      for (const resolve of resolvers) {
        resolve();
      }
    };
  }
  schedule(task) {
    this.tasks.add(task);
    if (!this.pending) {
      this.pending = true;
      this.scheduler(this.flush);
    }
    return new Promise((resolve) => this.resolvers.add(resolve));
  }
};
var scheduler32 = new Scheduler2((callback) => {
  if (typeof requestAnimationFrame === "function") {
    requestAnimationFrame(callback);
  } else {
    callback();
  }
});
var AUTOSCROLL_INTERVAL = 10;
var AutoScroller = class extends Plugin {
  constructor(manager, _options) {
    super(manager);
    const scroller = manager.registry.plugins.get(Scroller);
    if (!scroller) {
      throw new Error("AutoScroller plugin depends on Scroller plugin");
    }
    this.destroy = E(() => {
      if (this.disabled) {
        return;
      }
      const { position: _2, status } = manager.dragOperation;
      if (status.dragging) {
        const canScroll2 = scroller.scroll();
        if (canScroll2) {
          scroller.autoScrolling = true;
          const interval = setInterval(
            () => scheduler32.schedule(scroller.scroll),
            AUTOSCROLL_INTERVAL
          );
          return () => {
            clearInterval(interval);
          };
        } else {
          scroller.autoScrolling = false;
        }
      }
    });
  }
};
var listenerOptions = {
  capture: true,
  passive: true
};
var _timeout;
var ScrollListener = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    __privateAdd5(this, _timeout);
    this.handleScroll = () => {
      if (__privateGet5(this, _timeout) == null) {
        __privateSet5(this, _timeout, setTimeout(() => {
          this.manager.collisionObserver.forceUpdate(false);
          __privateSet5(this, _timeout, void 0);
        }, 50));
      }
    };
    const { dragOperation } = this.manager;
    this.destroy = E(() => {
      var _a42, _b22, _c32;
      const enabled = dragOperation.status.dragging;
      if (enabled) {
        const root = (_c32 = (_b22 = (_a42 = dragOperation.source) == null ? void 0 : _a42.element) == null ? void 0 : _b22.ownerDocument) != null ? _c32 : document;
        root.addEventListener("scroll", this.handleScroll, listenerOptions);
        return () => {
          root.removeEventListener(
            "scroll",
            this.handleScroll,
            listenerOptions
          );
        };
      }
    });
  }
};
_timeout = /* @__PURE__ */ new WeakMap();
var PreventSelection = class extends Plugin {
  constructor(manager, options2) {
    super(manager, options2);
    this.manager = manager;
    this.destroy = E(() => {
      var _a42;
      const { dragOperation } = this.manager;
      const { nonce } = (_a42 = this.options) != null ? _a42 : {};
      if (dragOperation.status.initialized) {
        const style = document.createElement("style");
        if (nonce) {
          style.setAttribute("nonce", nonce);
        }
        style.textContent = `* { user-select: none !important; -webkit-user-select: none !important; }`;
        document.head.appendChild(style);
        removeSelection();
        document.addEventListener("selectionchange", removeSelection, {
          capture: true
        });
        return () => {
          document.removeEventListener("selectionchange", removeSelection, {
            capture: true
          });
          style.remove();
        };
      }
    });
  }
};
function removeSelection() {
  var _a42;
  (_a42 = document.getSelection()) == null ? void 0 : _a42.removeAllRanges();
}
var defaults = Object.freeze({
  offset: 10,
  keyboardCodes: {
    start: ["Space", "Enter"],
    cancel: ["Escape"],
    end: ["Space", "Enter", "Tab"],
    up: ["ArrowUp"],
    down: ["ArrowDown"],
    left: ["ArrowLeft"],
    right: ["ArrowRight"]
  },
  shouldActivate(args) {
    var _a42;
    const { event, source } = args;
    const target = (_a42 = source.handle) != null ? _a42 : source.element;
    return event.target === target;
  }
});
var _cleanupFunctions2;
var _KeyboardSensor = class _KeyboardSensor2 extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    __privateAdd5(this, _cleanupFunctions2, []);
    this.listeners = new Listeners();
    this.handleSourceKeyDown = (event, source, options3) => {
      if (this.disabled || event.defaultPrevented) {
        return;
      }
      if (!isElement(event.target)) {
        return;
      }
      if (source.disabled) {
        return;
      }
      const {
        keyboardCodes = defaults.keyboardCodes,
        shouldActivate = defaults.shouldActivate
      } = options3 != null ? options3 : {};
      if (!keyboardCodes.start.includes(event.code)) {
        return;
      }
      if (!this.manager.dragOperation.status.idle) {
        return;
      }
      if (shouldActivate({ event, source, manager: this.manager })) {
        this.handleStart(event, source, options3);
      }
    };
  }
  bind(source, options2 = this.options) {
    const unbind = E(() => {
      var _a42;
      const target = (_a42 = source.handle) != null ? _a42 : source.element;
      const listener = (event) => {
        if (isKeyboardEvent(event)) {
          this.handleSourceKeyDown(event, source, options2);
        }
      };
      if (target) {
        target.addEventListener("keydown", listener);
        return () => {
          target.removeEventListener("keydown", listener);
        };
      }
    });
    return unbind;
  }
  handleStart(event, source, options2) {
    const { element } = source;
    if (!element) {
      throw new Error("Source draggable does not have an associated element");
    }
    event.preventDefault();
    event.stopImmediatePropagation();
    scrollIntoViewIfNeeded(element);
    const { center } = new DOMRectangle(element);
    const controller = this.manager.actions.start({
      event,
      coordinates: {
        x: center.x,
        y: center.y
      },
      source
    });
    if (controller.signal.aborted)
      return this.cleanup();
    this.sideEffects();
    const sourceDocument = getDocument(element);
    const listeners = [
      this.listeners.bind(sourceDocument, [
        {
          type: "keydown",
          listener: (event2) => this.handleKeyDown(event2, source, options2),
          options: { capture: true }
        }
      ])
    ];
    __privateGet5(this, _cleanupFunctions2).push(...listeners);
  }
  handleKeyDown(event, _source, options2) {
    const { keyboardCodes = defaults.keyboardCodes } = options2 != null ? options2 : {};
    if (isKeycode(event, [...keyboardCodes.end, ...keyboardCodes.cancel])) {
      event.preventDefault();
      const canceled = isKeycode(event, keyboardCodes.cancel);
      this.handleEnd(event, canceled);
      return;
    }
    if (isKeycode(event, keyboardCodes.up)) {
      this.handleMove("up", event);
    } else if (isKeycode(event, keyboardCodes.down)) {
      this.handleMove("down", event);
    }
    if (isKeycode(event, keyboardCodes.left)) {
      this.handleMove("left", event);
    } else if (isKeycode(event, keyboardCodes.right)) {
      this.handleMove("right", event);
    }
  }
  handleEnd(event, canceled) {
    this.manager.actions.stop({
      event,
      canceled
    });
    this.cleanup();
  }
  handleMove(direction, event) {
    var _a42, _b22;
    const { shape } = this.manager.dragOperation;
    const factor = event.shiftKey ? 5 : 1;
    let by = {
      x: 0,
      y: 0
    };
    let offset = (_b22 = (_a42 = this.options) == null ? void 0 : _a42.offset) != null ? _b22 : defaults.offset;
    if (typeof offset === "number") {
      offset = { x: offset, y: offset };
    }
    if (!shape) {
      return;
    }
    switch (direction) {
      case "up":
        by = { x: 0, y: -offset.y * factor };
        break;
      case "down":
        by = { x: 0, y: offset.y * factor };
        break;
      case "left":
        by = { x: -offset.x * factor, y: 0 };
        break;
      case "right":
        by = { x: offset.x * factor, y: 0 };
        break;
    }
    if (by.x || by.y) {
      event.preventDefault();
      this.manager.actions.move({
        event,
        by
      });
    }
  }
  sideEffects() {
    const autoScroller = this.manager.registry.plugins.get(AutoScroller);
    if ((autoScroller == null ? void 0 : autoScroller.disabled) === false) {
      autoScroller.disable();
      __privateGet5(this, _cleanupFunctions2).push(() => {
        autoScroller.enable();
      });
    }
  }
  cleanup() {
    __privateGet5(this, _cleanupFunctions2).forEach((cleanup) => cleanup());
    __privateSet5(this, _cleanupFunctions2, []);
  }
  destroy() {
    this.cleanup();
    this.listeners.clear();
  }
};
_cleanupFunctions2 = /* @__PURE__ */ new WeakMap();
_KeyboardSensor.configure = configurator(_KeyboardSensor);
_KeyboardSensor.defaults = defaults;
var KeyboardSensor = _KeyboardSensor;
function isKeycode(event, codes) {
  return codes.includes(event.code);
}
var defaults2 = Object.freeze({
  activationConstraints(event, source) {
    var _a42;
    const { pointerType, target } = event;
    if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a42 = source.handle) == null ? void 0 : _a42.contains(target)))) {
      return void 0;
    }
    if (pointerType === "touch") {
      return {
        delay: { value: 250, tolerance: 5 }
      };
    }
    if (isTextInput(target) && !event.defaultPrevented) {
      return {
        delay: { value: 200, tolerance: 0 }
      };
    }
    return {
      delay: { value: 200, tolerance: 10 },
      distance: { value: 5 }
    };
  }
});
var _cleanup;
var _clearTimeout;
var _PointerSensor = class _PointerSensor2 extends Sensor {
  constructor(manager, options2) {
    super(manager);
    this.manager = manager;
    this.options = options2;
    __privateAdd5(this, _cleanup, /* @__PURE__ */ new Set());
    __privateAdd5(this, _clearTimeout);
    this.listeners = new Listeners();
    this.latest = {
      event: void 0,
      coordinates: void 0
    };
    this.handleMove = () => {
      const { event, coordinates: to } = this.latest;
      if (!event || !to) {
        return;
      }
      this.manager.actions.move({ event, to });
    };
    this.handleCancel = this.handleCancel.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  activationConstraints(event, source) {
    var _a42;
    const { activationConstraints = defaults2.activationConstraints } = (_a42 = this.options) != null ? _a42 : {};
    const constraints = typeof activationConstraints === "function" ? activationConstraints(event, source) : activationConstraints;
    return constraints;
  }
  bind(source, options2 = this.options) {
    const unbind = E(() => {
      var _a42;
      const controller = new AbortController();
      const { signal: signal3 } = controller;
      const listener = (event) => {
        if (isPointerEvent(event)) {
          this.handlePointerDown(event, source, options2);
        }
      };
      let targets = [(_a42 = source.handle) != null ? _a42 : source.element];
      if (options2 == null ? void 0 : options2.activatorElements) {
        if (Array.isArray(options2.activatorElements)) {
          targets = options2.activatorElements;
        } else {
          targets = options2.activatorElements(source);
        }
      }
      for (const target of targets) {
        if (!target)
          continue;
        patchWindow(target.ownerDocument.defaultView);
        target.addEventListener("pointerdown", listener, { signal: signal3 });
      }
      return () => controller.abort();
    });
    return unbind;
  }
  handlePointerDown(event, source, options2 = {}) {
    if (this.disabled || !event.isPrimary || event.button !== 0 || !isElement(event.target) || source.disabled || isCapturedBySensor(event) || !this.manager.dragOperation.status.idle) {
      return;
    }
    const { target } = event;
    const isNativeDraggable = isHTMLElement(target) && target.draggable && target.getAttribute("draggable") === "true";
    const offset = getFrameTransform(source.element);
    this.initialCoordinates = {
      x: event.clientX * offset.scaleX + offset.x,
      y: event.clientY * offset.scaleY + offset.y
    };
    const constraints = this.activationConstraints(event, source);
    event.sensor = this;
    if (!(constraints == null ? void 0 : constraints.delay) && !(constraints == null ? void 0 : constraints.distance)) {
      this.handleStart(source, event);
    } else {
      const { delay } = constraints;
      if (delay) {
        const timeout3 = setTimeout(
          () => this.handleStart(source, event),
          delay.value
        );
        __privateSet5(this, _clearTimeout, () => {
          clearTimeout(timeout3);
          __privateSet5(this, _clearTimeout, void 0);
        });
      }
    }
    const ownerDocument = getDocument(event.target);
    const unbindListeners = this.listeners.bind(ownerDocument, [
      {
        type: "pointermove",
        listener: (event2) => this.handlePointerMove(event2, source)
      },
      {
        type: "pointerup",
        listener: this.handlePointerUp,
        options: {
          capture: true
        }
      },
      {
        // Cancel activation if there is a competing Drag and Drop interaction
        type: "dragstart",
        listener: isNativeDraggable ? this.handleCancel : preventDefault,
        options: {
          capture: true
        }
      }
    ]);
    const cleanup = () => {
      var _a42;
      unbindListeners();
      (_a42 = __privateGet5(this, _clearTimeout)) == null ? void 0 : _a42.call(this);
      this.initialCoordinates = void 0;
    };
    __privateGet5(this, _cleanup).add(cleanup);
  }
  handlePointerMove(event, source) {
    const coordinates = {
      x: event.clientX,
      y: event.clientY
    };
    const offset = getFrameTransform(source.element);
    coordinates.x = coordinates.x * offset.scaleX + offset.x;
    coordinates.y = coordinates.y * offset.scaleY + offset.y;
    if (this.manager.dragOperation.status.dragging) {
      event.preventDefault();
      event.stopPropagation();
      this.latest.event = event;
      this.latest.coordinates = coordinates;
      scheduler.schedule(this.handleMove);
      return;
    }
    if (!this.initialCoordinates) {
      return;
    }
    const delta = {
      x: coordinates.x - this.initialCoordinates.x,
      y: coordinates.y - this.initialCoordinates.y
    };
    const constraints = this.activationConstraints(event, source);
    const { distance, delay } = constraints != null ? constraints : {};
    if (distance) {
      if (distance.tolerance != null && exceedsDistance(delta, distance.tolerance)) {
        return this.handleCancel(event);
      }
      if (exceedsDistance(delta, distance.value)) {
        return this.handleStart(source, event);
      }
    }
    if (delay) {
      if (exceedsDistance(delta, delay.tolerance)) {
        return this.handleCancel(event);
      }
    }
  }
  handlePointerUp(event) {
    const { status } = this.manager.dragOperation;
    if (!status.idle) {
      event.preventDefault();
      event.stopPropagation();
      const canceled = !status.initialized;
      this.manager.actions.stop({ event, canceled });
    }
    this.cleanup();
  }
  handleKeyDown(event) {
    if (event.key === "Escape") {
      event.preventDefault();
      this.handleCancel(event);
    }
  }
  handleStart(source, event) {
    var _a42;
    const { manager, initialCoordinates } = this;
    (_a42 = __privateGet5(this, _clearTimeout)) == null ? void 0 : _a42.call(this);
    if (!initialCoordinates || !manager.dragOperation.status.idle) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    const controller = manager.actions.start({
      coordinates: initialCoordinates,
      event,
      source
    });
    if (controller.signal.aborted)
      return this.cleanup();
    event.preventDefault();
    const ownerDocument = getDocument(event.target);
    const pointerCaptureTarget = ownerDocument.body;
    pointerCaptureTarget.setPointerCapture(event.pointerId);
    const unbind = this.listeners.bind(ownerDocument, [
      {
        // Prevent scrolling on touch devices
        type: "touchmove",
        listener: preventDefault,
        options: {
          passive: false
        }
      },
      {
        // Prevent click events
        type: "click",
        listener: preventDefault
      },
      {
        type: "contextmenu",
        listener: preventDefault
      },
      {
        type: "keydown",
        listener: this.handleKeyDown
      },
      {
        type: "lostpointercapture",
        listener: (event2) => {
          if (event2.target !== pointerCaptureTarget)
            return;
          this.handlePointerUp(event2);
        }
      }
    ]);
    __privateGet5(this, _cleanup).add(unbind);
  }
  handleCancel(event) {
    const { dragOperation } = this.manager;
    if (dragOperation.status.initialized) {
      this.manager.actions.stop({ event, canceled: true });
    }
    this.cleanup();
  }
  cleanup() {
    this.latest = {
      event: void 0,
      coordinates: void 0
    };
    __privateGet5(this, _cleanup).forEach((cleanup) => cleanup());
    __privateGet5(this, _cleanup).clear();
  }
  destroy() {
    this.cleanup();
    this.listeners.clear();
  }
};
_cleanup = /* @__PURE__ */ new WeakMap();
_clearTimeout = /* @__PURE__ */ new WeakMap();
_PointerSensor.configure = configurator(_PointerSensor);
_PointerSensor.defaults = defaults2;
var PointerSensor = _PointerSensor;
function isCapturedBySensor(event) {
  return "sensor" in event;
}
function preventDefault(event) {
  event.preventDefault();
}
function noop() {
}
var windows = /* @__PURE__ */ new WeakSet();
function patchWindow(window2) {
  if (!window2 || windows.has(window2)) {
    return;
  }
  window2.addEventListener("touchmove", noop, {
    capture: false,
    passive: false
  });
  windows.add(window2);
}
var defaultPreset = {
  modifiers: [],
  plugins: [Accessibility, AutoScroller, Cursor, Feedback, PreventSelection],
  sensors: [PointerSensor, KeyboardSensor]
};
var DragDropManager2 = class extends DragDropManager {
  constructor(input = {}) {
    const {
      plugins = defaultPreset.plugins,
      sensors = defaultPreset.sensors,
      modifiers = []
    } = input;
    super(__spreadProps4(__spreadValues5({}, input), {
      plugins: [ScrollListener, Scroller, ...plugins],
      sensors,
      modifiers
    }));
  }
};
var _feedback_dec;
var _element_dec;
var _handle_dec;
var _c3;
var _init42;
var _handle;
var _element;
var _feedback;
var Draggable2 = class extends (_c3 = Draggable, _handle_dec = [reactive], _element_dec = [reactive], _feedback_dec = [reactive], _c3) {
  constructor(_a42, manager) {
    var _b22 = _a42, {
      element,
      effects: effects2 = () => [],
      handle,
      feedback = "default"
    } = _b22, input = __objRest3(_b22, [
      "element",
      "effects",
      "handle",
      "feedback"
    ]);
    super(
      __spreadValues5({
        effects: () => [
          ...effects2(),
          () => {
            var _a5, _b3;
            const { manager: manager2 } = this;
            if (!manager2)
              return;
            const sensors = (_b3 = (_a5 = this.sensors) == null ? void 0 : _a5.map(descriptor)) != null ? _b3 : [
              ...manager2.sensors
            ];
            const unbindFunctions = sensors.map((entry) => {
              const sensorInstance = entry instanceof Sensor ? entry : manager2.registry.register(entry.plugin);
              const options2 = entry instanceof Sensor ? void 0 : entry.options;
              const unbind = sensorInstance.bind(this, options2);
              return unbind;
            });
            return function cleanup() {
              unbindFunctions.forEach((unbind) => unbind());
            };
          }
        ]
      }, input),
      manager
    );
    __privateAdd5(this, _handle, __runInitializers4(_init42, 8, this)), __runInitializers4(_init42, 11, this);
    __privateAdd5(this, _element, __runInitializers4(_init42, 12, this)), __runInitializers4(_init42, 15, this);
    __privateAdd5(this, _feedback, __runInitializers4(_init42, 16, this)), __runInitializers4(_init42, 19, this);
    this.element = element;
    this.handle = handle;
    this.feedback = feedback;
  }
};
_init42 = __decoratorStart4(_c3);
_handle = /* @__PURE__ */ new WeakMap();
_element = /* @__PURE__ */ new WeakMap();
_feedback = /* @__PURE__ */ new WeakMap();
__decorateElement4(_init42, 4, "handle", _handle_dec, Draggable2, _handle);
__decorateElement4(_init42, 4, "element", _element_dec, Draggable2, _element);
__decorateElement4(_init42, 4, "feedback", _feedback_dec, Draggable2, _feedback);
__decoratorMetadata4(_init42, Draggable2);
var _proxy_dec;
var _element_dec2;
var _c23;
var _init52;
var _element2;
var _d;
var element_get;
var element_set;
var _Droppable_instances;
var _proxy;
var Droppable2 = class extends (_c23 = Droppable, _element_dec2 = [reactive], _proxy_dec = [reactive], _c23) {
  constructor(_a42, manager) {
    var _b22 = _a42, { element, effects: effects2 = () => [] } = _b22, input = __objRest3(_b22, ["element", "effects"]);
    const { collisionDetector = defaultCollisionDetection } = input;
    const updateShape = (boundingClientRect) => {
      const { manager: manager2, element: element2 } = this;
      if (!element2 || boundingClientRect === null) {
        this.shape = void 0;
        return void 0;
      }
      if (!manager2)
        return;
      const updatedShape = new DOMRectangle(element2);
      const shape = n(() => this.shape);
      if (updatedShape && (shape == null ? void 0 : shape.equals(updatedShape))) {
        return shape;
      }
      this.shape = updatedShape;
      return updatedShape;
    };
    const observePosition = d(false);
    super(
      __spreadProps4(__spreadValues5({}, input), {
        collisionDetector,
        effects: () => [
          ...effects2(),
          () => {
            const { element: element2, manager: manager2 } = this;
            if (!manager2)
              return;
            const { dragOperation } = manager2;
            const { source } = dragOperation;
            observePosition.value = Boolean(
              source && dragOperation.status.initialized && element2 && !this.disabled && this.accepts(source)
            );
          },
          () => {
            const { element: element2 } = this;
            if (observePosition.value && element2) {
              const positionObserver = new FrameObserver(
                element2,
                updateShape
              );
              return () => {
                positionObserver.disconnect();
                this.shape = void 0;
              };
            }
          },
          () => {
            var _a5;
            if ((_a5 = this.manager) == null ? void 0 : _a5.dragOperation.status.initialized) {
              return () => {
                this.shape = void 0;
              };
            }
          }
        ]
      }),
      manager
    );
    __privateAdd5(this, _Droppable_instances);
    __privateAdd5(this, _element2, __runInitializers4(_init52, 8, this)), __runInitializers4(_init52, 11, this);
    __privateAdd5(this, _proxy, __runInitializers4(_init52, 12, this)), __runInitializers4(_init52, 15, this);
    this.element = element;
    this.refreshShape = () => updateShape();
  }
  set element(element) {
    __privateSet5(this, _Droppable_instances, element, element_set);
  }
  get element() {
    var _a42;
    return (_a42 = this.proxy) != null ? _a42 : __privateGet5(this, _Droppable_instances, element_get);
  }
};
_init52 = __decoratorStart4(_c23);
_element2 = /* @__PURE__ */ new WeakMap();
_Droppable_instances = /* @__PURE__ */ new WeakSet();
_proxy = /* @__PURE__ */ new WeakMap();
_d = __decorateElement4(_init52, 20, "#element", _element_dec2, _Droppable_instances, _element2), element_get = _d.get, element_set = _d.set;
__decorateElement4(_init52, 4, "proxy", _proxy_dec, Droppable2, _proxy);
__decoratorMetadata4(_init52, Droppable2);

// node_modules/@measured/puck/node_modules/@dnd-kit/react/hooks.js
var import_react5 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@measured/puck/node_modules/@dnd-kit/react/utilities.js
function isRef(value) {
  return value != null && typeof value === "object" && "current" in value;
}
function currentValue(value) {
  var _a5;
  if (value == null) {
    return void 0;
  }
  if (isRef(value)) {
    return (_a5 = value.current) != null ? _a5 : void 0;
  }
  return value;
}

// node_modules/@measured/puck/node_modules/@dnd-kit/react/hooks.js
var canUseDOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useIsomorphicLayoutEffect = canUseDOM2 ? import_react5.useLayoutEffect : import_react5.useEffect;
function useForceUpdate() {
  const setState = (0, import_react5.useState)(0)[1];
  return (0, import_react5.useCallback)(() => {
    setState((value) => value + 1);
  }, [setState]);
}
function useDeepSignal(target, synchronous) {
  const tracked = (0, import_react5.useRef)(/* @__PURE__ */ new Map());
  const forceUpdate = useForceUpdate();
  useIsomorphicLayoutEffect(() => {
    if (!target) {
      tracked.current.clear();
      return;
    }
    return E(() => {
      var _a5;
      let stale = false;
      let sync = false;
      for (const entry of tracked.current) {
        const [key] = entry;
        const value = n(() => entry[1]);
        const latestValue = target[key];
        if (value !== latestValue) {
          stale = true;
          tracked.current.set(key, latestValue);
          sync = (_a5 = synchronous == null ? void 0 : synchronous(key, value, latestValue)) != null ? _a5 : false;
        }
      }
      if (stale) {
        sync ? (0, import_react_dom.flushSync)(forceUpdate) : forceUpdate();
      }
    });
  }, [target]);
  return (0, import_react5.useMemo)(
    () => target ? new Proxy(target, {
      get(target2, key) {
        const value = target2[key];
        tracked.current.set(key, value);
        return value;
      }
    }) : target,
    [target]
  );
}
function useImmediateEffect(callback, _2) {
  callback();
}
function useLatest(value) {
  const valueRef = (0, import_react5.useRef)(value);
  useIsomorphicLayoutEffect(() => {
    valueRef.current = value;
  }, [value]);
  return valueRef;
}
function useOnValueChange(value, onChange, effect3 = import_react5.useEffect, compare = Object.is) {
  const tracked = (0, import_react5.useRef)(value);
  effect3(() => {
    const oldValue = tracked.current;
    if (!compare(value, oldValue)) {
      tracked.current = value;
      onChange(value, oldValue);
    }
  }, [onChange, value]);
}
function useOnElementChange(value, onChange) {
  const previous = (0, import_react5.useRef)(currentValue(value));
  useIsomorphicLayoutEffect(() => {
    const current = currentValue(value);
    if (current !== previous.current) {
      previous.current = current;
      onChange(current);
    }
  });
}

// node_modules/@measured/puck/node_modules/@dnd-kit/react/index.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var __defProp6 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp6.call(b2, prop))
      __defNormalProp6(a2, prop, b2[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b2)) {
      if (__propIsEnum6.call(b2, prop))
        __defNormalProp6(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps5 = (a2, b2) => __defProps5(a2, __getOwnPropDescs5(b2));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var defaultManager = new DragDropManager2();
var DragDropContext = (0, import_react6.createContext)(
  defaultManager
);
var Renderer = (0, import_react6.memo)(
  (0, import_react6.forwardRef)(({ children }, ref) => {
    const [transitionCount, setTransitionCount] = (0, import_react6.useState)(0);
    const rendering = (0, import_react6.useRef)(null);
    const resolver = (0, import_react6.useRef)(null);
    const renderer = (0, import_react6.useMemo)(
      () => ({
        renderer: {
          get rendering() {
            var _a23;
            return (_a23 = rendering.current) != null ? _a23 : Promise.resolve();
          }
        },
        trackRendering(callback) {
          if (!rendering.current) {
            rendering.current = new Promise((resolve) => {
              resolver.current = resolve;
            });
          }
          (0, import_react6.startTransition)(() => {
            callback();
            setTransitionCount((count) => count + 1);
          });
        }
      }),
      []
    );
    useIsomorphicLayoutEffect(() => {
      var _a23;
      (_a23 = resolver.current) == null ? void 0 : _a23.call(resolver);
      rendering.current = null;
    }, [children, transitionCount]);
    (0, import_react6.useImperativeHandle)(ref, () => renderer);
    return null;
  })
);
var options = [void 0, deepEqual];
function DragDropProvider(_a23) {
  var _b3 = _a23, {
    children,
    onCollision,
    onBeforeDragStart,
    onDragStart,
    onDragMove,
    onDragOver,
    onDragEnd
  } = _b3, input = __objRest4(_b3, [
    "children",
    "onCollision",
    "onBeforeDragStart",
    "onDragStart",
    "onDragMove",
    "onDragOver",
    "onDragEnd"
  ]);
  var _a33;
  const rendererRef = (0, import_react6.useRef)(null);
  const [manager, setManager] = (0, import_react6.useState)((_a33 = input.manager) != null ? _a33 : null);
  const { plugins, modifiers, sensors } = input;
  const handleBeforeDragStart = useLatest(onBeforeDragStart);
  const handleDragStart = useLatest(onDragStart);
  const handleDragOver = useLatest(onDragOver);
  const handleDragMove = useLatest(onDragMove);
  const handleDragEnd = useLatest(onDragEnd);
  const handleCollision = useLatest(onCollision);
  (0, import_react6.useEffect)(() => {
    var _a42;
    if (!rendererRef.current)
      throw new Error("Renderer not found");
    const { renderer, trackRendering } = rendererRef.current;
    const manager2 = (_a42 = input.manager) != null ? _a42 : new DragDropManager2(input);
    manager2.renderer = renderer;
    manager2.monitor.addEventListener("beforedragstart", (event) => {
      const callback = handleBeforeDragStart.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener(
      "dragstart",
      (event) => {
        var _a5;
        return (_a5 = handleDragStart.current) == null ? void 0 : _a5.call(handleDragStart, event, manager2);
      }
    );
    manager2.monitor.addEventListener("dragover", (event) => {
      const callback = handleDragOver.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener("dragmove", (event) => {
      const callback = handleDragMove.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener("dragend", (event) => {
      const callback = handleDragEnd.current;
      if (callback) {
        trackRendering(() => callback(event, manager2));
      }
    });
    manager2.monitor.addEventListener(
      "collision",
      (event) => {
        var _a5;
        return (_a5 = handleCollision.current) == null ? void 0 : _a5.call(handleCollision, event, manager2);
      }
    );
    (0, import_react6.startTransition)(() => setManager(manager2));
    return manager2.destroy;
  }, [input.manager]);
  useOnValueChange(
    plugins,
    () => manager && (manager.plugins = plugins != null ? plugins : defaultPreset.plugins),
    ...options
  );
  useOnValueChange(
    sensors,
    () => manager && (manager.sensors = sensors != null ? sensors : defaultPreset.sensors),
    ...options
  );
  useOnValueChange(
    modifiers,
    () => manager && (manager.modifiers = modifiers != null ? modifiers : defaultPreset.modifiers),
    ...options
  );
  return (0, import_jsx_runtime2.jsxs)(DragDropContext.Provider, { value: manager, children: [
    (0, import_jsx_runtime2.jsx)(Renderer, { ref: rendererRef, children }),
    children
  ] });
}
function useDragDropManager() {
  return (0, import_react6.useContext)(DragDropContext);
}
function useInstance(initializer) {
  var _a23;
  const manager = (_a23 = useDragDropManager()) != null ? _a23 : void 0;
  const [instance] = (0, import_react6.useState)(() => initializer(manager));
  if (instance.manager !== manager) {
    instance.manager = manager;
  }
  useIsomorphicLayoutEffect(instance.register, [manager, instance]);
  return instance;
}
function useDraggable(input) {
  const { disabled, data, element, handle, id, modifiers, sensors } = input;
  const draggable = useInstance(
    (manager) => new Draggable2(
      __spreadProps5(__spreadValues6({}, input), {
        register: false,
        handle: currentValue(handle),
        element: currentValue(element)
      }),
      manager
    )
  );
  const trackedDraggable = useDeepSignal(draggable, shouldUpdateSynchronously);
  useOnValueChange(id, () => draggable.id = id);
  useOnElementChange(handle, (handle2) => draggable.handle = handle2);
  useOnElementChange(element, (element2) => draggable.element = element2);
  useOnValueChange(data, () => data && (draggable.data = data));
  useOnValueChange(disabled, () => draggable.disabled = disabled === true);
  useOnValueChange(sensors, () => draggable.sensors = sensors);
  useOnValueChange(
    modifiers,
    () => draggable.modifiers = modifiers,
    void 0,
    deepEqual
  );
  useOnValueChange(
    input.feedback,
    () => {
      var _a23;
      return draggable.feedback = (_a23 = input.feedback) != null ? _a23 : "default";
    }
  );
  useOnValueChange(
    input.alignment,
    () => draggable.alignment = input.alignment
  );
  return {
    draggable: trackedDraggable,
    get isDragging() {
      return trackedDraggable.isDragging;
    },
    get isDropping() {
      return trackedDraggable.isDropping;
    },
    get isDragSource() {
      return trackedDraggable.isDragSource;
    },
    handleRef: (0, import_react6.useCallback)(
      (element2) => {
        draggable.handle = element2 != null ? element2 : void 0;
      },
      [draggable]
    ),
    ref: (0, import_react6.useCallback)(
      (element2) => {
        var _a23, _b3;
        if (!element2 && ((_a23 = draggable.element) == null ? void 0 : _a23.isConnected) && !((_b3 = draggable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        draggable.element = element2 != null ? element2 : void 0;
      },
      [draggable]
    )
  };
}
function shouldUpdateSynchronously(key, oldValue, newValue) {
  if (key === "isDragSource" && !newValue && oldValue)
    return true;
  return false;
}
var __create6 = Object.create;
var __defProp22 = Object.defineProperty;
var __getOwnPropDesc6 = Object.getOwnPropertyDescriptor;
var __knownSymbol5 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError6 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __decoratorStart5 = (base) => {
  var _a23;
  return [, , , __create6((_a23 = base == null ? void 0 : base[__knownSymbol5("metadata")]) != null ? _a23 : null)];
};
var __decoratorStrings5 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn5 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError6("Function expected") : fn;
var __decoratorContext5 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings5[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError6("Already initialized") : fns.push(__expectFn5(fn || null)) });
var __decoratorMetadata5 = (array, target) => __defNormalProp22(target, __knownSymbol5("metadata"), array[3]);
var __runInitializers5 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++)
    fns[i2].call(self2);
  return value;
};
var __decorateElement5 = (array, flags, name, decorators, target, extra) => {
  var it, done, ctx, access, k = flags & 7, s2 = false, p2 = false;
  var j = 2, key = __decoratorStrings5[k + 5];
  var extraInitializers = array[j] || (array[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc6(target, name));
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext5(k, name, done = {}, array[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
    }
    it = (0, decorators[i2])(desc[key], ctx), done._ = 1;
    __expectFn5(it) && (desc[key] = it);
  }
  return desc && __defProp22(target, name, desc), target;
};
var __accessCheck6 = (obj, member, msg) => member.has(obj) || __typeError6("Cannot " + msg);
var __privateGet6 = (obj, member, getter) => (__accessCheck6(obj, member, "read from private field"), member.get(obj));
var __privateAdd6 = (obj, member, value) => member.has(obj) ? __typeError6("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet6 = (obj, member, value, setter) => (__accessCheck6(obj, member, "write to private field"), member.set(obj, value), value);
var Point2 = class _Point2 {
  /**
   * @param {number} Coordinate of the point on the horizontal axis
   * @param {number} Coordinate of the point on the vertical axis
   */
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  /**
   * Returns the delta between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static delta(a2, b2) {
    return new _Point2(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns the distance (hypotenuse) between this point and another point.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static distance(a2, b2) {
    return Math.hypot(a2.x - b2.x, a2.y - b2.y);
  }
  /**
   * Returns true if both points are equal.
   *
   * @param {Point} a - A point
   * @param {Point} b - Another point
   */
  static equals(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y;
  }
  static from({ x, y: y2 }) {
    return new _Point2(x, y2);
  }
};
var _direction_dec2;
var _delta_dec2;
var _a4;
var _timestamp2;
var _init8;
var Position2 = class extends (_a4 = ValueHistory, _delta_dec2 = [derived], _direction_dec2 = [derived], _a4) {
  constructor(initialValue) {
    const point = Point2.from(initialValue);
    super(point, (a2, b2) => Point2.equals(a2, b2));
    __runInitializers5(_init8, 5, this);
    __privateAdd6(this, _timestamp2, 0);
    this.velocity = { x: 0, y: 0 };
  }
  get delta() {
    return Point2.delta(this.current, this.initial);
  }
  get direction() {
    const { current, previous } = this;
    if (!previous)
      return null;
    const delta = {
      x: current.x - previous.x,
      y: current.y - previous.y
    };
    if (!delta.x && !delta.y) {
      return null;
    }
    if (Math.abs(delta.x) > Math.abs(delta.y)) {
      return delta.x > 0 ? "right" : "left";
    }
    return delta.y > 0 ? "down" : "up";
  }
  get current() {
    return super.current;
  }
  set current(coordinates) {
    const { current } = this;
    const point = Point2.from(coordinates);
    const delta = {
      x: point.x - current.x,
      y: point.y - current.y
    };
    const timestamp = Date.now();
    const timeDelta = timestamp - __privateGet6(this, _timestamp2);
    const velocity = (delta2) => Math.round(delta2 / timeDelta * 100);
    r(() => {
      __privateSet6(this, _timestamp2, timestamp);
      this.velocity = {
        x: velocity(delta.x),
        y: velocity(delta.y)
      };
      super.current = point;
    });
  }
  reset(coordinates = this.defaultValue) {
    super.reset(Point2.from(coordinates));
    this.velocity = { x: 0, y: 0 };
  }
};
_init8 = __decoratorStart5(_a4);
_timestamp2 = /* @__PURE__ */ new WeakMap();
__decorateElement5(_init8, 2, "delta", _delta_dec2, Position2);
__decorateElement5(_init8, 2, "direction", _direction_dec2, Position2);
__decoratorMetadata5(_init8, Position2);
var Axis2 = ((Axis22) => {
  Axis22["Horizontal"] = "x";
  Axis22["Vertical"] = "y";
  return Axis22;
})(Axis2 || {});
Object.values(Axis2);
var pointerIntersection2 = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point2.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var shapeIntersection2 = ({
  dragOperation,
  droppable
}) => {
  const { shape } = dragOperation;
  if (!droppable.shape || !(shape == null ? void 0 : shape.current)) {
    return null;
  }
  const intersectionArea = shape.current.intersectionArea(droppable.shape);
  if (intersectionArea) {
    const { position } = dragOperation;
    const distance = Point2.distance(droppable.shape.center, position.current);
    const intersectionRatio = intersectionArea / (shape.current.area + droppable.shape.area - intersectionArea);
    const value = intersectionRatio / distance;
    return {
      id: droppable.id,
      value,
      type: CollisionType.ShapeIntersection,
      priority: CollisionPriority.Normal
    };
  }
  return null;
};
var defaultCollisionDetection2 = (args) => {
  var _a23;
  return (_a23 = pointerIntersection2(args)) != null ? _a23 : shapeIntersection2(args);
};
function useDroppable(input) {
  const { collisionDetector, data, disabled, element, id, accept, type } = input;
  const droppable = useInstance(
    (manager) => new Droppable2(
      __spreadProps5(__spreadValues6({}, input), {
        register: false,
        element: currentValue(element)
      }),
      manager
    )
  );
  const trackedDroppalbe = useDeepSignal(droppable);
  useOnValueChange(id, () => droppable.id = id);
  useOnElementChange(element, (element2) => droppable.element = element2);
  useOnValueChange(
    accept,
    () => droppable.accept = accept,
    void 0,
    deepEqual
  );
  useOnValueChange(
    collisionDetector,
    () => droppable.collisionDetector = collisionDetector != null ? collisionDetector : defaultCollisionDetection2
  );
  useOnValueChange(data, () => data && (droppable.data = data));
  useOnValueChange(disabled, () => droppable.disabled = disabled === true);
  useOnValueChange(type, () => droppable.type = type);
  return {
    droppable: trackedDroppalbe,
    get isDropTarget() {
      return trackedDroppalbe.isDropTarget;
    },
    ref: (0, import_react6.useCallback)(
      (element2) => {
        var _a23, _b3;
        if (!element2 && ((_a23 = droppable.element) == null ? void 0 : _a23.isConnected) && !((_b3 = droppable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        droppable.element = element2 != null ? element2 : void 0;
      },
      [droppable]
    )
  };
}

// node_modules/@measured/puck/dist/chunk-V7Y7BFEC.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/@measured/puck/node_modules/@dnd-kit/react/sortable.js
var import_react7 = __toESM(require_react());

// node_modules/@dnd-kit/dom/sortable.js
var __create7 = Object.create;
var __defProp7 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDesc7 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __knownSymbol6 = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError7 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp7.call(b2, prop))
      __defNormalProp7(a2, prop, b2[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b2)) {
      if (__propIsEnum7.call(b2, prop))
        __defNormalProp7(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps6 = (a2, b2) => __defProps6(a2, __getOwnPropDescs6(b2));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __decoratorStart6 = (base) => {
  var _a5;
  return [, , , __create7((_a5 = void 0) != null ? _a5 : null)];
};
var __decoratorStrings6 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn6 = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError7("Function expected") : fn;
var __decoratorContext6 = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings6[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError7("Already initialized") : fns.push(__expectFn6(fn || null)) });
var __decoratorMetadata6 = (array, target) => __defNormalProp7(target, __knownSymbol6("metadata"), array[3]);
var __runInitializers6 = (array, flags, self2, value) => {
  for (var i2 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i2 < n3; i2++)
    flags & 1 ? fns[i2].call(self2) : value = fns[i2].call(self2, value);
  return value;
};
var __decorateElement6 = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k = flags & 7, s2 = false, p2 = false;
  var j = array.length + 1, key = __decoratorStrings6[k + 5];
  var initializers = array[j - 1] = [], extraInitializers = array[j] || (array[j] = []);
  var desc = (target = target.prototype, __getOwnPropDesc7({ get [name]() {
    return __privateGet7(this, extra);
  }, set [name](x) {
    return __privateSet7(this, extra, x);
  } }, name));
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    ctx = __decoratorContext6(k, name, done = {}, array[3], extraInitializers);
    {
      ctx.static = s2, ctx.private = p2, access = ctx.access = { has: (x) => name in x };
      access.get = (x) => x[name];
      access.set = (x, y2) => x[name] = y2;
    }
    it = (0, decorators[i2])({ get: desc.get, set: desc.set }, ctx), done._ = 1;
    if (it === void 0)
      __expectFn6(it) && (desc[key] = it);
    else if (typeof it !== "object" || it === null)
      __typeError7("Object expected");
    else
      __expectFn6(fn = it.get) && (desc.get = fn), __expectFn6(fn = it.set) && (desc.set = fn), __expectFn6(fn = it.init) && initializers.unshift(fn);
  }
  return desc && __defProp7(target, name, desc), target;
};
var __accessCheck7 = (obj, member, msg) => member.has(obj) || __typeError7("Cannot " + msg);
var __privateGet7 = (obj, member, getter) => (__accessCheck7(obj, member, "read from private field"), member.get(obj));
var __privateAdd7 = (obj, member, value) => member.has(obj) ? __typeError7("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet7 = (obj, member, value, setter) => (__accessCheck7(obj, member, "write to private field"), member.set(obj, value), value);
function isSortable(element) {
  return element instanceof SortableDroppable || element instanceof SortableDraggable;
}
var TOLERANCE = 10;
var SortableKeyboardPlugin = class extends Plugin {
  constructor(manager) {
    super(manager);
    const cleanupEffect = E(() => {
      const { dragOperation } = manager;
      if (!isKeyboardEvent(dragOperation.activatorEvent)) {
        return;
      }
      if (!isSortable(dragOperation.source)) {
        return;
      }
      if (dragOperation.status.initialized) {
        const scroller = manager.registry.plugins.get(Scroller);
        if (scroller) {
          scroller.disable();
          return () => scroller.enable();
        }
      }
    });
    const unsubscribe = manager.monitor.addEventListener(
      "dragmove",
      (event, manager2) => {
        queueMicrotask(() => {
          if (this.disabled || event.defaultPrevented || !event.nativeEvent) {
            return;
          }
          const { dragOperation } = manager2;
          if (!isKeyboardEvent(event.nativeEvent)) {
            return;
          }
          if (!isSortable(dragOperation.source)) {
            return;
          }
          if (!dragOperation.shape) {
            return;
          }
          const { actions, collisionObserver, registry } = manager2;
          const { by } = event;
          if (!by) {
            return;
          }
          const direction = getDirection2(by);
          const { source, target } = dragOperation;
          const { center } = dragOperation.shape.current;
          const potentialTargets = [];
          const cleanup = [];
          r(() => {
            for (const droppable of registry.droppables) {
              const { id: id2 } = droppable;
              if (!droppable.accepts(source) || id2 === (target == null ? void 0 : target.id) && isSortable(droppable) || !droppable.element) {
                continue;
              }
              let previousShape = droppable.shape;
              const shape = new DOMRectangle(droppable.element, {
                getBoundingClientRect: (element) => getVisibleBoundingRectangle(element, void 0, 0.2)
              });
              if (!shape.height || !shape.width)
                continue;
              if (direction == "down" && center.y + TOLERANCE < shape.center.y || direction == "up" && center.y - TOLERANCE > shape.center.y || direction == "left" && center.x - TOLERANCE > shape.center.x || direction == "right" && center.x + TOLERANCE < shape.center.x) {
                potentialTargets.push(droppable);
                droppable.shape = shape;
                cleanup.push(() => droppable.shape = previousShape);
              }
            }
          });
          event.preventDefault();
          collisionObserver.disable();
          const collisions = collisionObserver.computeCollisions(
            potentialTargets,
            closestCorners
          );
          r(() => cleanup.forEach((clean) => clean()));
          const [firstCollision] = collisions;
          if (!firstCollision) {
            return;
          }
          const { id } = firstCollision;
          const { index, group } = source.sortable;
          actions.setDropTarget(id).then(() => {
            const { source: source2, target: target2, shape } = dragOperation;
            if (!source2 || !isSortable(source2) || !shape) {
              return;
            }
            const {
              index: newIndex,
              group: newGroup,
              target: targetElement
            } = source2.sortable;
            const updated = index !== newIndex || group !== newGroup;
            const element = updated ? targetElement : target2 == null ? void 0 : target2.element;
            if (!element)
              return;
            scrollIntoViewIfNeeded(element);
            const updatedShape = new DOMRectangle(element);
            if (!updatedShape) {
              return;
            }
            const delta = Rectangle.delta(
              updatedShape,
              Rectangle.from(shape.current.boundingRectangle),
              source2.alignment
            );
            actions.move({
              by: delta
            });
            if (updated) {
              actions.setDropTarget(source2.id).then(() => collisionObserver.enable());
            } else {
              collisionObserver.enable();
            }
          });
        });
      }
    );
    this.destroy = () => {
      unsubscribe();
      cleanupEffect();
    };
  }
};
function getDirection2(delta) {
  const { x, y: y2 } = delta;
  if (x > 0) {
    return "right";
  } else if (x < 0) {
    return "left";
  } else if (y2 > 0) {
    return "down";
  } else if (y2 < 0) {
    return "up";
  }
}
var __defProp23 = Object.defineProperty;
var __defProps22 = Object.defineProperties;
var __getOwnPropDescs22 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols22 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum22 = Object.prototype.propertyIsEnumerable;
var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues22 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp22.call(b2, prop))
      __defNormalProp23(a2, prop, b2[prop]);
  if (__getOwnPropSymbols22)
    for (var prop of __getOwnPropSymbols22(b2)) {
      if (__propIsEnum22.call(b2, prop))
        __defNormalProp23(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps22 = (a2, b2) => __defProps22(a2, __getOwnPropDescs22(b2));
function arrayMove(array, from, to) {
  if (from === to) {
    return array;
  }
  const newArray = array.slice();
  newArray.splice(to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function mutate(items, event, mutation) {
  var _a5, _b3;
  const { source, target, canceled } = event.operation;
  if (!source || !target || canceled) {
    if ("preventDefault" in event)
      event.preventDefault();
    return items;
  }
  const findIndex = (item, id) => item === id || typeof item === "object" && "id" in item && item.id === id;
  if (Array.isArray(items)) {
    const sourceIndex2 = items.findIndex((item) => findIndex(item, source.id));
    const targetIndex2 = items.findIndex((item) => findIndex(item, target.id));
    if (sourceIndex2 === -1 || targetIndex2 === -1) {
      return items;
    }
    if (!canceled && "index" in source && typeof source.index === "number") {
      const projectedSourceIndex = source.index;
      if (projectedSourceIndex !== sourceIndex2) {
        return mutation(items, sourceIndex2, projectedSourceIndex);
      }
    }
    return mutation(items, sourceIndex2, targetIndex2);
  }
  const entries = Object.entries(items);
  let sourceIndex = -1;
  let sourceParent;
  let targetIndex = -1;
  let targetParent;
  for (const [id, children] of entries) {
    if (sourceIndex === -1) {
      sourceIndex = children.findIndex((item) => findIndex(item, source.id));
      if (sourceIndex !== -1) {
        sourceParent = id;
      }
    }
    if (targetIndex === -1) {
      targetIndex = children.findIndex((item) => findIndex(item, target.id));
      if (targetIndex !== -1) {
        targetParent = id;
      }
    }
    if (sourceIndex !== -1 && targetIndex !== -1) {
      break;
    }
  }
  if (!source.manager)
    return items;
  const { dragOperation } = source.manager;
  const position = (_b3 = (_a5 = dragOperation.shape) == null ? void 0 : _a5.current.center) != null ? _b3 : dragOperation.position.current;
  if (targetParent == null) {
    if (target.id in items) {
      const insertionIndex = target.shape && position.y > target.shape.center.y ? items[target.id].length : 0;
      targetParent = target.id;
      targetIndex = insertionIndex;
    }
  }
  if (sourceParent == null || targetParent == null || sourceParent === targetParent && sourceIndex === targetIndex) {
    if ("preventDefault" in event)
      event.preventDefault();
    return items;
  }
  if (sourceParent === targetParent) {
    return __spreadProps22(__spreadValues22({}, items), {
      [sourceParent]: mutation(items[sourceParent], sourceIndex, targetIndex)
    });
  }
  const isBelowTarget = target.shape && Math.round(position.y) > Math.round(target.shape.center.y);
  const modifier = isBelowTarget ? 1 : 0;
  const sourceItem = items[sourceParent][sourceIndex];
  return __spreadProps22(__spreadValues22({}, items), {
    [sourceParent]: [
      ...items[sourceParent].slice(0, sourceIndex),
      ...items[sourceParent].slice(sourceIndex + 1)
    ],
    [targetParent]: [
      ...items[targetParent].slice(0, targetIndex + modifier),
      sourceItem,
      ...items[targetParent].slice(targetIndex + modifier)
    ]
  });
}
function move(items, event) {
  return mutate(items, event, arrayMove);
}
var defaultGroup = "__default__";
var OptimisticSortingPlugin = class extends Plugin {
  constructor(manager) {
    super(manager);
    const getSortableInstances = () => {
      const sortableInstances = /* @__PURE__ */ new Map();
      for (const droppable of manager.registry.droppables) {
        if (droppable instanceof SortableDroppable) {
          const { sortable } = droppable;
          const { group } = sortable;
          let instances = sortableInstances.get(group);
          if (!instances) {
            instances = /* @__PURE__ */ new Set();
            sortableInstances.set(group, instances);
          }
          instances.add(sortable);
        }
      }
      for (const [group, instances] of sortableInstances) {
        sortableInstances.set(group, new Set(sort(instances)));
      }
      return sortableInstances;
    };
    const unsubscribe = [
      manager.monitor.addEventListener("dragover", (event, manager2) => {
        if (this.disabled) {
          return;
        }
        const { dragOperation } = manager2;
        const { source, target } = dragOperation;
        if (!isSortable(source) || !isSortable(target)) {
          return;
        }
        if (source.sortable === target.sortable) {
          return;
        }
        const instances = getSortableInstances();
        const sameGroup = source.sortable.group === target.sortable.group;
        const sourceInstances = instances.get(source.sortable.group);
        const targetInstances = sameGroup ? sourceInstances : instances.get(target.sortable.group);
        if (!sourceInstances || !targetInstances)
          return;
        queueMicrotask(() => {
          if (event.defaultPrevented)
            return;
          manager2.renderer.rendering.then(() => {
            var _a5, _b3, _c4;
            const newInstances = getSortableInstances();
            for (const [group, sortableInstances] of instances.entries()) {
              const entries = Array.from(sortableInstances).entries();
              for (const [index, sortable] of entries) {
                if (sortable.index !== index || sortable.group !== group || !((_a5 = newInstances.get(group)) == null ? void 0 : _a5.has(sortable))) {
                  return;
                }
              }
            }
            const sourceElement = source.sortable.element;
            const targetElement = target.sortable.element;
            if (!targetElement || !sourceElement) {
              return;
            }
            if (!sameGroup && target.id === source.sortable.group) {
              return;
            }
            const orderedSourceSortables = sort(sourceInstances);
            const orderedTargetSortables = sameGroup ? orderedSourceSortables : sort(targetInstances);
            const sourceGroup = (_b3 = source.sortable.group) != null ? _b3 : defaultGroup;
            const targetGroup = (_c4 = target.sortable.group) != null ? _c4 : defaultGroup;
            const state = {
              [sourceGroup]: orderedSourceSortables,
              [targetGroup]: orderedTargetSortables
            };
            const newState = move(state, event);
            if (state === newState)
              return;
            const sourceIndex = newState[targetGroup].indexOf(source.sortable);
            const targetIndex = newState[targetGroup].indexOf(target.sortable);
            manager2.collisionObserver.disable();
            reorder(sourceElement, sourceIndex, targetElement, targetIndex);
            r(() => {
              for (const [index, sortable] of newState[sourceGroup].entries()) {
                sortable.index = index;
              }
              if (!sameGroup) {
                for (const [index, sortable] of newState[targetGroup].entries()) {
                  sortable.group = target.sortable.group;
                  sortable.index = index;
                }
              }
            });
            manager2.actions.setDropTarget(source.id).then(() => manager2.collisionObserver.enable());
          });
        });
      }),
      manager.monitor.addEventListener("dragend", (event, manager2) => {
        if (!event.canceled) {
          return;
        }
        const { dragOperation } = manager2;
        const { source } = dragOperation;
        if (!isSortable(source)) {
          return;
        }
        if (source.sortable.initialIndex === source.sortable.index && source.sortable.initialGroup === source.sortable.group) {
          return;
        }
        queueMicrotask(() => {
          const instances = getSortableInstances();
          const initialGroupInstances = instances.get(
            source.sortable.initialGroup
          );
          if (!initialGroupInstances)
            return;
          manager2.renderer.rendering.then(() => {
            for (const [group, sortableInstances] of instances.entries()) {
              const entries = Array.from(sortableInstances).entries();
              for (const [index, sortable] of entries) {
                if (sortable.index !== index || sortable.group !== group) {
                  return;
                }
              }
            }
            const initialGroup = sort(initialGroupInstances);
            const sourceElement = source.sortable.element;
            const target = initialGroup[source.sortable.initialIndex];
            const targetElement = target == null ? void 0 : target.element;
            if (!target || !targetElement || !sourceElement) {
              return;
            }
            reorder(sourceElement, target.index, targetElement, source.index);
            r(() => {
              for (const [_2, sortableInstances] of instances.entries()) {
                const entries = Array.from(sortableInstances).values();
                for (const sortable of entries) {
                  sortable.index = sortable.initialIndex;
                  sortable.group = sortable.initialGroup;
                }
              }
            });
          });
        });
      })
    ];
    this.destroy = () => {
      for (const unsubscribeListener of unsubscribe) {
        unsubscribeListener();
      }
    };
  }
};
function reorder(sourceElement, sourceIndex, targetElement, targetIndex) {
  const position = targetIndex < sourceIndex ? "afterend" : "beforebegin";
  targetElement.insertAdjacentElement(position, sourceElement);
}
function sortByIndex(a2, b2) {
  return a2.index - b2.index;
}
function sort(instances) {
  return Array.from(instances).sort(sortByIndex);
}
var defaultPlugins = [
  SortableKeyboardPlugin,
  OptimisticSortingPlugin
];
var defaultSortableTransition = {
  duration: 250,
  easing: "cubic-bezier(0.25, 1, 0.5, 1)",
  idle: false
};
var store = new WeakStore();
var _group_dec;
var _index_dec;
var _init9;
var _index;
var _previousGroup;
var _previousIndex;
var _group;
var _element3;
_index_dec = [reactive], _group_dec = [reactive];
var Sortable2 = class {
  constructor(_a5, manager) {
    __privateAdd7(this, _index, __runInitializers6(_init9, 8, this)), __runInitializers6(_init9, 11, this);
    __privateAdd7(this, _previousGroup);
    __privateAdd7(this, _previousIndex);
    __privateAdd7(this, _group, __runInitializers6(_init9, 12, this)), __runInitializers6(_init9, 15, this);
    __privateAdd7(this, _element3);
    this.register = () => {
      r(() => {
        var _a6, _b4;
        (_a6 = this.manager) == null ? void 0 : _a6.registry.register(this.droppable);
        (_b4 = this.manager) == null ? void 0 : _b4.registry.register(this.draggable);
      });
      return () => this.unregister();
    };
    this.unregister = () => {
      r(() => {
        var _a6, _b4;
        (_a6 = this.manager) == null ? void 0 : _a6.registry.unregister(this.droppable);
        (_b4 = this.manager) == null ? void 0 : _b4.registry.unregister(this.draggable);
      });
    };
    this.destroy = () => {
      r(() => {
        this.droppable.destroy();
        this.draggable.destroy();
      });
    };
    var _b3 = _a5, {
      effects: inputEffects = () => [],
      group,
      index,
      sensors,
      type,
      transition = defaultSortableTransition,
      plugins = defaultPlugins
    } = _b3, input = __objRest5(_b3, [
      "effects",
      "group",
      "index",
      "sensors",
      "type",
      "transition",
      "plugins"
    ]);
    this.droppable = new SortableDroppable(input, manager, this);
    this.draggable = new SortableDraggable(
      __spreadProps6(__spreadValues7({}, input), {
        effects: () => [
          () => {
            var _a23, _b22, _c4;
            const status = (_a23 = this.manager) == null ? void 0 : _a23.dragOperation.status;
            if ((status == null ? void 0 : status.initializing) && this.id === ((_c4 = (_b22 = this.manager) == null ? void 0 : _b22.dragOperation.source) == null ? void 0 : _c4.id)) {
              store.clear(this.manager);
            }
            if (status == null ? void 0 : status.dragging) {
              store.set(
                this.manager,
                this.id,
                n(() => ({
                  initialIndex: this.index,
                  initialGroup: this.group
                }))
              );
            }
          },
          () => {
            const { index: index2, group: group2, manager: _2 } = this;
            const previousIndex = __privateGet7(this, _previousIndex);
            const previousGroup = __privateGet7(this, _previousGroup);
            if (index2 !== previousIndex || group2 !== previousGroup) {
              __privateSet7(this, _previousIndex, index2);
              __privateSet7(this, _previousGroup, group2);
              this.animate();
            }
          },
          () => {
            const { target } = this;
            const { feedback, isDragSource } = this.draggable;
            if (feedback == "move" && isDragSource) {
              this.droppable.disabled = !target;
            }
          },
          () => {
            const { manager: manager2 } = this;
            for (const plugin of plugins) {
              manager2 == null ? void 0 : manager2.registry.register(plugin);
            }
          },
          ...inputEffects()
        ],
        type,
        sensors
      }),
      manager,
      this
    );
    __privateSet7(this, _element3, input.element);
    this.manager = manager;
    this.index = index;
    __privateSet7(this, _previousIndex, index);
    this.group = group;
    __privateSet7(this, _previousGroup, group);
    this.type = type;
    this.transition = transition;
  }
  get initialIndex() {
    var _a5, _b3;
    return (_b3 = (_a5 = store.get(this.manager, this.id)) == null ? void 0 : _a5.initialIndex) != null ? _b3 : this.index;
  }
  get initialGroup() {
    var _a5, _b3;
    return (_b3 = (_a5 = store.get(this.manager, this.id)) == null ? void 0 : _a5.initialGroup) != null ? _b3 : this.group;
  }
  animate() {
    n(() => {
      const { manager, transition } = this;
      const { shape } = this.droppable;
      if (!manager)
        return;
      const { idle } = manager.dragOperation.status;
      if (!shape || !transition || idle && !transition.idle) {
        return;
      }
      manager.renderer.rendering.then(() => {
        const { element } = this;
        if (!element) {
          return;
        }
        const updatedShape = this.refreshShape();
        if (!updatedShape) {
          return;
        }
        const delta = {
          x: shape.boundingRectangle.left - updatedShape.boundingRectangle.left,
          y: shape.boundingRectangle.top - updatedShape.boundingRectangle.top
        };
        const { translate } = getComputedStyles(element);
        const currentTranslate = computeTranslate(element, translate, false);
        const finalTranslate = computeTranslate(element, translate);
        if (delta.x || delta.y) {
          animateTransform({
            element,
            keyframes: {
              translate: [
                `${currentTranslate.x + delta.x}px ${currentTranslate.y + delta.y}px ${currentTranslate.z}`,
                `${finalTranslate.x}px ${finalTranslate.y}px ${finalTranslate.z}`
              ]
            },
            options: transition
          }).then(() => {
            if (!manager.dragOperation.status.dragging) {
              this.droppable.shape = void 0;
            }
          });
        }
      });
    });
  }
  get manager() {
    return this.draggable.manager;
  }
  set manager(manager) {
    r(() => {
      this.draggable.manager = manager;
      this.droppable.manager = manager;
    });
  }
  set element(element) {
    r(() => {
      const previousElement = __privateGet7(this, _element3);
      const droppableElement = this.droppable.element;
      const draggableElement = this.draggable.element;
      if (!droppableElement || droppableElement === previousElement) {
        this.droppable.element = element;
      }
      if (!draggableElement || draggableElement === previousElement) {
        this.draggable.element = element;
      }
      __privateSet7(this, _element3, element);
    });
  }
  get element() {
    var _a5, _b3;
    const element = __privateGet7(this, _element3);
    if (!element)
      return;
    return (_b3 = (_a5 = ProxiedElements.get(element)) != null ? _a5 : element) != null ? _b3 : this.droppable.element;
  }
  set target(target) {
    this.droppable.element = target;
  }
  get target() {
    return this.droppable.element;
  }
  set source(source) {
    this.draggable.element = source;
  }
  get source() {
    return this.draggable.element;
  }
  get disabled() {
    return this.draggable.disabled && this.droppable.disabled;
  }
  set feedback(value) {
    this.draggable.feedback = value;
  }
  set disabled(value) {
    r(() => {
      this.droppable.disabled = value;
      this.draggable.disabled = value;
    });
  }
  set data(data) {
    r(() => {
      this.droppable.data = data;
      this.draggable.data = data;
    });
  }
  set handle(handle) {
    this.draggable.handle = handle;
  }
  set id(id) {
    r(() => {
      this.droppable.id = id;
      this.draggable.id = id;
    });
  }
  get id() {
    return this.droppable.id;
  }
  set sensors(value) {
    this.draggable.sensors = value;
  }
  set modifiers(value) {
    this.draggable.modifiers = value;
  }
  set collisionPriority(value) {
    this.droppable.collisionPriority = value;
  }
  set collisionDetector(value) {
    this.droppable.collisionDetector = value != null ? value : defaultCollisionDetection;
  }
  set alignment(value) {
    this.draggable.alignment = value;
  }
  get alignment() {
    return this.draggable.alignment;
  }
  set type(type) {
    r(() => {
      this.droppable.type = type;
      this.draggable.type = type;
    });
  }
  get type() {
    return this.draggable.type;
  }
  set accept(value) {
    this.droppable.accept = value;
  }
  get accept() {
    return this.droppable.accept;
  }
  get isDropTarget() {
    return this.droppable.isDropTarget;
  }
  /**
   * A boolean indicating whether the sortable item is the source of a drag operation.
   */
  get isDragSource() {
    return this.draggable.isDragSource;
  }
  /**
   * A boolean indicating whether the sortable item is being dragged.
   */
  get isDragging() {
    return this.draggable.isDragging;
  }
  /**
   * A boolean indicating whether the sortable item is being dropped.
   */
  get isDropping() {
    return this.draggable.isDropping;
  }
  get status() {
    return this.draggable.status;
  }
  refreshShape() {
    return this.droppable.refreshShape();
  }
  accepts(draggable) {
    return this.droppable.accepts(draggable);
  }
};
_init9 = __decoratorStart6();
_index = /* @__PURE__ */ new WeakMap();
_previousGroup = /* @__PURE__ */ new WeakMap();
_previousIndex = /* @__PURE__ */ new WeakMap();
_group = /* @__PURE__ */ new WeakMap();
_element3 = /* @__PURE__ */ new WeakMap();
__decorateElement6(_init9, 4, "index", _index_dec, Sortable2, _index);
__decorateElement6(_init9, 4, "group", _group_dec, Sortable2, _group);
__decoratorMetadata6(_init9, Sortable2);
var SortableDraggable = class extends Draggable2 {
  constructor(input, manager, sortable) {
    super(input, manager);
    this.sortable = sortable;
  }
  get index() {
    return this.sortable.index;
  }
};
var SortableDroppable = class extends Droppable2 {
  constructor(input, manager, sortable) {
    super(input, manager);
    this.sortable = sortable;
  }
};

// node_modules/@measured/puck/node_modules/@dnd-kit/react/sortable.js
var __defProp8 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols8 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues8 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp8.call(b2, prop))
      __defNormalProp8(a2, prop, b2[prop]);
  if (__getOwnPropSymbols8)
    for (var prop of __getOwnPropSymbols8(b2)) {
      if (__propIsEnum8.call(b2, prop))
        __defNormalProp8(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps7 = (a2, b2) => __defProps7(a2, __getOwnPropDescs7(b2));
function useSortable(input) {
  const {
    accept,
    collisionDetector,
    collisionPriority,
    id,
    data,
    element,
    handle,
    index,
    group,
    disabled,
    feedback,
    modifiers,
    sensors,
    target,
    type
  } = input;
  const transition = __spreadValues8(__spreadValues8({}, defaultSortableTransition), input.transition);
  const sortable = useInstance((manager) => {
    return new Sortable2(
      __spreadProps7(__spreadValues8({}, input), {
        transition,
        register: false,
        handle: currentValue(handle),
        element: currentValue(element),
        target: currentValue(target),
        feedback
      }),
      manager
    );
  });
  const trackedSortable = useDeepSignal(sortable, shouldUpdateSynchronously2);
  useOnValueChange(id, () => sortable.id = id);
  useIsomorphicLayoutEffect(() => {
    r(() => {
      sortable.group = group;
      sortable.index = index;
    });
  }, [sortable, group, index]);
  useOnValueChange(type, () => sortable.type = type);
  useOnValueChange(
    accept,
    () => sortable.accept = accept,
    void 0,
    deepEqual
  );
  useOnValueChange(data, () => data && (sortable.data = data));
  useOnValueChange(
    index,
    () => {
      var _a5;
      if (((_a5 = sortable.manager) == null ? void 0 : _a5.dragOperation.status.idle) && (transition == null ? void 0 : transition.idle)) {
        sortable.refreshShape();
      }
    },
    useImmediateEffect
  );
  useOnElementChange(handle, (handle2) => sortable.handle = handle2);
  useOnElementChange(element, (element2) => sortable.element = element2);
  useOnElementChange(target, (target2) => sortable.target = target2);
  useOnValueChange(disabled, () => sortable.disabled = disabled === true);
  useOnValueChange(sensors, () => sortable.sensors = sensors);
  useOnValueChange(
    collisionDetector,
    () => sortable.collisionDetector = collisionDetector
  );
  useOnValueChange(
    collisionPriority,
    () => sortable.collisionPriority = collisionPriority
  );
  useOnValueChange(feedback, () => sortable.feedback = feedback != null ? feedback : "default");
  useOnValueChange(
    transition,
    () => sortable.transition = transition,
    void 0,
    deepEqual
  );
  useOnValueChange(
    modifiers,
    () => sortable.modifiers = modifiers,
    void 0,
    deepEqual
  );
  useOnValueChange(
    input.alignment,
    () => sortable.alignment = input.alignment
  );
  return {
    sortable: trackedSortable,
    get isDragging() {
      return trackedSortable.isDragging;
    },
    get isDropping() {
      return trackedSortable.isDropping;
    },
    get isDragSource() {
      return trackedSortable.isDragSource;
    },
    get isDropTarget() {
      return trackedSortable.isDropTarget;
    },
    handleRef: (0, import_react7.useCallback)(
      (element2) => {
        sortable.handle = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    ref: (0, import_react7.useCallback)(
      (element2) => {
        var _a5, _b3;
        if (!element2 && ((_a5 = sortable.element) == null ? void 0 : _a5.isConnected) && !((_b3 = sortable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        sortable.element = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    sourceRef: (0, import_react7.useCallback)(
      (element2) => {
        var _a5, _b3;
        if (!element2 && ((_a5 = sortable.source) == null ? void 0 : _a5.isConnected) && !((_b3 = sortable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        sortable.source = element2 != null ? element2 : void 0;
      },
      [sortable]
    ),
    targetRef: (0, import_react7.useCallback)(
      (element2) => {
        var _a5, _b3;
        if (!element2 && ((_a5 = sortable.target) == null ? void 0 : _a5.isConnected) && !((_b3 = sortable.manager) == null ? void 0 : _b3.dragOperation.status.idle)) {
          return;
        }
        sortable.target = element2 != null ? element2 : void 0;
      },
      [sortable]
    )
  };
}
function shouldUpdateSynchronously2(key, oldValue, newValue) {
  if (key === "isDragSource" && !newValue && oldValue)
    return true;
  return false;
}

// node_modules/@measured/puck/dist/chunk-V7Y7BFEC.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
var import_react27 = __toESM(require_react(), 1);
var import_react28 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);
var import_react31 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var import_react32 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);

// node_modules/zustand/esm/react/shallow.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/zustand/esm/vanilla/shallow.mjs
var isIterable = (obj) => Symbol.iterator in obj;
var hasIterableEntries = (value) => (
  // HACK: avoid checking entries type
  "entries" in value
);
var compareEntries = (valueA, valueB) => {
  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries());
  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries());
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA) {
    if (!mapB.has(key) || !Object.is(value, mapB.get(key))) {
      return false;
    }
  }
  return true;
};
var compareIterables = (valueA, valueB) => {
  const iteratorA = valueA[Symbol.iterator]();
  const iteratorB = valueB[Symbol.iterator]();
  let nextA = iteratorA.next();
  let nextB = iteratorB.next();
  while (!nextA.done && !nextB.done) {
    if (!Object.is(nextA.value, nextB.value)) {
      return false;
    }
    nextA = iteratorA.next();
    nextB = iteratorB.next();
  }
  return !!nextA.done && !!nextB.done;
};
function shallow(valueA, valueB) {
  if (Object.is(valueA, valueB)) {
    return true;
  }
  if (typeof valueA !== "object" || valueA === null || typeof valueB !== "object" || valueB === null) {
    return false;
  }
  if (Object.getPrototypeOf(valueA) !== Object.getPrototypeOf(valueB)) {
    return false;
  }
  if (isIterable(valueA) && isIterable(valueB)) {
    if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {
      return compareEntries(valueA, valueB);
    }
    return compareIterables(valueA, valueB);
  }
  return compareEntries(
    { entries: () => Object.entries(valueA) },
    { entries: () => Object.entries(valueB) }
  );
}

// node_modules/zustand/esm/react/shallow.mjs
function useShallow(selector) {
  const prev = import_react9.default.useRef(void 0);
  return (state) => {
    const next = selector(state);
    return shallow(prev.current, next) ? prev.current : prev.current = next;
  };
}

// node_modules/@measured/puck/dist/chunk-V7Y7BFEC.mjs
var import_react33 = __toESM(require_react(), 1);
var import_react34 = __toESM(require_react(), 1);
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);
var import_react38 = __toESM(require_react(), 1);

// node_modules/use-debounce/dist/index.module.js
var import_react10 = __toESM(require_react());
function c2(u3, e3, c3) {
  var i2 = this, a2 = (0, import_react10.useRef)(null), o2 = (0, import_react10.useRef)(0), f3 = (0, import_react10.useRef)(null), l2 = (0, import_react10.useRef)([]), m = (0, import_react10.useRef)(), v2 = (0, import_react10.useRef)(), d2 = (0, import_react10.useRef)(u3), p2 = (0, import_react10.useRef)(true);
  (0, import_react10.useEffect)(function() {
    d2.current = u3;
  }, [u3]);
  var g2 = !e3 && 0 !== e3 && "undefined" != typeof window;
  if ("function" != typeof u3)
    throw new TypeError("Expected a function");
  e3 = +e3 || 0;
  var w2 = !!(c3 = c3 || {}).leading, s2 = !("trailing" in c3) || !!c3.trailing, x = "maxWait" in c3, y2 = x ? Math.max(+c3.maxWait || 0, e3) : null;
  (0, import_react10.useEffect)(function() {
    return p2.current = true, function() {
      p2.current = false;
    };
  }, []);
  var h2 = (0, import_react10.useMemo)(function() {
    var r3 = function(r4) {
      var n4 = l2.current, t4 = m.current;
      return l2.current = m.current = null, o2.current = r4, v2.current = d2.current.apply(t4, n4);
    }, n3 = function(r4, n4) {
      g2 && cancelAnimationFrame(f3.current), f3.current = g2 ? requestAnimationFrame(r4) : setTimeout(r4, n4);
    }, t3 = function(r4) {
      if (!p2.current)
        return false;
      var n4 = r4 - a2.current;
      return !a2.current || n4 >= e3 || n4 < 0 || x && r4 - o2.current >= y2;
    }, u4 = function(n4) {
      return f3.current = null, s2 && l2.current ? r3(n4) : (l2.current = m.current = null, v2.current);
    }, c4 = function r4() {
      var c5 = Date.now();
      if (t3(c5))
        return u4(c5);
      if (p2.current) {
        var i3 = e3 - (c5 - a2.current), f4 = x ? Math.min(i3, y2 - (c5 - o2.current)) : i3;
        n3(r4, f4);
      }
    }, h3 = function() {
      var u5 = Date.now(), d3 = t3(u5);
      if (l2.current = [].slice.call(arguments), m.current = i2, a2.current = u5, d3) {
        if (!f3.current && p2.current)
          return o2.current = a2.current, n3(c4, e3), w2 ? r3(a2.current) : v2.current;
        if (x)
          return n3(c4, e3), r3(a2.current);
      }
      return f3.current || n3(c4, e3), v2.current;
    };
    return h3.cancel = function() {
      f3.current && (g2 ? cancelAnimationFrame(f3.current) : clearTimeout(f3.current)), o2.current = 0, l2.current = a2.current = m.current = f3.current = null;
    }, h3.isPending = function() {
      return !!f3.current;
    }, h3.flush = function() {
      return f3.current ? u4(Date.now()) : v2.current;
    }, h3;
  }, [w2, x, e3, y2, s2, g2]);
  return h2;
}

// node_modules/@measured/puck/dist/chunk-V7Y7BFEC.mjs
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
var import_react41 = __toESM(require_react(), 1);
var import_react43 = __toESM(require_react(), 1);
var import_react44 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var import_react48 = __toESM(require_react(), 1);
var import_react49 = __toESM(require_react(), 1);
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var import_react52 = __toESM(require_react(), 1);
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);
var import_react55 = __toESM(require_react(), 1);
var import_object_hash = __toESM(require_object_hash(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var import_react59 = __toESM(require_react(), 1);
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react60 = __toESM(require_react(), 1);
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react61 = __toESM(require_react(), 1);
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react62 = __toESM(require_react(), 1);
var import_react63 = __toESM(require_react(), 1);
var import_fast_deep_equal3 = __toESM(require_fast_deep_equal(), 1);
var import_react64 = __toESM(require_react(), 1);
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var require_classnames = __commonJS2({
  "../../node_modules/classnames/index.js"(exports, module) {
    "use strict";
    init_react_import();
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});
init_react_import();
var overrideKeys = [
  "header",
  "headerActions",
  "fields",
  "fieldLabel",
  "drawer",
  "drawerItem",
  "componentOverlay",
  "outline",
  "puck",
  "preview"
];
init_react_import();
init_react_import();
var import_classnames = __toESM2(require_classnames());
var getClassNameFactory = (rootClass, styles2, config = { baseClass: "" }) => (options2 = {}) => {
  if (typeof options2 === "string") {
    const descendant = options2;
    const style = styles2[`${rootClass}-${descendant}`];
    if (style) {
      return config.baseClass + styles2[`${rootClass}-${descendant}`] || "";
    }
    return "";
  } else if (typeof options2 === "object") {
    const modifiers = options2;
    const prefixedModifiers = {};
    for (let modifier in modifiers) {
      prefixedModifiers[styles2[`${rootClass}--${modifier}`]] = modifiers[modifier];
    }
    const c3 = styles2[rootClass];
    return config.baseClass + (0, import_classnames.default)(__spreadValues({
      [c3]: !!c3
    }, prefixedModifiers));
  } else {
    return config.baseClass + styles2[rootClass] || "";
  }
};
var get_class_name_factory_default = getClassNameFactory;
init_react_import();
var styles_module_default = { "ActionBar": "_ActionBar_rvadt_1", "ActionBar-label": "_ActionBar-label_rvadt_18", "ActionBar-action": "_ActionBar-action_rvadt_30", "ActionBar-group": "_ActionBar-group_rvadt_38" };
var getClassName = get_class_name_factory_default("ActionBar", styles_module_default);
var ActionBar = ({
  label,
  children
}) => (0, import_jsx_runtime3.jsxs)(
  "div",
  {
    className: getClassName(),
    onClick: (e3) => {
      e3.stopPropagation();
    },
    children: [
      label && (0, import_jsx_runtime3.jsx)(ActionBar.Group, { children: (0, import_jsx_runtime3.jsx)("div", { className: getClassName("label"), children: label }) }),
      children
    ]
  }
);
var Action = ({
  children,
  label,
  onClick
}) => (0, import_jsx_runtime3.jsx)(
  "button",
  {
    type: "button",
    className: getClassName("action"),
    onClick,
    title: label,
    children
  }
);
var Group = ({ children }) => (0, import_jsx_runtime3.jsx)("div", { className: getClassName("group"), children });
var Label = ({ label }) => (0, import_jsx_runtime3.jsx)("div", { className: getClassName("label"), children: label });
ActionBar.Action = Action;
ActionBar.Label = Label;
ActionBar.Group = Group;
init_react_import();
init_react_import();
var IconButton_module_default = { "IconButton": "_IconButton_swpni_1", "IconButton--disabled": "_IconButton--disabled_swpni_20", "IconButton-title": "_IconButton-title_swpni_33" };
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var reorder2 = (list, startIndex, endIndex) => {
  const result = Array.from(list);
  const [removed] = result.splice(startIndex, 1);
  result.splice(endIndex, 0, removed);
  return result;
};
init_react_import();
var replace = (list, index, newItem) => {
  const result = Array.from(list);
  result.splice(index, 1);
  result.splice(index, 0, newItem);
  return result;
};
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var setAction = (state, action, appStore) => {
  if (typeof action.state === "object") {
    const newState = __spreadValues(__spreadValues({}, state), action.state);
    if (action.state.indexes) {
      return newState;
    }
    console.warn(
      "`set` is expensive and may cause unnecessary re-renders. Consider using a more atomic action instead."
    );
    return walkAppState(newState, appStore.config);
  }
  return __spreadValues(__spreadValues({}, state), action.state(state));
};
init_react_import();
init_react_import();
var insert = (list, index, item) => {
  const result = Array.from(list || []);
  result.splice(index, 0, item);
  return result;
};
init_react_import();
var generateId = (type) => type ? `${type}-${v4_default()}` : v4_default();
init_react_import();
var getIdsForParent = (zoneCompound, state) => {
  const [parentId] = zoneCompound.split(":");
  const node = state.indexes.nodes[parentId];
  return ((node == null ? void 0 : node.path) || []).map((p2) => p2.split(":")[0]);
};
init_react_import();
var populateIds = (data, config, override = false) => {
  const id = generateId(data.type);
  return walkTree(
    __spreadProps(__spreadValues({}, data), {
      props: override ? __spreadProps(__spreadValues({}, data.props), { id }) : __spreadValues({}, data.props)
    }),
    config,
    (contents) => contents.map((item) => {
      const id2 = generateId(item.type);
      return __spreadProps(__spreadValues({}, item), {
        props: override ? __spreadProps(__spreadValues({}, item.props), { id: id2 }) : __spreadValues({ id: id2 }, item.props)
      });
    })
  );
};
function insertAction(state, action, appStore) {
  const id = action.id || generateId(action.componentType);
  const emptyComponentData = populateIds(
    {
      type: action.componentType,
      props: __spreadProps(__spreadValues({}, appStore.config.components[action.componentType].defaultProps || {}), {
        id
      })
    },
    appStore.config
  );
  const [parentId] = action.destinationZone.split(":");
  const idsInPath = getIdsForParent(action.destinationZone, state);
  return walkAppState(
    state,
    appStore.config,
    (content, zoneCompound) => {
      if (zoneCompound === action.destinationZone) {
        return insert(
          content || [],
          action.destinationIndex,
          emptyComponentData
        );
      }
      return content;
    },
    (childItem, path) => {
      if (childItem.props.id === id || childItem.props.id === parentId) {
        return childItem;
      } else if (idsInPath.includes(childItem.props.id)) {
        return childItem;
      } else if (path.includes(action.destinationZone)) {
        return childItem;
      }
      return null;
    }
  );
}
init_react_import();
var replaceAction = (state, action, appStore) => {
  const [parentId] = action.destinationZone.split(":");
  const idsInPath = getIdsForParent(action.destinationZone, state);
  const originalId = state.indexes.zones[action.destinationZone].contentIds[action.destinationIndex];
  const idChanged = originalId !== action.data.props.id;
  if (idChanged) {
    throw new Error(
      `Can't change the id during a replace action. Please us "remove" and "insert" to define a new node.`
    );
  }
  const newSlotIds = [];
  const data = walkTree(action.data, appStore.config, (contents, opts) => {
    newSlotIds.push(`${opts.parentId}:${opts.propName}`);
    return contents.map((item) => {
      const id = generateId(item.type);
      return __spreadProps(__spreadValues({}, item), {
        props: __spreadValues({ id }, item.props)
      });
    });
  });
  const stateWithDeepSlotsRemoved = __spreadValues({}, state);
  Object.keys(state.indexes.zones).forEach((zoneCompound) => {
    const id = zoneCompound.split(":")[0];
    if (id === originalId) {
      if (!newSlotIds.includes(zoneCompound)) {
        delete stateWithDeepSlotsRemoved.indexes.zones[zoneCompound];
      }
    }
  });
  return walkAppState(
    stateWithDeepSlotsRemoved,
    appStore.config,
    (content, zoneCompound) => {
      const newContent = [...content];
      if (zoneCompound === action.destinationZone) {
        newContent[action.destinationIndex] = data;
      }
      return newContent;
    },
    (childItem, path) => {
      const pathIds = path.map((p2) => p2.split(":")[0]);
      if (childItem.props.id === data.props.id) {
        return data;
      } else if (childItem.props.id === parentId) {
        return childItem;
      } else if (idsInPath.indexOf(childItem.props.id) > -1) {
        return childItem;
      } else if (pathIds.indexOf(data.props.id) > -1) {
        return childItem;
      }
      return null;
    }
  );
};
init_react_import();
var replaceRootAction = (state, action, appStore) => {
  return walkAppState(
    state,
    appStore.config,
    (content) => content,
    (childItem) => {
      if (childItem.props.id === "root") {
        return __spreadProps(__spreadValues({}, childItem), {
          props: __spreadValues(__spreadValues({}, childItem.props), action.root.props),
          readOnly: action.root.readOnly
        });
      }
      return childItem;
    }
  );
};
init_react_import();
init_react_import();
function getItem(selector, state) {
  var _a5, _b3;
  const zone = (_a5 = state.indexes.zones) == null ? void 0 : _a5[selector.zone || rootDroppableId];
  return zone ? (_b3 = state.indexes.nodes[zone.contentIds[selector.index]]) == null ? void 0 : _b3.data : void 0;
}
function duplicateAction(state, action, appStore) {
  const item = getItem(
    { index: action.sourceIndex, zone: action.sourceZone },
    state
  );
  const idsInPath = getIdsForParent(action.sourceZone, state);
  const newItem = __spreadProps(__spreadValues({}, item), {
    props: __spreadProps(__spreadValues({}, item.props), {
      id: generateId(item.type)
    })
  });
  const modified = walkAppState(
    state,
    appStore.config,
    (content, zoneCompound) => {
      if (zoneCompound === action.sourceZone) {
        return insert(content, action.sourceIndex + 1, item);
      }
      return content;
    },
    (childItem, path, index) => {
      const zoneCompound = path[path.length - 1];
      const parents = path.map((p2) => p2.split(":")[0]);
      if (parents.indexOf(newItem.props.id) > -1) {
        return __spreadProps(__spreadValues({}, childItem), {
          props: __spreadProps(__spreadValues({}, childItem.props), {
            id: generateId(childItem.type)
          })
        });
      }
      if (zoneCompound === action.sourceZone && index === action.sourceIndex + 1) {
        return newItem;
      }
      const [sourceZoneParent] = action.sourceZone.split(":");
      if (sourceZoneParent === childItem.props.id || idsInPath.indexOf(childItem.props.id) > -1) {
        return childItem;
      }
      return null;
    }
  );
  return __spreadProps(__spreadValues({}, modified), {
    ui: __spreadProps(__spreadValues({}, modified.ui), {
      itemSelector: {
        index: action.sourceIndex + 1,
        zone: action.sourceZone
      }
    })
  });
}
init_react_import();
init_react_import();
init_react_import();
var remove = (list, index) => {
  const result = Array.from(list);
  result.splice(index, 1);
  return result;
};
var moveAction = (state, action, appStore) => {
  if (action.sourceZone === action.destinationZone && action.sourceIndex === action.destinationIndex) {
    return state;
  }
  const item = getItem(
    { zone: action.sourceZone, index: action.sourceIndex },
    state
  );
  if (!item)
    return state;
  const idsInSourcePath = getIdsForParent(action.sourceZone, state);
  const idsInDestinationPath = getIdsForParent(action.destinationZone, state);
  return walkAppState(
    state,
    appStore.config,
    (content, zoneCompound) => {
      if (zoneCompound === action.sourceZone && zoneCompound === action.destinationZone) {
        return insert(
          remove(content, action.sourceIndex),
          action.destinationIndex,
          item
        );
      } else if (zoneCompound === action.sourceZone) {
        return remove(content, action.sourceIndex);
      } else if (zoneCompound === action.destinationZone) {
        return insert(content, action.destinationIndex, item);
      }
      return content;
    },
    (childItem, path) => {
      const [sourceZoneParent] = action.sourceZone.split(":");
      const [destinationZoneParent] = action.destinationZone.split(":");
      const childId = childItem.props.id;
      if (sourceZoneParent === childId || destinationZoneParent === childId || item.props.id === childId || idsInSourcePath.indexOf(childId) > -1 || idsInDestinationPath.indexOf(childId) > -1 || path.includes(action.destinationZone)) {
        return childItem;
      }
      return null;
    }
  );
};
var reorderAction = (state, action, appStore) => {
  return moveAction(
    state,
    {
      type: "move",
      sourceIndex: action.sourceIndex,
      sourceZone: action.destinationZone,
      destinationIndex: action.destinationIndex,
      destinationZone: action.destinationZone
    },
    appStore
  );
};
init_react_import();
var removeAction = (state, action, appStore) => {
  const item = getItem({ index: action.index, zone: action.zone }, state);
  const nodesToDelete = Object.entries(state.indexes.nodes).reduce(
    (acc, [nodeId, nodeData]) => {
      const pathIds = nodeData.path.map((p2) => p2.split(":")[0]);
      if (pathIds.includes(item.props.id)) {
        return [...acc, nodeId];
      }
      return acc;
    },
    [item.props.id]
  );
  const newState = walkAppState(
    state,
    appStore.config,
    (content, zoneCompound) => {
      if (zoneCompound === action.zone) {
        return remove(content, action.index);
      }
      return content;
    }
  );
  Object.keys(newState.data.zones || {}).forEach((zoneCompound) => {
    const parentId = zoneCompound.split(":")[0];
    if (nodesToDelete.includes(parentId) && newState.data.zones) {
      delete newState.data.zones[zoneCompound];
    }
  });
  Object.keys(newState.indexes.zones).forEach((zoneCompound) => {
    const parentId = zoneCompound.split(":")[0];
    if (nodesToDelete.includes(parentId)) {
      delete newState.indexes.zones[zoneCompound];
    }
  });
  nodesToDelete.forEach((id) => {
    delete newState.indexes.nodes[id];
  });
  return newState;
};
init_react_import();
var zoneCache = {};
function registerZoneAction(state, action) {
  if (zoneCache[action.zone]) {
    return __spreadProps(__spreadValues({}, state), {
      data: __spreadProps(__spreadValues({}, state.data), {
        zones: __spreadProps(__spreadValues({}, state.data.zones), {
          [action.zone]: zoneCache[action.zone]
        })
      }),
      indexes: __spreadProps(__spreadValues({}, state.indexes), {
        zones: __spreadProps(__spreadValues({}, state.indexes.zones), {
          [action.zone]: __spreadProps(__spreadValues({}, state.indexes.zones[action.zone]), {
            contentIds: zoneCache[action.zone].map((item) => item.props.id),
            type: "dropzone"
          })
        })
      })
    });
  }
  return __spreadProps(__spreadValues({}, state), { data: setupZone(state.data, action.zone) });
}
function unregisterZoneAction(state, action) {
  const _zones = __spreadValues({}, state.data.zones || {});
  const zoneIndex = __spreadValues({}, state.indexes.zones || {});
  if (_zones[action.zone]) {
    zoneCache[action.zone] = _zones[action.zone];
    delete _zones[action.zone];
  }
  delete zoneIndex[action.zone];
  return __spreadProps(__spreadValues({}, state), {
    data: __spreadProps(__spreadValues({}, state.data), {
      zones: _zones
    }),
    indexes: __spreadProps(__spreadValues({}, state.indexes), {
      zones: zoneIndex
    })
  });
}
init_react_import();
var setDataAction = (state, action, appStore) => {
  if (typeof action.data === "object") {
    console.warn(
      "`setData` is expensive and may cause unnecessary re-renders. Consider using a more atomic action instead."
    );
    return walkAppState(
      __spreadProps(__spreadValues({}, state), {
        data: __spreadValues(__spreadValues({}, state.data), action.data)
      }),
      appStore.config
    );
  }
  return walkAppState(
    __spreadProps(__spreadValues({}, state), {
      data: __spreadValues(__spreadValues({}, state.data), action.data(state.data))
    }),
    appStore.config
  );
};
init_react_import();
var setUiAction = (state, action) => {
  if (typeof action.ui === "object") {
    return __spreadProps(__spreadValues({}, state), {
      ui: __spreadValues(__spreadValues({}, state.ui), action.ui)
    });
  }
  return __spreadProps(__spreadValues({}, state), {
    ui: __spreadValues(__spreadValues({}, state.ui), action.ui(state.ui))
  });
};
init_react_import();
var makeStatePublic = (state) => {
  const { data, ui } = state;
  return { data, ui };
};
init_react_import();
function storeInterceptor(reducer, record, onAction) {
  return (state, action) => {
    const newAppState = reducer(state, action);
    const isValidType = ![
      "registerZone",
      "unregisterZone",
      "setData",
      "setUi",
      "set"
    ].includes(action.type);
    if (typeof action.recordHistory !== "undefined" ? action.recordHistory : isValidType) {
      if (record)
        record(newAppState);
    }
    onAction == null ? void 0 : onAction(action, makeStatePublic(newAppState), makeStatePublic(state));
    return newAppState;
  };
}
function createReducer({
  record,
  onAction,
  appStore
}) {
  return storeInterceptor(
    (state, action) => {
      if (action.type === "set") {
        return setAction(state, action, appStore);
      }
      if (action.type === "insert") {
        return insertAction(state, action, appStore);
      }
      if (action.type === "replace") {
        return replaceAction(state, action, appStore);
      }
      if (action.type === "replaceRoot") {
        return replaceRootAction(state, action, appStore);
      }
      if (action.type === "duplicate") {
        return duplicateAction(state, action, appStore);
      }
      if (action.type === "reorder") {
        return reorderAction(state, action, appStore);
      }
      if (action.type === "move") {
        return moveAction(state, action, appStore);
      }
      if (action.type === "remove") {
        return removeAction(state, action, appStore);
      }
      if (action.type === "registerZone") {
        return registerZoneAction(state, action);
      }
      if (action.type === "unregisterZone") {
        return unregisterZoneAction(state, action);
      }
      if (action.type === "setData") {
        return setDataAction(state, action, appStore);
      }
      if (action.type === "setUi") {
        return setUiAction(state, action);
      }
      return state;
    },
    record,
    onAction
  );
}
init_react_import();
init_react_import();
var keyCodeMap = {
  ControlLeft: "ctrl",
  ControlRight: "ctrl",
  MetaLeft: "meta",
  MetaRight: "meta",
  ShiftLeft: "shift",
  ShiftRight: "shift",
  KeyA: "a",
  KeyB: "b",
  KeyC: "c",
  KeyD: "d",
  KeyE: "e",
  KeyF: "f",
  KeyG: "g",
  KeyH: "h",
  KeyI: "i",
  KeyJ: "j",
  KeyK: "k",
  KeyL: "l",
  KeyM: "m",
  KeyN: "n",
  KeyO: "o",
  KeyP: "p",
  KeyQ: "q",
  KeyR: "r",
  KeyS: "s",
  KeyT: "t",
  KeyU: "u",
  KeyV: "v",
  KeyW: "w",
  KeyX: "x",
  KeyY: "y",
  KeyZ: "z"
};
var useHotkeyStore = create()(
  subscribeWithSelector((set) => ({
    held: {},
    hold: (key) => set((s2) => s2.held[key] ? s2 : { held: __spreadProps(__spreadValues({}, s2.held), { [key]: true }) }),
    release: (key) => set((s2) => s2.held[key] ? { held: __spreadProps(__spreadValues({}, s2.held), { [key]: false }) } : s2),
    reset: (held = {}) => set(() => ({ held })),
    triggers: {}
  }))
);
var monitorHotkeys = (doc) => {
  const onKeyDown = (e3) => {
    const key = keyCodeMap[e3.code];
    if (key) {
      useHotkeyStore.getState().hold(key);
      const { held, triggers } = useHotkeyStore.getState();
      Object.values(triggers).forEach(({ combo, cb }) => {
        const conditionMet = Object.entries(combo).every(
          ([key2, value]) => value === !!held[key2]
        ) && Object.entries(held).every(
          ([key2, value]) => value === !!combo[key2]
        );
        if (conditionMet) {
          e3.preventDefault();
          cb();
        }
      });
      if (key !== "meta" && key !== "ctrl" && key !== "shift") {
        useHotkeyStore.getState().release(key);
      }
    }
  };
  const onKeyUp = (e3) => {
    const key = keyCodeMap[e3.code];
    if (key) {
      if (key === "meta") {
        useHotkeyStore.getState().reset();
      } else {
        useHotkeyStore.getState().release(key);
      }
    }
  };
  const onVisibilityChanged = (e3) => {
    if (document.visibilityState === "hidden") {
      useHotkeyStore.getState().reset();
    }
  };
  doc.addEventListener("keydown", onKeyDown);
  doc.addEventListener("keyup", onKeyUp);
  doc.addEventListener("visibilitychange", onVisibilityChanged);
  return () => {
    doc.removeEventListener("keydown", onKeyDown);
    doc.removeEventListener("keyup", onKeyUp);
    doc.removeEventListener("visibilitychange", onVisibilityChanged);
  };
};
var useMonitorHotkeys = () => {
  (0, import_react14.useEffect)(() => monitorHotkeys(document), []);
};
var useHotkey = (combo, cb) => {
  (0, import_react14.useEffect)(
    () => useHotkeyStore.setState((s2) => ({
      triggers: __spreadProps(__spreadValues({}, s2.triggers), {
        [`${Object.keys(combo).join("+")}`]: { combo, cb }
      })
    })),
    []
  );
};
var EMPTY_HISTORY_INDEX = 0;
function debounce2(func, timeout3 = 300) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func(...args);
    }, timeout3);
  };
}
var tidyState = (state) => {
  return __spreadProps(__spreadValues({}, state), {
    ui: __spreadProps(__spreadValues({}, state.ui), {
      field: {
        focus: null
      }
    })
  });
};
var createHistorySlice = (set, get) => {
  const record = debounce2((state) => {
    const { histories, index } = get().history;
    const history = {
      state,
      id: generateId("history")
    };
    const newHistories = [...histories.slice(0, index + 1), history];
    set({
      history: __spreadProps(__spreadValues({}, get().history), {
        histories: newHistories,
        index: newHistories.length - 1
      })
    });
  }, 250);
  return {
    initialAppState: {},
    index: EMPTY_HISTORY_INDEX,
    histories: [],
    hasPast: () => get().history.index > EMPTY_HISTORY_INDEX,
    hasFuture: () => get().history.index < get().history.histories.length - 1,
    prevHistory: () => {
      const { history } = get();
      return history.hasPast() ? history.histories[history.index - 1] : null;
    },
    nextHistory: () => {
      const s2 = get().history;
      return s2.hasFuture() ? s2.histories[s2.index + 1] : null;
    },
    currentHistory: () => get().history.histories[get().history.index],
    back: () => {
      var _a5;
      const { history, dispatch } = get();
      if (history.hasPast()) {
        const state = tidyState(
          ((_a5 = history.prevHistory()) == null ? void 0 : _a5.state) || history.initialAppState
        );
        dispatch({
          type: "set",
          state
        });
        set({ history: __spreadProps(__spreadValues({}, history), { index: history.index - 1 }) });
      }
    },
    forward: () => {
      var _a5;
      const { history, dispatch } = get();
      if (history.hasFuture()) {
        const state = (_a5 = history.nextHistory()) == null ? void 0 : _a5.state;
        dispatch({ type: "set", state: state ? tidyState(state) : {} });
        set({ history: __spreadProps(__spreadValues({}, history), { index: history.index + 1 }) });
      }
    },
    setHistories: (histories) => {
      var _a5;
      const { dispatch, history } = get();
      dispatch({
        type: "set",
        state: ((_a5 = histories[histories.length - 1]) == null ? void 0 : _a5.state) || history.initialAppState
      });
      set({ history: __spreadProps(__spreadValues({}, history), { histories, index: histories.length - 1 }) });
    },
    setHistoryIndex: (index) => {
      var _a5;
      const { dispatch, history } = get();
      dispatch({
        type: "set",
        state: ((_a5 = history.histories[index]) == null ? void 0 : _a5.state) || history.initialAppState
      });
      set({ history: __spreadProps(__spreadValues({}, history), { index }) });
    },
    record
  };
};
function useRegisterHistorySlice(appStore, {
  histories,
  index,
  initialAppState
}) {
  (0, import_react13.useEffect)(
    () => appStore.setState({
      history: __spreadProps(__spreadValues({}, appStore.getState().history), {
        histories,
        index,
        initialAppState
      })
    }),
    [histories, index, initialAppState]
  );
  const back = () => {
    appStore.getState().history.back();
  };
  const forward = () => {
    appStore.getState().history.forward();
  };
  useHotkey({ meta: true, z: true }, back);
  useHotkey({ meta: true, shift: true, z: true }, forward);
  useHotkey({ meta: true, y: true }, forward);
  useHotkey({ ctrl: true, z: true }, back);
  useHotkey({ ctrl: true, shift: true, z: true }, forward);
  useHotkey({ ctrl: true, y: true }, forward);
}
init_react_import();
var createNodesSlice = (set, get) => ({
  nodes: {},
  registerNode: (id, node) => {
    const s2 = get().nodes;
    const emptyNode = {
      id,
      methods: {
        sync: () => null,
        hideOverlay: () => null,
        showOverlay: () => null
      },
      element: null
    };
    const existingNode = s2.nodes[id];
    set({
      nodes: __spreadProps(__spreadValues({}, s2), {
        nodes: __spreadProps(__spreadValues({}, s2.nodes), {
          [id]: __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, emptyNode), existingNode), node), {
            id
          })
        })
      })
    });
  },
  unregisterNode: (id) => {
    const s2 = get().nodes;
    const existingNode = s2.nodes[id];
    if (existingNode) {
      const newNodes = __spreadValues({}, s2.nodes);
      delete newNodes[id];
      set({
        nodes: __spreadProps(__spreadValues({}, s2), {
          nodes: newNodes
        })
      });
    }
  }
});
init_react_import();
init_react_import();
var flattenData = (state, config) => {
  const data = [];
  walkAppState(
    state,
    config,
    (content) => content,
    (item) => {
      data.push(item);
      return null;
    }
  );
  return data;
};
var createPermissionsSlice = (set, get) => {
  const resolvePermissions = (..._0) => __async(void 0, [..._0], function* (params = {}, force) {
    const { state, permissions, config } = get();
    const { cache: cache2, globalPermissions } = permissions;
    const resolveDataForItem = (item2, force2 = false) => __async(void 0, null, function* () {
      var _a5, _b3, _c4;
      const { config: config2, state: appState, setComponentLoading } = get();
      const componentConfig = item2.type === "root" ? config2.root : config2.components[item2.type];
      if (!componentConfig) {
        return;
      }
      const initialPermissions = __spreadValues(__spreadValues({}, globalPermissions), componentConfig.permissions);
      if (componentConfig.resolvePermissions) {
        const changed = getChanged(item2, (_a5 = cache2[item2.props.id]) == null ? void 0 : _a5.lastData);
        if (Object.values(changed).some((el) => el === true) || force2) {
          const clearTimeout2 = setComponentLoading(item2.props.id, true, 50);
          const resolvedPermissions = yield componentConfig.resolvePermissions(
            item2,
            {
              changed,
              lastPermissions: ((_b3 = cache2[item2.props.id]) == null ? void 0 : _b3.lastPermissions) || null,
              permissions: initialPermissions,
              appState: makeStatePublic(appState),
              lastData: ((_c4 = cache2[item2.props.id]) == null ? void 0 : _c4.lastData) || null
            }
          );
          const latest = get().permissions;
          set({
            permissions: __spreadProps(__spreadValues({}, latest), {
              cache: __spreadProps(__spreadValues({}, latest.cache), {
                [item2.props.id]: {
                  lastData: item2,
                  lastPermissions: resolvedPermissions
                }
              }),
              resolvedPermissions: __spreadProps(__spreadValues({}, latest.resolvedPermissions), {
                [item2.props.id]: resolvedPermissions
              })
            })
          });
          clearTimeout2();
        }
      }
    });
    const resolveDataForRoot = (force2 = false) => {
      const { state: appState } = get();
      resolveDataForItem(
        // Shim the root data in by conforming to component data shape
        {
          type: "root",
          props: __spreadProps(__spreadValues({}, appState.data.root.props), { id: "root" })
        },
        force2
      );
    };
    const { item, type, root } = params;
    if (item) {
      yield resolveDataForItem(item, force);
    } else if (type) {
      flattenData(state, config).filter((item2) => item2.type === type).map((item2) => __async(void 0, null, function* () {
        yield resolveDataForItem(item2, force);
      }));
    } else if (root) {
      resolveDataForRoot(force);
    } else {
      flattenData(state, config).map((item2) => __async(void 0, null, function* () {
        yield resolveDataForItem(item2, force);
      }));
    }
  });
  const refreshPermissions = (params) => resolvePermissions(params, true);
  return {
    cache: {},
    globalPermissions: {
      drag: true,
      edit: true,
      delete: true,
      duplicate: true,
      insert: true
    },
    resolvedPermissions: {},
    getPermissions: ({ item, type, root } = {}) => {
      const { config, permissions } = get();
      const { globalPermissions, resolvedPermissions } = permissions;
      if (item) {
        const componentConfig = config.components[item.type];
        const initialPermissions = __spreadValues(__spreadValues({}, globalPermissions), componentConfig == null ? void 0 : componentConfig.permissions);
        const resolvedForItem = resolvedPermissions[item.props.id];
        return resolvedForItem ? __spreadValues(__spreadValues({}, globalPermissions), resolvedForItem) : initialPermissions;
      } else if (type) {
        const componentConfig = config.components[type];
        return __spreadValues(__spreadValues({}, globalPermissions), componentConfig == null ? void 0 : componentConfig.permissions);
      } else if (root) {
        const rootConfig = config.root;
        const initialPermissions = __spreadValues(__spreadValues({}, globalPermissions), rootConfig == null ? void 0 : rootConfig.permissions);
        const resolvedForItem = resolvedPermissions["root"];
        return resolvedForItem ? __spreadValues(__spreadValues({}, globalPermissions), resolvedForItem) : initialPermissions;
      }
      return globalPermissions;
    },
    resolvePermissions,
    refreshPermissions
  };
};
var useRegisterPermissionsSlice = (appStore, globalPermissions) => {
  (0, import_react15.useEffect)(() => {
    const { permissions } = appStore.getState();
    const { globalPermissions: existingGlobalPermissions } = permissions;
    appStore.setState({
      permissions: __spreadProps(__spreadValues({}, permissions), {
        globalPermissions: __spreadValues(__spreadValues({}, existingGlobalPermissions), globalPermissions)
      })
    });
    permissions.resolvePermissions();
  }, [globalPermissions]);
  (0, import_react15.useEffect)(() => {
    return appStore.subscribe(
      (s2) => s2.state.data,
      () => {
        appStore.getState().permissions.resolvePermissions();
      }
    );
  }, []);
  (0, import_react15.useEffect)(() => {
    return appStore.subscribe(
      (s2) => s2.config,
      () => {
        appStore.getState().permissions.resolvePermissions();
      }
    );
  }, []);
};
init_react_import();
var createFieldsSlice = (_set, _get) => {
  return {
    fields: {},
    loading: false,
    lastResolvedData: {},
    id: void 0
  };
};
var useRegisterFieldsSlice = (appStore, id) => {
  const resolveFields = (0, import_react16.useCallback)(
    (reset) => __async(void 0, null, function* () {
      var _a5, _b3;
      const { fields, lastResolvedData } = appStore.getState().fields;
      const nodes = appStore.getState().state.indexes.nodes;
      const node = nodes[id || "root"];
      const componentData = node == null ? void 0 : node.data;
      const parentNode = (node == null ? void 0 : node.parentId) ? nodes[node.parentId] : null;
      const parent = (parentNode == null ? void 0 : parentNode.data) || null;
      const { getComponentConfig, state } = appStore.getState();
      const componentConfig = getComponentConfig(componentData == null ? void 0 : componentData.type);
      if (!componentData || !componentConfig)
        return;
      const defaultFields2 = componentConfig.fields || {};
      const resolver = componentConfig.resolveFields;
      let lastFields = fields;
      if (reset) {
        appStore.setState((s2) => ({
          fields: __spreadProps(__spreadValues({}, s2.fields), { fields: defaultFields2, id })
        }));
        lastFields = defaultFields2;
      }
      if (resolver) {
        const timeout3 = setTimeout(() => {
          appStore.setState((s2) => ({
            fields: __spreadProps(__spreadValues({}, s2.fields), { loading: true })
          }));
        }, 50);
        const lastData = ((_a5 = lastResolvedData.props) == null ? void 0 : _a5.id) === id ? lastResolvedData : null;
        const changed = getChanged(componentData, lastData);
        const newFields = yield resolver(componentData, {
          changed,
          fields: defaultFields2,
          lastFields,
          lastData,
          appState: makeStatePublic(state),
          parent
        });
        clearTimeout(timeout3);
        if (((_b3 = appStore.getState().selectedItem) == null ? void 0 : _b3.props.id) !== id) {
          return;
        }
        appStore.setState({
          fields: {
            fields: newFields,
            loading: false,
            lastResolvedData: componentData,
            id
          }
        });
      } else {
        appStore.setState((s2) => ({
          fields: __spreadProps(__spreadValues({}, s2.fields), { fields: defaultFields2, id })
        }));
      }
    }),
    [id]
  );
  (0, import_react16.useEffect)(() => {
    resolveFields(true);
    return appStore.subscribe(
      (s2) => s2.state.indexes.nodes[id || "root"],
      () => resolveFields()
    );
  }, [id]);
};
init_react_import();
var toRoot = (item) => {
  if ("type" in item && item.type !== "root") {
    throw new Error("Converting non-root item to root.");
  }
  const { readOnly } = item;
  if (item.props) {
    if ("id" in item.props) {
      const _a5 = item.props, { id } = _a5, props = __objRest(_a5, ["id"]);
      return { props, readOnly };
    }
    return { props: item.props, readOnly };
  }
  return { props: {}, readOnly };
};
var defaultPageFields = {
  title: { type: "text" }
};
var createAppStore = (initialAppStore) => create()(
  subscribeWithSelector((set, get) => {
    var _a5, _b3;
    return __spreadProps(__spreadValues({
      state: defaultAppState,
      config: { components: {} },
      componentState: {},
      plugins: [],
      overrides: {},
      viewports: defaultViewports,
      zoomConfig: {
        autoZoom: 1,
        rootHeight: 0,
        zoom: 1
      },
      status: "LOADING",
      iframe: {},
      metadata: {},
      fieldTransforms: {}
    }, initialAppStore), {
      fields: createFieldsSlice(set, get),
      history: createHistorySlice(set, get),
      nodes: createNodesSlice(set, get),
      permissions: createPermissionsSlice(set, get),
      getComponentConfig: (type) => {
        var _a23;
        const { config, selectedItem } = get();
        const rootFields = ((_a23 = config.root) == null ? void 0 : _a23.fields) || defaultPageFields;
        return type && type !== "root" ? config.components[type] : selectedItem ? config.components[selectedItem.type] : __spreadProps(__spreadValues({}, config.root), { fields: rootFields });
      },
      selectedItem: ((_a5 = initialAppStore == null ? void 0 : initialAppStore.state) == null ? void 0 : _a5.ui.itemSelector) ? getItem(
        (_b3 = initialAppStore == null ? void 0 : initialAppStore.state) == null ? void 0 : _b3.ui.itemSelector,
        initialAppStore.state
      ) : null,
      dispatch: (action) => set((s2) => {
        var _a23, _b22;
        const { record } = get().history;
        const dispatch = createReducer({
          record,
          appStore: s2
        });
        const state = dispatch(s2.state, action);
        const selectedItem = state.ui.itemSelector ? getItem(state.ui.itemSelector, state) : null;
        (_b22 = (_a23 = get()).onAction) == null ? void 0 : _b22.call(_a23, action, state, get().state);
        return __spreadProps(__spreadValues({}, s2), { state, selectedItem });
      }),
      setZoomConfig: (zoomConfig) => set({ zoomConfig }),
      setStatus: (status) => set({ status }),
      setComponentState: (componentState) => set({ componentState }),
      pendingLoadTimeouts: {},
      setComponentLoading: (id, loading = true, defer2 = 0) => {
        const { setComponentState, pendingLoadTimeouts } = get();
        const loadId = generateId();
        const setLoading = () => {
          var _a23;
          const { componentState } = get();
          setComponentState(__spreadProps(__spreadValues({}, componentState), {
            [id]: __spreadProps(__spreadValues({}, componentState[id]), {
              loadingCount: (((_a23 = componentState[id]) == null ? void 0 : _a23.loadingCount) || 0) + 1
            })
          }));
        };
        const unsetLoading = () => {
          var _a23;
          const { componentState } = get();
          clearTimeout(timeout3);
          delete pendingLoadTimeouts[loadId];
          set({ pendingLoadTimeouts });
          setComponentState(__spreadProps(__spreadValues({}, componentState), {
            [id]: __spreadProps(__spreadValues({}, componentState[id]), {
              loadingCount: Math.max(
                (((_a23 = componentState[id]) == null ? void 0 : _a23.loadingCount) || 0) - 1,
                0
              )
            })
          }));
        };
        const timeout3 = setTimeout(() => {
          if (loading) {
            setLoading();
          } else {
            unsetLoading();
          }
          delete pendingLoadTimeouts[loadId];
          set({ pendingLoadTimeouts });
        }, defer2);
        set({
          pendingLoadTimeouts: __spreadProps(__spreadValues({}, pendingLoadTimeouts), {
            [id]: timeout3
          })
        });
        return unsetLoading;
      },
      unsetComponentLoading: (id) => {
        const { setComponentLoading } = get();
        setComponentLoading(id, false);
      },
      // Helper
      setUi: (ui, recordHistory) => set((s2) => {
        const dispatch = createReducer({
          record: () => {
          },
          appStore: s2
        });
        const state = dispatch(s2.state, {
          type: "setUi",
          ui,
          recordHistory
        });
        const selectedItem = state.ui.itemSelector ? getItem(state.ui.itemSelector, state) : null;
        return __spreadProps(__spreadValues({}, s2), { state, selectedItem });
      }),
      resolveComponentData: (componentData, trigger) => __async(void 0, null, function* () {
        const { config, metadata, setComponentLoading, permissions } = get();
        const timeouts = {};
        return yield resolveComponentData(
          componentData,
          config,
          metadata,
          (item) => {
            const id = "id" in item.props ? item.props.id : "root";
            timeouts[id] = setComponentLoading(id, true, 50);
          },
          (item) => __async(void 0, null, function* () {
            const id = "id" in item.props ? item.props.id : "root";
            if ("type" in item) {
              yield permissions.refreshPermissions({ item });
            } else {
              yield permissions.refreshPermissions({ root: true });
            }
            timeouts[id]();
          }),
          trigger
        );
      }),
      resolveAndCommitData: () => __async(void 0, null, function* () {
        const { config, state, dispatch, resolveComponentData: resolveComponentData2 } = get();
        walkAppState(
          state,
          config,
          (content) => content,
          (childItem) => {
            resolveComponentData2(childItem, "load").then((resolved) => {
              const { state: state2 } = get();
              const node = state2.indexes.nodes[resolved.node.props.id];
              if (node && resolved.didChange) {
                if (resolved.node.props.id === "root") {
                  dispatch({
                    type: "replaceRoot",
                    root: toRoot(resolved.node)
                  });
                } else {
                  const zoneCompound = `${node.parentId}:${node.zone}`;
                  const parentZone = state2.indexes.zones[zoneCompound];
                  const index = parentZone.contentIds.indexOf(
                    resolved.node.props.id
                  );
                  dispatch({
                    type: "replace",
                    data: resolved.node,
                    destinationIndex: index,
                    destinationZone: zoneCompound
                  });
                }
              }
            });
            return childItem;
          }
        );
      })
    });
  })
);
var appStoreContext = (0, import_react12.createContext)(createAppStore());
function useAppStore(selector) {
  const context = (0, import_react12.useContext)(appStoreContext);
  return useStore(context, selector);
}
function useAppStoreApi() {
  return (0, import_react12.useContext)(appStoreContext);
}
init_react_import();
init_react_import();
init_react_import();
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}
var getRect = function getRect2(_ref) {
  var top = _ref.top, right = _ref.right, bottom = _ref.bottom, left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top,
    right,
    bottom,
    left,
    width,
    height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse2 = function parse22(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);
  if (suffix !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? true ? invariant(false, "Could not parse value [raw: " + raw + ", without suffix: " + value + "]") : invariant(false) : void 0;
  return result;
};
var calculateBox = function calculateBox2(borderBox, styles2) {
  var margin = {
    top: parse2(styles2.marginTop),
    right: parse2(styles2.marginRight),
    bottom: parse2(styles2.marginBottom),
    left: parse2(styles2.marginLeft)
  };
  var padding = {
    top: parse2(styles2.paddingTop),
    right: parse2(styles2.paddingRight),
    bottom: parse2(styles2.paddingBottom),
    left: parse2(styles2.paddingLeft)
  };
  var border = {
    top: parse2(styles2.borderTopWidth),
    right: parse2(styles2.borderRightWidth),
    bottom: parse2(styles2.borderBottomWidth),
    left: parse2(styles2.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el) {
  var borderBox = el.getBoundingClientRect();
  var styles2 = window.getComputedStyle(el);
  return calculateBox(borderBox, styles2);
};
var RESET_ZOOM_SMALLER_THAN_FRAME = true;
var getZoomConfig = (uiViewport, frame, zoom) => {
  const box = getBox(frame);
  const { width: frameWidth, height: frameHeight } = box.contentBox;
  const viewportHeight = uiViewport.height === "auto" ? frameHeight : uiViewport.height;
  let rootHeight = 0;
  let autoZoom = 1;
  if (uiViewport.width > frameWidth || viewportHeight > frameHeight) {
    const widthZoom = Math.min(frameWidth / uiViewport.width, 1);
    const heightZoom = Math.min(frameHeight / viewportHeight, 1);
    zoom = widthZoom;
    if (widthZoom < heightZoom) {
      rootHeight = viewportHeight / zoom;
    } else {
      rootHeight = viewportHeight;
      zoom = heightZoom;
    }
    autoZoom = zoom;
  } else {
    if (RESET_ZOOM_SMALLER_THAN_FRAME) {
      autoZoom = 1;
      zoom = 1;
      rootHeight = viewportHeight;
    }
  }
  return { autoZoom, rootHeight, zoom };
};
var useResetAutoZoom = (frameRef) => {
  const appStoreApi = useAppStoreApi();
  const resetAutoZoom = (options2) => {
    const { state, zoomConfig, setZoomConfig } = appStoreApi.getState();
    const { viewports } = state.ui;
    const newViewports = (options2 == null ? void 0 : options2.viewports) || viewports;
    if (frameRef.current) {
      setZoomConfig(
        getZoomConfig(newViewports == null ? void 0 : newViewports.current, frameRef.current, zoomConfig.zoom)
      );
    }
  };
  return resetAutoZoom;
};
init_react_import();
var styles_module_default2 = { "Loader": "_Loader_nacdm_13", "loader-animation": "_loader-animation_nacdm_1" };
var getClassName2 = get_class_name_factory_default("Loader", styles_module_default2);
var Loader = (_a5) => {
  var _b3 = _a5, {
    color,
    size = 16
  } = _b3, props = __objRest(_b3, [
    "color",
    "size"
  ]);
  return (0, import_jsx_runtime4.jsx)(
    "span",
    __spreadValues({
      className: getClassName2(),
      style: {
        width: size,
        height: size,
        color
      },
      "aria-label": "loading"
    }, props)
  );
};
var getClassName3 = get_class_name_factory_default("IconButton", IconButton_module_default);
var IconButton = ({
  children,
  href,
  onClick,
  variant = "primary",
  type,
  disabled,
  tabIndex,
  newTab,
  fullWidth,
  title
}) => {
  const [loading, setLoading] = (0, import_react11.useState)(false);
  const ElementType = href ? "a" : "button";
  const el = (0, import_jsx_runtime5.jsxs)(
    ElementType,
    {
      className: getClassName3({
        primary: variant === "primary",
        secondary: variant === "secondary",
        disabled,
        fullWidth
      }),
      onClick: (e3) => {
        if (!onClick)
          return;
        setLoading(true);
        Promise.resolve(onClick(e3)).then(() => {
          setLoading(false);
        });
      },
      type,
      disabled: disabled || loading,
      tabIndex,
      target: newTab ? "_blank" : void 0,
      rel: newTab ? "noreferrer" : void 0,
      href,
      title,
      children: [
        (0, import_jsx_runtime5.jsx)("span", { className: getClassName3("title"), children: title }),
        children,
        loading && (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
          "  ",
          (0, import_jsx_runtime5.jsx)(Loader, { size: 14 })
        ] })
      ]
    }
  );
  return el;
};
init_react_import();
init_react_import();
var Button_module_default = { "Button": "_Button_10byl_1", "Button--medium": "_Button--medium_10byl_29", "Button--large": "_Button--large_10byl_37", "Button-icon": "_Button-icon_10byl_44", "Button--primary": "_Button--primary_10byl_48", "Button--secondary": "_Button--secondary_10byl_67", "Button--flush": "_Button--flush_10byl_84", "Button--disabled": "_Button--disabled_10byl_88", "Button--fullWidth": "_Button--fullWidth_10byl_95", "Button-spinner": "_Button-spinner_10byl_100" };
init_react_import();
var dataAttrRe = /^(data-.*)$/;
var filterDataAttrs = (props) => {
  let filteredProps = {};
  for (const prop in props) {
    if (Object.prototype.hasOwnProperty.call(props, prop) && dataAttrRe.test(prop)) {
      filteredProps[prop] = props[prop];
    }
  }
  return filteredProps;
};
var getClassName4 = get_class_name_factory_default("Button", Button_module_default);
var Button = (_a5) => {
  var _b3 = _a5, {
    children,
    href,
    onClick,
    variant = "primary",
    type,
    disabled,
    tabIndex,
    newTab,
    fullWidth,
    icon,
    size = "medium",
    loading: loadingProp = false
  } = _b3, props = __objRest(_b3, [
    "children",
    "href",
    "onClick",
    "variant",
    "type",
    "disabled",
    "tabIndex",
    "newTab",
    "fullWidth",
    "icon",
    "size",
    "loading"
  ]);
  const [loading, setLoading] = (0, import_react17.useState)(loadingProp);
  (0, import_react17.useEffect)(() => setLoading(loadingProp), [loadingProp]);
  const ElementType = href ? "a" : type ? "button" : "span";
  const dataAttrs = filterDataAttrs(props);
  const el = (0, import_jsx_runtime6.jsxs)(
    ElementType,
    __spreadProps(__spreadValues({
      className: getClassName4({
        primary: variant === "primary",
        secondary: variant === "secondary",
        disabled,
        fullWidth,
        [size]: true
      }),
      onClick: (e3) => {
        if (!onClick)
          return;
        setLoading(true);
        Promise.resolve(onClick(e3)).then(() => {
          setLoading(false);
        });
      },
      type,
      disabled: disabled || loading,
      tabIndex,
      target: newTab ? "_blank" : void 0,
      rel: newTab ? "noreferrer" : void 0,
      href
    }, dataAttrs), {
      children: [
        icon && (0, import_jsx_runtime6.jsx)("div", { className: getClassName4("icon"), children: icon }),
        children,
        loading && (0, import_jsx_runtime6.jsx)("div", { className: getClassName4("spinner"), children: (0, import_jsx_runtime6.jsx)(Loader, { size: 14 }) })
      ]
    })
  );
  return el;
};
init_react_import();
init_react_import();
var styles_module_default3 = { "InputWrapper": "_InputWrapper_bsxfo_1", "Input-label": "_Input-label_bsxfo_5", "Input-labelIcon": "_Input-labelIcon_bsxfo_14", "Input-disabledIcon": "_Input-disabledIcon_bsxfo_21", "Input-input": "_Input-input_bsxfo_26", "Input": "_Input_bsxfo_1", "Input--readOnly": "_Input--readOnly_bsxfo_82", "Input-radioGroupItems": "_Input-radioGroupItems_bsxfo_93", "Input-radio": "_Input-radio_bsxfo_93", "Input-radioInner": "_Input-radioInner_bsxfo_110", "Input-radioInput": "_Input-radioInput_bsxfo_155" };
init_react_import();
init_react_import();
init_react_import();
var styles_module_default4 = { "ArrayField": "_ArrayField_14u8o_5", "ArrayField--isDraggingFrom": "_ArrayField--isDraggingFrom_14u8o_13", "ArrayField-addButton": "_ArrayField-addButton_14u8o_18", "ArrayField--hasItems": "_ArrayField--hasItems_14u8o_33", "ArrayField-inner": "_ArrayField-inner_14u8o_59", "ArrayFieldItem": "_ArrayFieldItem_14u8o_67", "ArrayFieldItem--isDragging": "_ArrayFieldItem--isDragging_14u8o_78", "ArrayFieldItem--isExpanded": "_ArrayFieldItem--isExpanded_14u8o_82", "ArrayFieldItem-summary": "_ArrayFieldItem-summary_14u8o_97", "ArrayField--addDisabled": "_ArrayField--addDisabled_14u8o_127", "ArrayFieldItem-body": "_ArrayFieldItem-body_14u8o_166", "ArrayFieldItem-fieldset": "_ArrayFieldItem-fieldset_14u8o_175", "ArrayFieldItem-rhs": "_ArrayFieldItem-rhs_14u8o_183", "ArrayFieldItem-actions": "_ArrayFieldItem-actions_14u8o_189" };
init_react_import();
init_react_import();
init_react_import();
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var mergeClasses = (...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();
init_react_import();
init_react_import();
var defaultAttributes2 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
var Icon = (0, import_react20.forwardRef)(
  (_a5, ref) => {
    var _b3 = _a5, {
      color = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      iconNode
    } = _b3, rest = __objRest(_b3, [
      "color",
      "size",
      "strokeWidth",
      "absoluteStrokeWidth",
      "className",
      "children",
      "iconNode"
    ]);
    return (0, import_react20.createElement)(
      "svg",
      __spreadValues(__spreadProps(__spreadValues({
        ref
      }, defaultAttributes2), {
        width: size,
        height: size,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className)
      }), rest),
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react20.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
var createLucideIcon = (iconName, iconNode) => {
  const Component = (0, import_react19.forwardRef)(
    (_a5, ref) => {
      var _b3 = _a5, { className } = _b3, props = __objRest(_b3, ["className"]);
      return (0, import_react19.createElement)(Icon, __spreadValues({
        ref,
        iconNode,
        className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className)
      }, props));
    }
  );
  Component.displayName = `${iconName}`;
  return Component;
};
init_react_import();
var ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
init_react_import();
var ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
init_react_import();
var ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
init_react_import();
var CircleCheckBig = createLucideIcon("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
init_react_import();
var Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
init_react_import();
var CornerLeftUp = createLucideIcon("CornerLeftUp", [
  ["polyline", { points: "14 9 9 4 4 9", key: "m9oyvo" }],
  ["path", { d: "M20 20h-7a4 4 0 0 1-4-4V4", key: "1blwi3" }]
]);
init_react_import();
var EllipsisVertical = createLucideIcon("EllipsisVertical", [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }],
  ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]
]);
init_react_import();
var Globe = createLucideIcon("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
init_react_import();
var Hash = createLucideIcon("Hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);
init_react_import();
var Layers = createLucideIcon("Layers", [
  [
    "path",
    {
      d: "M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",
      key: "zw3jo"
    }
  ],
  [
    "path",
    {
      d: "M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",
      key: "1wduqc"
    }
  ],
  [
    "path",
    {
      d: "M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",
      key: "kqbvx6"
    }
  ]
]);
init_react_import();
var LayoutGrid = createLucideIcon("LayoutGrid", [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
]);
init_react_import();
var Link = createLucideIcon("Link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
init_react_import();
var List = createLucideIcon("List", [
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 18h.01", key: "1tta3j" }],
  ["path", { d: "M3 6h.01", key: "1rqtza" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 18h13", key: "1lx6n3" }],
  ["path", { d: "M8 6h13", key: "ik3vkj" }]
]);
init_react_import();
var LockOpen = createLucideIcon("LockOpen", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 9.9-1", key: "1mm8w8" }]
]);
init_react_import();
var Lock = createLucideIcon("Lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
init_react_import();
var Monitor2 = createLucideIcon("Monitor", [
  ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" }],
  ["line", { x1: "8", x2: "16", y1: "21", y2: "21", key: "1svkeh" }],
  ["line", { x1: "12", x2: "12", y1: "17", y2: "21", key: "vw1qmm" }]
]);
init_react_import();
var PanelLeft = createLucideIcon("PanelLeft", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }]
]);
init_react_import();
var PanelRight = createLucideIcon("PanelRight", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }]
]);
init_react_import();
var Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
init_react_import();
var Redo2 = createLucideIcon("Redo2", [
  ["path", { d: "m15 14 5-5-5-5", key: "12vg1m" }],
  ["path", { d: "M20 9H9.5A5.5 5.5 0 0 0 4 14.5A5.5 5.5 0 0 0 9.5 20H13", key: "6uklza" }]
]);
init_react_import();
var Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
init_react_import();
var SlidersHorizontal = createLucideIcon("SlidersHorizontal", [
  ["line", { x1: "21", x2: "14", y1: "4", y2: "4", key: "obuewd" }],
  ["line", { x1: "10", x2: "3", y1: "4", y2: "4", key: "1q6298" }],
  ["line", { x1: "21", x2: "12", y1: "12", y2: "12", key: "1iu8h1" }],
  ["line", { x1: "8", x2: "3", y1: "12", y2: "12", key: "ntss68" }],
  ["line", { x1: "21", x2: "16", y1: "20", y2: "20", key: "14d8ph" }],
  ["line", { x1: "12", x2: "3", y1: "20", y2: "20", key: "m0wm8r" }],
  ["line", { x1: "14", x2: "14", y1: "2", y2: "6", key: "14e1ph" }],
  ["line", { x1: "8", x2: "8", y1: "10", y2: "14", key: "1i6ji0" }],
  ["line", { x1: "16", x2: "16", y1: "18", y2: "22", key: "1lctlv" }]
]);
init_react_import();
var Smartphone = createLucideIcon("Smartphone", [
  ["rect", { width: "14", height: "20", x: "5", y: "2", rx: "2", ry: "2", key: "1yt0o3" }],
  ["path", { d: "M12 18h.01", key: "mhygvu" }]
]);
init_react_import();
var Tablet = createLucideIcon("Tablet", [
  ["rect", { width: "16", height: "20", x: "4", y: "2", rx: "2", ry: "2", key: "76otgf" }],
  ["line", { x1: "12", x2: "12.01", y1: "18", y2: "18", key: "1dp563" }]
]);
init_react_import();
var Trash = createLucideIcon("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
init_react_import();
var Type = createLucideIcon("Type", [
  ["polyline", { points: "4 7 4 4 20 4 20 7", key: "1nosan" }],
  ["line", { x1: "9", x2: "15", y1: "20", y2: "20", key: "swin9y" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
init_react_import();
var Undo2 = createLucideIcon("Undo2", [
  ["path", { d: "M9 14 4 9l5-5", key: "102s5s" }],
  ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]
]);
init_react_import();
var ZoomIn = createLucideIcon("ZoomIn", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "11", x2: "11", y1: "8", y2: "14", key: "1vmskp" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
init_react_import();
var ZoomOut = createLucideIcon("ZoomOut", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["line", { x1: "21", x2: "16.65", y1: "21", y2: "16.65", key: "13gj7c" }],
  ["line", { x1: "8", x2: "14", y1: "11", y2: "11", key: "durymu" }]
]);
init_react_import();
init_react_import();
init_react_import();
var styles_module_default5 = { "DragIcon": "_DragIcon_17p8x_1", "DragIcon--disabled": "_DragIcon--disabled_17p8x_8" };
var getClassName5 = get_class_name_factory_default("DragIcon", styles_module_default5);
var DragIcon = ({ isDragDisabled }) => (0, import_jsx_runtime7.jsx)("div", { className: getClassName5({ disabled: isDragDisabled }), children: (0, import_jsx_runtime7.jsx)("svg", { viewBox: "0 0 20 20", width: "12", fill: "currentColor", children: (0, import_jsx_runtime7.jsx)("path", { d: "M7 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 2zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 7 14zm6-8a2 2 0 1 0-.001-4.001A2 2 0 0 0 13 6zm0 2a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 8zm0 6a2 2 0 1 0 .001 4.001A2 2 0 0 0 13 14z" }) }) });
init_react_import();
init_react_import();
var touchDefault = { delay: { value: 200, tolerance: 10 } };
var otherDefault = {
  delay: { value: 200, tolerance: 10 },
  distance: { value: 5 }
};
var useSensors = ({
  other = otherDefault,
  mouse,
  touch = touchDefault
} = {
  touch: touchDefault,
  other: otherDefault
}) => {
  const [sensors] = (0, import_react23.useState)(() => [
    PointerSensor.configure({
      activationConstraints(event, source) {
        var _a5;
        const { pointerType, target } = event;
        if (pointerType === "mouse" && isElement(target) && (source.handle === target || ((_a5 = source.handle) == null ? void 0 : _a5.contains(target)))) {
          return mouse;
        }
        if (pointerType === "touch") {
          return touch;
        }
        return other;
      }
    })
  ]);
  return sensors;
};
init_react_import();
init_react_import();
init_react_import();
var DEBUG = false;
var debugElements = {};
var timeout2;
var collisionDebug = (a2, b2, id, color, label) => {
  if (!DEBUG)
    return;
  const debugId = `${id}-debug`;
  clearTimeout(timeout2);
  timeout2 = setTimeout(() => {
    Object.entries(debugElements).forEach(([id2, { svg }]) => {
      svg.remove();
      delete debugElements[id2];
    });
  }, 1e3);
  requestAnimationFrame(() => {
    var _a5, _b3;
    const existingEl = debugElements[debugId];
    let line = (_a5 = debugElements[debugId]) == null ? void 0 : _a5.line;
    let text = (_b3 = debugElements[debugId]) == null ? void 0 : _b3.text;
    if (!existingEl) {
      const svgNs = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNs, "svg");
      line = document.createElementNS(svgNs, "line");
      text = document.createElementNS(svgNs, "text");
      svg.setAttribute("id", debugId);
      svg.setAttribute(
        "style",
        "position: fixed; height: 100%; width: 100%; pointer-events: none; top: 0px; left: 0px;"
      );
      svg.appendChild(line);
      svg.appendChild(text);
      text.setAttribute("fill", `black`);
      document.body.appendChild(svg);
      debugElements[debugId] = { svg, line, text };
    }
    line.setAttribute("x1", a2.x.toString());
    line.setAttribute("x2", b2.x.toString());
    line.setAttribute("y1", a2.y.toString());
    line.setAttribute("y2", b2.y.toString());
    line.setAttribute("style", `stroke:${color};stroke-width:2`);
    text.setAttribute("x", (a2.x - (a2.x - b2.x) / 2).toString());
    text.setAttribute("y", (a2.y - (a2.y - b2.y) / 2).toString());
    if (label) {
      text.innerHTML = label;
    }
  });
};
var distanceChange = "increasing";
var directionalCollision = (input, previous) => {
  var _a5;
  const { dragOperation, droppable } = input;
  const { shape: dropShape } = droppable;
  const { position } = dragOperation;
  const dragShape = (_a5 = dragOperation.shape) == null ? void 0 : _a5.current;
  if (!dragShape || !dropShape)
    return null;
  const dropCenter = dropShape.center;
  const distanceToPrevious = Math.sqrt(
    Math.pow(dropCenter.x - previous.x, 2) + Math.pow(dropCenter.y - previous.y, 2)
  );
  const distanceToCurrent = Math.sqrt(
    Math.pow(dropCenter.x - position.current.x, 2) + Math.pow(dropCenter.y - position.current.y, 2)
  );
  distanceChange = distanceToCurrent === distanceToPrevious ? distanceChange : distanceToCurrent < distanceToPrevious ? "decreasing" : "increasing";
  collisionDebug(
    dragShape.center,
    dropCenter,
    droppable.id.toString(),
    "rebeccapurple"
  );
  if (distanceChange === "decreasing") {
    return {
      id: droppable.id,
      value: 1,
      type: CollisionType.Collision
    };
  }
  return null;
};
init_react_import();
var getDirection3 = (dragAxis, delta) => {
  if (dragAxis === "dynamic") {
    if (Math.abs(delta.y) > Math.abs(delta.x)) {
      return delta.y === 0 ? null : delta.y > 0 ? "down" : "up";
    } else {
      return delta.x === 0 ? null : delta.x > 0 ? "right" : "left";
    }
  } else if (dragAxis === "x") {
    return delta.x === 0 ? null : delta.x > 0 ? "right" : "left";
  }
  return delta.y === 0 ? null : delta.y > 0 ? "down" : "up";
};
init_react_import();
var getMidpointImpact = (dragShape, dropShape, direction, offsetMultiplier = 0) => {
  const dragRect = dragShape.boundingRectangle;
  const dropCenter = dropShape.center;
  if (direction === "down") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.height;
    return dragRect.bottom >= dropCenter.y + offset2;
  } else if (direction === "up") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.height;
    return dragRect.top < dropCenter.y - offset2;
  } else if (direction === "left") {
    const offset2 = offsetMultiplier * dropShape.boundingRectangle.width;
    return dropCenter.x - offset2 >= dragRect.left;
  }
  const offset = offsetMultiplier * dropShape.boundingRectangle.width;
  return dragRect.right - offset >= dropCenter.x;
};
init_react_import();
var INTERVAL_SENSITIVITY = 10;
var intervalCache = {
  current: { x: 0, y: 0 },
  delta: { x: 0, y: 0 },
  previous: { x: 0, y: 0 },
  direction: null
};
var trackMovementInterval = (point, dragAxis = "dynamic") => {
  intervalCache.current = point;
  intervalCache.delta = {
    x: point.x - intervalCache.previous.x,
    y: point.y - intervalCache.previous.y
  };
  intervalCache.direction = getDirection3(dragAxis, intervalCache.delta) || intervalCache.direction;
  if (Math.abs(intervalCache.delta.x) > INTERVAL_SENSITIVITY || Math.abs(intervalCache.delta.y) > INTERVAL_SENSITIVITY) {
    intervalCache.previous = Point.from(point);
  }
  return intervalCache;
};
init_react_import();
var pointerIntersection3 = ({
  dragOperation,
  droppable
}) => {
  const pointerCoordinates = dragOperation.position.current;
  if (!pointerCoordinates) {
    return null;
  }
  const { id } = droppable;
  if (!droppable.shape) {
    return null;
  }
  if (droppable.shape.containsPoint(pointerCoordinates)) {
    const distance = Point.distance(droppable.shape.center, pointerCoordinates);
    return {
      id,
      value: 1 / distance,
      type: CollisionType.PointerIntersection,
      priority: CollisionPriority.High
    };
  }
  return null;
};
var closestCorners2 = (input) => {
  const { dragOperation, droppable } = input;
  const { shape, position } = dragOperation;
  if (!droppable.shape) {
    return null;
  }
  const shapeCorners = shape ? Rectangle.from(shape.current.boundingRectangle).corners : void 0;
  const distance = Rectangle.from(
    droppable.shape.boundingRectangle
  ).corners.reduce(
    (acc, corner, index) => {
      var _a5;
      return acc + Point.distance(
        Point.from(corner),
        (_a5 = shapeCorners == null ? void 0 : shapeCorners[index]) != null ? _a5 : position.current
      );
    },
    0
  );
  const value = distance / 4;
  return {
    id: droppable.id,
    value: 1 / value,
    type: CollisionType.Collision,
    priority: CollisionPriority.Normal
  };
};
init_react_import();
var collisionStore = createStore(() => ({
  fallbackEnabled: false
}));
var flushNext = "";
var createDynamicCollisionDetector = (dragAxis, midpointOffset = 0.05) => (input) => {
  var _a5, _b3, _c4, _d2, _e;
  const { dragOperation, droppable } = input;
  const { position } = dragOperation;
  const dragShape = (_a5 = dragOperation.shape) == null ? void 0 : _a5.current;
  const { shape: dropShape } = droppable;
  if (!dragShape || !dropShape) {
    return null;
  }
  const { center: dragCenter } = dragShape;
  const { fallbackEnabled } = collisionStore.getState();
  const interval = trackMovementInterval(position.current, dragAxis);
  const data = {
    direction: interval.direction
  };
  const { center: dropCenter } = dropShape;
  const overMidpoint = getMidpointImpact(
    dragShape,
    dropShape,
    interval.direction,
    midpointOffset
  );
  if (((_b3 = dragOperation.source) == null ? void 0 : _b3.id) === droppable.id) {
    const collision = directionalCollision(input, interval.previous);
    collisionDebug(dragCenter, dropCenter, droppable.id.toString(), "yellow");
    if (collision) {
      return __spreadProps(__spreadValues({}, collision), {
        priority: CollisionPriority.Highest,
        data
      });
    }
  }
  const intersectionArea = dragShape.intersectionArea(dropShape);
  const intersectionRatio = intersectionArea / dropShape.area;
  if (intersectionArea && overMidpoint) {
    collisionDebug(
      dragCenter,
      dropCenter,
      droppable.id.toString(),
      "green",
      interval.direction
    );
    const collision = {
      id: droppable.id,
      value: intersectionRatio,
      priority: CollisionPriority.High,
      type: CollisionType.Collision
    };
    const shouldFlushId = flushNext === droppable.id;
    flushNext = "";
    return __spreadProps(__spreadValues({}, collision), { id: shouldFlushId ? "flush" : collision.id, data });
  }
  if (fallbackEnabled && ((_c4 = dragOperation.source) == null ? void 0 : _c4.id) !== droppable.id) {
    const xAxisIntersection = dropShape.boundingRectangle.right > dragShape.boundingRectangle.left && dropShape.boundingRectangle.left < dragShape.boundingRectangle.right;
    const yAxisIntersection = dropShape.boundingRectangle.bottom > dragShape.boundingRectangle.top && dropShape.boundingRectangle.top < dragShape.boundingRectangle.bottom;
    if (dragAxis === "y" && xAxisIntersection || yAxisIntersection) {
      const fallbackCollision = closestCorners2(input);
      if (fallbackCollision) {
        const direction = getDirection3(dragAxis, {
          x: dragShape.center.x - (((_d2 = droppable.shape) == null ? void 0 : _d2.center.x) || 0),
          y: dragShape.center.y - (((_e = droppable.shape) == null ? void 0 : _e.center.y) || 0)
        });
        data.direction = direction;
        if (intersectionArea) {
          collisionDebug(
            dragCenter,
            dropCenter,
            droppable.id.toString(),
            "red",
            direction || ""
          );
          flushNext = droppable.id;
          return __spreadProps(__spreadValues({}, fallbackCollision), {
            priority: CollisionPriority.Low,
            data
          });
        }
        collisionDebug(
          dragCenter,
          dropCenter,
          droppable.id.toString(),
          "orange",
          direction || ""
        );
        return __spreadProps(__spreadValues({}, fallbackCollision), {
          priority: CollisionPriority.Lowest,
          data
        });
      }
    }
  }
  collisionDebug(dragCenter, dropCenter, droppable.id.toString(), "hotpink");
  return null;
};
var SortableProvider = ({
  children,
  onDragStart,
  onDragEnd,
  onMove
}) => {
  const sensors = useSensors({
    mouse: { distance: { value: 5 } }
  });
  return (0, import_jsx_runtime8.jsx)(
    DragDropProvider,
    {
      sensors,
      onDragStart: (event) => {
        var _a5, _b3;
        return onDragStart((_b3 = (_a5 = event.operation.source) == null ? void 0 : _a5.id.toString()) != null ? _b3 : "");
      },
      onDragOver: (event, manager) => {
        var _a5;
        event.preventDefault();
        const { operation } = event;
        const { source, target } = operation;
        if (!source || !target)
          return;
        let sourceIndex = source.data.index;
        let targetIndex = target.data.index;
        const collisionData = (_a5 = manager.collisionObserver.collisions[0]) == null ? void 0 : _a5.data;
        if (sourceIndex !== targetIndex && source.id !== target.id) {
          const collisionPosition = (collisionData == null ? void 0 : collisionData.direction) === "up" ? "before" : "after";
          if (targetIndex >= sourceIndex) {
            targetIndex = targetIndex - 1;
          }
          if (collisionPosition === "after") {
            targetIndex = targetIndex + 1;
          }
          onMove({
            source: sourceIndex,
            target: targetIndex
          });
        }
      },
      onDragEnd: () => {
        setTimeout(() => {
          onDragEnd();
        }, 250);
      },
      children
    }
  );
};
var Sortable = ({
  id,
  index,
  disabled,
  children,
  type = "item"
}) => {
  const {
    ref: sortableRef,
    isDragging,
    isDropping,
    handleRef
  } = useSortable({
    id,
    type,
    index,
    disabled,
    data: { index },
    collisionDetector: createDynamicCollisionDetector("y")
  });
  return children({ isDragging, isDropping, ref: sortableRef, handleRef });
};
init_react_import();
var NestedFieldContext = (0, import_react25.createContext)({});
var useNestedFieldContext = () => {
  const context = (0, import_react25.useContext)(NestedFieldContext);
  return __spreadProps(__spreadValues({}, context), {
    readOnlyFields: context.readOnlyFields || {}
  });
};
var NestedFieldProvider = ({
  children,
  name,
  subName,
  wildcardName = name,
  readOnlyFields
}) => {
  const subPath = `${name}.${subName}`;
  const wildcardSubPath = `${wildcardName}.${subName}`;
  const subReadOnlyFields = (0, import_react25.useMemo)(
    () => Object.keys(readOnlyFields).reduce((acc, readOnlyKey) => {
      const isLocal = readOnlyKey.indexOf(subPath) > -1 || readOnlyKey.indexOf(wildcardSubPath) > -1;
      if (isLocal) {
        const subPathPattern = new RegExp(
          `^(${name}|${wildcardName}).`.replace(/\[/g, "\\[").replace(/\]/g, "\\]").replace(/\./g, "\\.").replace(/\*/g, "\\*")
        );
        const localName = readOnlyKey.replace(subPathPattern, "");
        return __spreadProps(__spreadValues({}, acc), {
          [localName]: readOnlyFields[readOnlyKey]
        });
      }
      return acc;
    }, {}),
    [name, subName, wildcardName, readOnlyFields]
  );
  return (0, import_jsx_runtime9.jsx)(
    NestedFieldContext.Provider,
    {
      value: { readOnlyFields: subReadOnlyFields, localName: subName },
      children
    }
  );
};
var getClassName6 = get_class_name_factory_default("ArrayField", styles_module_default4);
var getClassNameItem = get_class_name_factory_default("ArrayFieldItem", styles_module_default4);
var ArrayField = ({
  field,
  onChange,
  value: _value2,
  name,
  label,
  labelIcon,
  readOnly,
  id,
  Label: Label2 = (props) => (0, import_jsx_runtime10.jsx)("div", __spreadValues({}, props))
}) => {
  const thisArrayState = useAppStore((s2) => s2.state.ui.arrayState[id]);
  const setUi = useAppStore((s2) => s2.setUi);
  const { readOnlyFields, localName = name } = useNestedFieldContext();
  const value = _value2;
  const arrayState = thisArrayState || {
    items: Array.from(value || []).map((item, idx) => {
      return {
        _originalIndex: idx,
        _arrayId: `${id}-${idx}`
      };
    }),
    openId: ""
  };
  const [localState, setLocalState] = (0, import_react21.useState)({ arrayState, value });
  (0, import_react21.useEffect)(() => {
    var _a5;
    const _arrayState = (_a5 = appStore.getState().state.ui.arrayState[id]) != null ? _a5 : arrayState;
    setLocalState({ arrayState: _arrayState, value });
  }, [value]);
  const appStore = useAppStoreApi();
  const mapArrayStateToUi = (0, import_react21.useCallback)(
    (partialArrayState) => {
      const state = appStore.getState().state;
      return {
        arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
          [id]: __spreadValues(__spreadValues({}, arrayState), partialArrayState)
        })
      };
    },
    [arrayState, appStore]
  );
  const getHighestIndex = (0, import_react21.useCallback)(() => {
    return arrayState.items.reduce(
      (acc, item) => item._originalIndex > acc ? item._originalIndex : acc,
      -1
    );
  }, [arrayState]);
  const regenerateArrayState = (0, import_react21.useCallback)(
    (value2) => {
      let highestIndex = getHighestIndex();
      const newItems = Array.from(value2 || []).map((item, idx) => {
        var _a5;
        const arrayStateItem = arrayState.items[idx];
        const newItem = {
          _originalIndex: typeof (arrayStateItem == null ? void 0 : arrayStateItem._originalIndex) !== "undefined" ? arrayStateItem._originalIndex : highestIndex + 1,
          _arrayId: ((_a5 = arrayState.items[idx]) == null ? void 0 : _a5._arrayId) || `${id}-${highestIndex + 1}`
        };
        if (newItem._originalIndex > highestIndex) {
          highestIndex = newItem._originalIndex;
        }
        return newItem;
      });
      return __spreadProps(__spreadValues({}, arrayState), { items: newItems });
    },
    [arrayState]
  );
  (0, import_react21.useEffect)(() => {
    if (arrayState.items.length > 0) {
      setUi(mapArrayStateToUi(arrayState));
    }
  }, []);
  const [draggedItem, setDraggedItem] = (0, import_react21.useState)("");
  const isDraggingAny = !!draggedItem;
  const canEdit = useAppStore(
    (s2) => s2.permissions.getPermissions({ item: s2.selectedItem }).edit
  );
  const forceReadOnly = !canEdit;
  const valueRef = (0, import_react21.useRef)(value);
  const uniqifyItem = (0, import_react21.useCallback)(
    (val) => {
      if (field.type !== "array" || !field.arrayFields)
        return;
      const config = appStore.getState().config;
      return walkField({
        value: val,
        fields: field.arrayFields,
        mappers: {
          slot: ({ value: value2 }) => {
            const content = value2;
            return content.map((item) => populateIds(item, config, true));
          }
        },
        config
      });
    },
    [appStore, field]
  );
  if (field.type !== "array" || !field.arrayFields) {
    return null;
  }
  const addDisabled = field.max !== void 0 && localState.arrayState.items.length >= field.max || readOnly;
  return (0, import_jsx_runtime10.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime10.jsx)(List, { size: 16 }),
      el: "div",
      readOnly,
      children: (0, import_jsx_runtime10.jsx)(
        SortableProvider,
        {
          onDragStart: (id2) => setDraggedItem(id2),
          onDragEnd: () => {
            setDraggedItem("");
            onChange(valueRef.current);
          },
          onMove: (move2) => {
            if (arrayState.items[move2.source]._arrayId !== draggedItem) {
              return;
            }
            const newValue = reorder2(localState.value, move2.source, move2.target);
            const newArrayStateItems = reorder2(
              arrayState.items,
              move2.source,
              move2.target
            );
            const state = appStore.getState().state;
            const newUi = {
              arrayState: __spreadProps(__spreadValues({}, state.ui.arrayState), {
                [id]: __spreadProps(__spreadValues({}, arrayState), { items: newArrayStateItems })
              })
            };
            setUi(newUi, false);
            setLocalState({
              value: newValue,
              arrayState: __spreadProps(__spreadValues({}, arrayState), { items: newArrayStateItems })
            });
            valueRef.current = newValue;
          },
          children: (0, import_jsx_runtime10.jsxs)(
            "div",
            {
              className: getClassName6({
                hasItems: Array.isArray(value) && value.length > 0,
                addDisabled
              }),
              children: [
                localState.arrayState.items.length > 0 && (0, import_jsx_runtime10.jsx)("div", { className: getClassName6("inner"), "data-dnd-container": true, children: localState.arrayState.items.map((item, i2) => {
                  const { _arrayId = `${id}-${i2}`, _originalIndex = i2 } = item;
                  const data = Array.from(localState.value || [])[i2] || {};
                  return (0, import_jsx_runtime10.jsx)(
                    Sortable,
                    {
                      id: _arrayId,
                      index: i2,
                      disabled: readOnly,
                      children: ({ isDragging, ref, handleRef }) => (0, import_jsx_runtime10.jsxs)(
                        "div",
                        {
                          ref,
                          className: getClassNameItem({
                            isExpanded: arrayState.openId === _arrayId,
                            isDragging,
                            readOnly
                          }),
                          children: [
                            (0, import_jsx_runtime10.jsxs)(
                              "div",
                              {
                                ref: handleRef,
                                onClick: (e3) => {
                                  if (isDragging)
                                    return;
                                  e3.preventDefault();
                                  e3.stopPropagation();
                                  if (arrayState.openId === _arrayId) {
                                    setUi(
                                      mapArrayStateToUi({
                                        openId: ""
                                      })
                                    );
                                  } else {
                                    setUi(
                                      mapArrayStateToUi({
                                        openId: _arrayId
                                      })
                                    );
                                  }
                                },
                                className: getClassNameItem("summary"),
                                children: [
                                  field.getItemSummary ? field.getItemSummary(data, i2) : `Item #${_originalIndex}`,
                                  (0, import_jsx_runtime10.jsxs)("div", { className: getClassNameItem("rhs"), children: [
                                    !readOnly && (0, import_jsx_runtime10.jsxs)("div", { className: getClassNameItem("actions"), children: [
                                      (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("action"), children: (0, import_jsx_runtime10.jsx)(
                                        IconButton,
                                        {
                                          type: "button",
                                          disabled: !!addDisabled,
                                          onClick: (e3) => {
                                            e3.stopPropagation();
                                            const existingValue = [...value || []];
                                            const newItem = uniqifyItem(
                                              existingValue[i2]
                                            );
                                            existingValue.splice(i2, 0, newItem);
                                            const newUi = mapArrayStateToUi(
                                              regenerateArrayState(existingValue)
                                            );
                                            setUi(newUi, false);
                                            onChange(existingValue);
                                          },
                                          title: "Duplicate",
                                          children: (0, import_jsx_runtime10.jsx)(Copy, { size: 16 })
                                        }
                                      ) }),
                                      (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("action"), children: (0, import_jsx_runtime10.jsx)(
                                        IconButton,
                                        {
                                          type: "button",
                                          disabled: field.min !== void 0 && field.min >= localState.arrayState.items.length,
                                          onClick: (e3) => {
                                            e3.stopPropagation();
                                            const existingValue = [...value || []];
                                            const existingItems = [
                                              ...arrayState.items || []
                                            ];
                                            existingValue.splice(i2, 1);
                                            existingItems.splice(i2, 1);
                                            setUi(
                                              mapArrayStateToUi({
                                                items: existingItems
                                              }),
                                              false
                                            );
                                            onChange(existingValue);
                                          },
                                          title: "Delete",
                                          children: (0, import_jsx_runtime10.jsx)(Trash, { size: 16 })
                                        }
                                      ) })
                                    ] }),
                                    (0, import_jsx_runtime10.jsx)("div", { children: (0, import_jsx_runtime10.jsx)(DragIcon, {}) })
                                  ] })
                                ]
                              }
                            ),
                            (0, import_jsx_runtime10.jsx)("div", { className: getClassNameItem("body"), children: arrayState.openId === _arrayId && (0, import_jsx_runtime10.jsx)("fieldset", { className: getClassNameItem("fieldset"), children: Object.keys(field.arrayFields).map(
                              (subName) => {
                                const subField = field.arrayFields[subName];
                                const indexName = `${name}[${i2}]`;
                                const subPath = `${indexName}.${subName}`;
                                const localIndexName = `${localName}[${i2}]`;
                                const localWildcardName = `${localName}[*]`;
                                const localSubPath = `${localIndexName}.${subName}`;
                                const localWildcardSubPath = `${localWildcardName}.${subName}`;
                                const subReadOnly = forceReadOnly ? forceReadOnly : typeof readOnlyFields[subPath] !== "undefined" ? readOnlyFields[localSubPath] : readOnlyFields[localWildcardSubPath];
                                const label2 = subField.label || subName;
                                return (0, import_jsx_runtime10.jsx)(
                                  NestedFieldProvider,
                                  {
                                    name: localIndexName,
                                    wildcardName: localWildcardName,
                                    subName,
                                    readOnlyFields,
                                    children: (0, import_jsx_runtime10.jsx)(
                                      AutoFieldPrivate,
                                      {
                                        name: subPath,
                                        label: label2,
                                        id: `${_arrayId}_${subName}`,
                                        readOnly: subReadOnly,
                                        field: __spreadProps(__spreadValues({}, subField), {
                                          label: label2
                                          // May be used by custom fields
                                        }),
                                        value: data[subName],
                                        onChange: (val, ui) => {
                                          onChange(
                                            replace(value, i2, __spreadProps(__spreadValues({}, data), {
                                              [subName]: val
                                            })),
                                            ui
                                          );
                                        }
                                      }
                                    )
                                  },
                                  subPath
                                );
                              }
                            ) }) })
                          ]
                        }
                      )
                    },
                    _arrayId
                  );
                }) }),
                !addDisabled && (0, import_jsx_runtime10.jsx)(
                  "button",
                  {
                    type: "button",
                    className: getClassName6("addButton"),
                    onClick: () => {
                      var _a5;
                      if (isDraggingAny)
                        return;
                      const existingValue = value || [];
                      const newItem = defaultSlots(
                        uniqifyItem((_a5 = field.defaultItemProps) != null ? _a5 : {}),
                        field.arrayFields
                      );
                      const newValue = [...existingValue, newItem];
                      const newArrayState = regenerateArrayState(newValue);
                      setUi(mapArrayStateToUi(newArrayState), false);
                      onChange(newValue);
                    },
                    children: (0, import_jsx_runtime10.jsx)(Plus, { size: 21 })
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
};
init_react_import();
var getClassName7 = get_class_name_factory_default("Input", styles_module_default3);
var DefaultField = ({
  field,
  onChange,
  readOnly,
  value: _value2,
  name,
  label,
  labelIcon,
  Label: Label2,
  id
}) => {
  const value = _value2;
  return (0, import_jsx_runtime11.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime11.jsxs)(import_jsx_runtime11.Fragment, { children: [
        field.type === "text" && (0, import_jsx_runtime11.jsx)(Type, { size: 16 }),
        field.type === "number" && (0, import_jsx_runtime11.jsx)(Hash, { size: 16 })
      ] }),
      readOnly,
      children: (0, import_jsx_runtime11.jsx)(
        "input",
        {
          className: getClassName7("input"),
          autoComplete: "off",
          type: field.type,
          title: label || name,
          name,
          value: (value == null ? void 0 : value.toString) ? value.toString() : "",
          onChange: (e3) => {
            if (field.type === "number") {
              const numberValue = Number(e3.currentTarget.value);
              if (typeof field.min !== "undefined" && numberValue < field.min) {
                return;
              }
              if (typeof field.max !== "undefined" && numberValue > field.max) {
                return;
              }
              onChange(numberValue);
            } else {
              onChange(e3.currentTarget.value);
            }
          },
          readOnly,
          tabIndex: readOnly ? -1 : void 0,
          id,
          min: field.type === "number" ? field.min : void 0,
          max: field.type === "number" ? field.max : void 0,
          placeholder: field.type === "text" || field.type === "number" ? field.placeholder : void 0,
          step: field.type === "number" ? field.step : void 0
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default6 = { "ExternalInput-actions": "_ExternalInput-actions_91ls0_1", "ExternalInput-button": "_ExternalInput-button_91ls0_5", "ExternalInput--dataSelected": "_ExternalInput--dataSelected_91ls0_24", "ExternalInput--readOnly": "_ExternalInput--readOnly_91ls0_31", "ExternalInput-detachButton": "_ExternalInput-detachButton_91ls0_35", "ExternalInput": "_ExternalInput_91ls0_1", "ExternalInputModal": "_ExternalInputModal_91ls0_79", "ExternalInputModal-grid": "_ExternalInputModal-grid_91ls0_89", "ExternalInputModal--filtersToggled": "_ExternalInputModal--filtersToggled_91ls0_100", "ExternalInputModal-filters": "_ExternalInputModal-filters_91ls0_105", "ExternalInputModal-masthead": "_ExternalInputModal-masthead_91ls0_124", "ExternalInputModal-tableWrapper": "_ExternalInputModal-tableWrapper_91ls0_133", "ExternalInputModal-table": "_ExternalInputModal-table_91ls0_133", "ExternalInputModal-thead": "_ExternalInputModal-thead_91ls0_149", "ExternalInputModal-th": "_ExternalInputModal-th_91ls0_149", "ExternalInputModal-td": "_ExternalInputModal-td_91ls0_164", "ExternalInputModal-tr": "_ExternalInputModal-tr_91ls0_169", "ExternalInputModal-tbody": "_ExternalInputModal-tbody_91ls0_176", "ExternalInputModal--hasData": "_ExternalInputModal--hasData_91ls0_202", "ExternalInputModal-loadingBanner": "_ExternalInputModal-loadingBanner_91ls0_206", "ExternalInputModal--isLoading": "_ExternalInputModal--isLoading_91ls0_223", "ExternalInputModal-searchForm": "_ExternalInputModal-searchForm_91ls0_227", "ExternalInputModal-search": "_ExternalInputModal-search_91ls0_227", "ExternalInputModal-searchIcon": "_ExternalInputModal-searchIcon_91ls0_264", "ExternalInputModal-searchIconText": "_ExternalInputModal-searchIconText_91ls0_289", "ExternalInputModal-searchInput": "_ExternalInputModal-searchInput_91ls0_299", "ExternalInputModal-searchActions": "_ExternalInputModal-searchActions_91ls0_313", "ExternalInputModal-searchActionIcon": "_ExternalInputModal-searchActionIcon_91ls0_326", "ExternalInputModal-footerContainer": "_ExternalInputModal-footerContainer_91ls0_330", "ExternalInputModal-footer": "_ExternalInputModal-footer_91ls0_330", "ExternalInputModal-field": "_ExternalInputModal-field_91ls0_343" };
init_react_import();
init_react_import();
var styles_module_default7 = { "Modal": "_Modal_ikbaj_1", "Modal--isOpen": "_Modal--isOpen_ikbaj_15", "Modal-inner": "_Modal-inner_ikbaj_19" };
var getClassName8 = get_class_name_factory_default("Modal", styles_module_default7);
var Modal = ({
  children,
  onClose,
  isOpen
}) => {
  const [rootEl, setRootEl] = (0, import_react28.useState)(null);
  (0, import_react28.useEffect)(() => {
    setRootEl(document.getElementById("puck-portal-root"));
  }, []);
  if (!rootEl) {
    return (0, import_jsx_runtime12.jsx)("div", {});
  }
  return (0, import_react_dom2.createPortal)(
    (0, import_jsx_runtime12.jsx)("div", { className: getClassName8({ isOpen }), onClick: onClose, children: (0, import_jsx_runtime12.jsx)(
      "div",
      {
        className: getClassName8("inner"),
        onClick: (e3) => e3.stopPropagation(),
        children
      }
    ) }),
    rootEl
  );
};
init_react_import();
init_react_import();
var styles_module_default8 = { "Heading": "_Heading_qxrry_1", "Heading--xxxxl": "_Heading--xxxxl_qxrry_12", "Heading--xxxl": "_Heading--xxxl_qxrry_18", "Heading--xxl": "_Heading--xxl_qxrry_22", "Heading--xl": "_Heading--xl_qxrry_26", "Heading--l": "_Heading--l_qxrry_30", "Heading--m": "_Heading--m_qxrry_34", "Heading--s": "_Heading--s_qxrry_38", "Heading--xs": "_Heading--xs_qxrry_42" };
var getClassName9 = get_class_name_factory_default("Heading", styles_module_default8);
var Heading = ({ children, rank, size = "m" }) => {
  const Tag = rank ? `h${rank}` : "span";
  return (0, import_jsx_runtime13.jsx)(
    Tag,
    {
      className: getClassName9({
        [size]: true
      }),
      children
    }
  );
};
init_react_import();
var getClassName10 = get_class_name_factory_default("ExternalInput", styles_module_default6);
var getClassNameModal = get_class_name_factory_default("ExternalInputModal", styles_module_default6);
var dataCache = {};
var ExternalInput = ({
  field,
  onChange,
  value = null,
  name,
  id,
  readOnly
}) => {
  const {
    mapProp = (val) => val,
    mapRow = (val) => val,
    filterFields
  } = field || {};
  const [data, setData] = (0, import_react27.useState)([]);
  const [isOpen, setOpen] = (0, import_react27.useState)(false);
  const [isLoading, setIsLoading] = (0, import_react27.useState)(true);
  const hasFilterFields = !!filterFields;
  const [filters, setFilters] = (0, import_react27.useState)(field.initialFilters || {});
  const [filtersToggled, setFiltersToggled] = (0, import_react27.useState)(hasFilterFields);
  const mappedData = (0, import_react27.useMemo)(() => {
    return data.map(mapRow);
  }, [data]);
  const keys = (0, import_react27.useMemo)(() => {
    const validKeys = /* @__PURE__ */ new Set();
    for (const item of mappedData) {
      for (const key of Object.keys(item)) {
        if (typeof item[key] === "string" || typeof item[key] === "number" || (0, import_react27.isValidElement)(item[key])) {
          validKeys.add(key);
        }
      }
    }
    return Array.from(validKeys);
  }, [mappedData]);
  const [searchQuery, setSearchQuery] = (0, import_react27.useState)(field.initialQuery || "");
  const search = (0, import_react27.useCallback)(
    (query, filters2) => __async(void 0, null, function* () {
      setIsLoading(true);
      const cacheKey = `${id}-${query}-${JSON.stringify(filters2)}`;
      const listData = dataCache[cacheKey] || (yield field.fetchList({ query, filters: filters2 }));
      if (listData) {
        setData(listData);
        setIsLoading(false);
        dataCache[cacheKey] = listData;
      }
    }),
    [id, field]
  );
  const Footer = (0, import_react27.useCallback)(
    (props) => field.renderFooter ? field.renderFooter(props) : (0, import_jsx_runtime14.jsxs)("span", { className: getClassNameModal("footer"), children: [
      props.items.length,
      " result",
      props.items.length === 1 ? "" : "s"
    ] }),
    [field.renderFooter]
  );
  (0, import_react27.useEffect)(() => {
    search(searchQuery, filters);
  }, []);
  return (0, import_jsx_runtime14.jsxs)(
    "div",
    {
      className: getClassName10({
        dataSelected: !!value,
        modalVisible: isOpen,
        readOnly
      }),
      id,
      children: [
        (0, import_jsx_runtime14.jsxs)("div", { className: getClassName10("actions"), children: [
          (0, import_jsx_runtime14.jsx)(
            "button",
            {
              type: "button",
              onClick: () => setOpen(true),
              className: getClassName10("button"),
              disabled: readOnly,
              children: value ? field.getItemSummary ? field.getItemSummary(value) : "External item" : (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, { children: [
                (0, import_jsx_runtime14.jsx)(Link, { size: "16" }),
                (0, import_jsx_runtime14.jsx)("span", { children: field.placeholder })
              ] })
            }
          ),
          value && (0, import_jsx_runtime14.jsx)(
            "button",
            {
              type: "button",
              className: getClassName10("detachButton"),
              onClick: () => {
                onChange(null);
              },
              disabled: readOnly,
              children: (0, import_jsx_runtime14.jsx)(LockOpen, { size: 16 })
            }
          )
        ] }),
        (0, import_jsx_runtime14.jsx)(Modal, { onClose: () => setOpen(false), isOpen, children: (0, import_jsx_runtime14.jsxs)(
          "form",
          {
            className: getClassNameModal({
              isLoading,
              loaded: !isLoading,
              hasData: mappedData.length > 0,
              filtersToggled
            }),
            onSubmit: (e3) => {
              e3.preventDefault();
              search(searchQuery, filters);
            },
            children: [
              (0, import_jsx_runtime14.jsx)("div", { className: getClassNameModal("masthead"), children: field.showSearch ? (0, import_jsx_runtime14.jsxs)("div", { className: getClassNameModal("searchForm"), children: [
                (0, import_jsx_runtime14.jsxs)("label", { className: getClassNameModal("search"), children: [
                  (0, import_jsx_runtime14.jsx)("span", { className: getClassNameModal("searchIconText"), children: "Search" }),
                  (0, import_jsx_runtime14.jsx)("div", { className: getClassNameModal("searchIcon"), children: (0, import_jsx_runtime14.jsx)(Search, { size: "18" }) }),
                  (0, import_jsx_runtime14.jsx)(
                    "input",
                    {
                      className: getClassNameModal("searchInput"),
                      name: "q",
                      type: "search",
                      placeholder: field.placeholder,
                      onChange: (e3) => {
                        setSearchQuery(e3.currentTarget.value);
                      },
                      autoComplete: "off",
                      value: searchQuery
                    }
                  )
                ] }),
                (0, import_jsx_runtime14.jsxs)("div", { className: getClassNameModal("searchActions"), children: [
                  (0, import_jsx_runtime14.jsx)(Button, { type: "submit", loading: isLoading, fullWidth: true, children: "Search" }),
                  hasFilterFields && (0, import_jsx_runtime14.jsx)("div", { className: getClassNameModal("searchActionIcon"), children: (0, import_jsx_runtime14.jsx)(
                    IconButton,
                    {
                      type: "button",
                      title: "Toggle filters",
                      onClick: (e3) => {
                        e3.preventDefault();
                        e3.stopPropagation();
                        setFiltersToggled(!filtersToggled);
                      },
                      children: (0, import_jsx_runtime14.jsx)(SlidersHorizontal, { size: 20 })
                    }
                  ) })
                ] })
              ] }) : (0, import_jsx_runtime14.jsx)(Heading, { rank: "2", size: "xs", children: field.placeholder || "Select data" }) }),
              (0, import_jsx_runtime14.jsxs)("div", { className: getClassNameModal("grid"), children: [
                hasFilterFields && (0, import_jsx_runtime14.jsx)("div", { className: getClassNameModal("filters"), children: hasFilterFields && Object.keys(filterFields).map((fieldName) => {
                  const filterField = filterFields[fieldName];
                  return (0, import_jsx_runtime14.jsx)(
                    "div",
                    {
                      className: getClassNameModal("field"),
                      children: (0, import_jsx_runtime14.jsx)(
                        AutoFieldPrivate,
                        {
                          field: filterField,
                          name: fieldName,
                          id: `external_field_${fieldName}_filter`,
                          label: filterField.label || fieldName,
                          value: filters[fieldName],
                          onChange: (value2) => {
                            const newFilters = __spreadProps(__spreadValues({}, filters), {
                              [fieldName]: value2
                            });
                            setFilters(newFilters);
                            search(searchQuery, newFilters);
                          }
                        }
                      )
                    },
                    fieldName
                  );
                }) }),
                (0, import_jsx_runtime14.jsxs)("div", { className: getClassNameModal("tableWrapper"), children: [
                  (0, import_jsx_runtime14.jsxs)("table", { className: getClassNameModal("table"), children: [
                    (0, import_jsx_runtime14.jsx)("thead", { className: getClassNameModal("thead"), children: (0, import_jsx_runtime14.jsx)("tr", { className: getClassNameModal("tr"), children: keys.map((key) => (0, import_jsx_runtime14.jsx)(
                      "th",
                      {
                        className: getClassNameModal("th"),
                        style: { textAlign: "left" },
                        children: key
                      },
                      key
                    )) }) }),
                    (0, import_jsx_runtime14.jsx)("tbody", { className: getClassNameModal("tbody"), children: mappedData.map((item, i2) => {
                      return (0, import_jsx_runtime14.jsx)(
                        "tr",
                        {
                          style: { whiteSpace: "nowrap" },
                          className: getClassNameModal("tr"),
                          onClick: () => {
                            onChange(mapProp(data[i2]));
                            setOpen(false);
                          },
                          children: keys.map((key) => (0, import_jsx_runtime14.jsx)("td", { className: getClassNameModal("td"), children: item[key] }, key))
                        },
                        i2
                      );
                    }) })
                  ] }),
                  (0, import_jsx_runtime14.jsx)("div", { className: getClassNameModal("loadingBanner"), children: (0, import_jsx_runtime14.jsx)(Loader, { size: 24 }) })
                ] })
              ] }),
              (0, import_jsx_runtime14.jsx)("div", { className: getClassNameModal("footerContainer"), children: (0, import_jsx_runtime14.jsx)(Footer, { items: mappedData }) })
            ]
          }
        ) })
      ]
    }
  );
};
var ExternalField = ({
  field,
  onChange,
  value,
  name,
  label,
  labelIcon,
  Label: Label2,
  id,
  readOnly
}) => {
  var _a5, _b3, _c4;
  const validField = field;
  const deprecatedField = field;
  (0, import_react26.useEffect)(() => {
    if (deprecatedField.adaptor) {
      console.error(
        "Warning: The `adaptor` API is deprecated. Please use updated APIs on the `external` field instead. This will be a breaking change in a future release."
      );
    }
  }, []);
  if (field.type !== "external") {
    return null;
  }
  return (0, import_jsx_runtime15.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime15.jsx)(Link, { size: 16 }),
      el: "div",
      children: (0, import_jsx_runtime15.jsx)(
        ExternalInput,
        {
          name,
          field: __spreadProps(__spreadValues({}, validField), {
            // DEPRECATED
            placeholder: ((_a5 = deprecatedField.adaptor) == null ? void 0 : _a5.name) ? `Select from ${deprecatedField.adaptor.name}` : validField.placeholder || "Select data",
            mapProp: ((_b3 = deprecatedField.adaptor) == null ? void 0 : _b3.mapProp) || validField.mapProp,
            mapRow: validField.mapRow,
            fetchList: ((_c4 = deprecatedField.adaptor) == null ? void 0 : _c4.fetchList) ? () => __async(void 0, null, function* () {
              return yield deprecatedField.adaptor.fetchList(
                deprecatedField.adaptorParams
              );
            }) : validField.fetchList
          }),
          onChange,
          value,
          id,
          readOnly
        }
      )
    }
  );
};
init_react_import();
var getClassName11 = get_class_name_factory_default("Input", styles_module_default3);
var RadioField = ({
  field,
  onChange,
  readOnly,
  value,
  name,
  id,
  label,
  labelIcon,
  Label: Label2
}) => {
  if (field.type !== "radio" || !field.options) {
    return null;
  }
  return (0, import_jsx_runtime16.jsx)(
    Label2,
    {
      icon: labelIcon || (0, import_jsx_runtime16.jsx)(CircleCheckBig, { size: 16 }),
      label: label || name,
      readOnly,
      el: "div",
      children: (0, import_jsx_runtime16.jsx)("div", { className: getClassName11("radioGroupItems"), id, children: field.options.map((option) => {
        var _a5;
        return (0, import_jsx_runtime16.jsxs)(
          "label",
          {
            className: getClassName11("radio"),
            children: [
              (0, import_jsx_runtime16.jsx)(
                "input",
                {
                  type: "radio",
                  className: getClassName11("radioInput"),
                  value: JSON.stringify({ value: option.value }),
                  name,
                  onChange: (e3) => {
                    onChange(JSON.parse(e3.target.value).value);
                  },
                  disabled: readOnly,
                  checked: value === option.value
                }
              ),
              (0, import_jsx_runtime16.jsx)("div", { className: getClassName11("radioInner"), children: option.label || ((_a5 = option.value) == null ? void 0 : _a5.toString()) })
            ]
          },
          option.label + option.value
        );
      }) })
    }
  );
};
init_react_import();
var getClassName12 = get_class_name_factory_default("Input", styles_module_default3);
var SelectField = ({
  field,
  onChange,
  label,
  labelIcon,
  Label: Label2,
  value,
  name,
  readOnly,
  id
}) => {
  if (field.type !== "select" || !field.options) {
    return null;
  }
  return (0, import_jsx_runtime17.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime17.jsx)(ChevronDown, { size: 16 }),
      readOnly,
      children: (0, import_jsx_runtime17.jsx)(
        "select",
        {
          id,
          title: label || name,
          className: getClassName12("input"),
          disabled: readOnly,
          onChange: (e3) => {
            onChange(JSON.parse(e3.target.value).value);
          },
          value: JSON.stringify({ value }),
          children: field.options.map((option) => (0, import_jsx_runtime17.jsx)(
            "option",
            {
              label: option.label,
              value: JSON.stringify({ value: option.value })
            },
            option.label + JSON.stringify(option.value)
          ))
        }
      )
    }
  );
};
init_react_import();
var getClassName13 = get_class_name_factory_default("Input", styles_module_default3);
var TextareaField = ({
  field,
  onChange,
  readOnly,
  value,
  name,
  label,
  labelIcon,
  Label: Label2,
  id
}) => {
  return (0, import_jsx_runtime18.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime18.jsx)(Type, { size: 16 }),
      readOnly,
      children: (0, import_jsx_runtime18.jsx)(
        "textarea",
        {
          id,
          className: getClassName13("input"),
          autoComplete: "off",
          name,
          value: typeof value === "undefined" ? "" : value,
          onChange: (e3) => onChange(e3.currentTarget.value),
          readOnly,
          tabIndex: readOnly ? -1 : void 0,
          rows: 5,
          placeholder: field.type === "textarea" ? field.placeholder : void 0
        }
      )
    }
  );
};
init_react_import();
init_react_import();
var styles_module_default9 = { "ObjectField": "_ObjectField_1ua3y_5", "ObjectField-fieldset": "_ObjectField-fieldset_1ua3y_13" };
var getClassName14 = get_class_name_factory_default("ObjectField", styles_module_default9);
var ObjectField = ({
  field,
  onChange,
  value,
  name,
  label,
  labelIcon,
  Label: Label2,
  readOnly,
  id
}) => {
  const { readOnlyFields, localName = name } = useNestedFieldContext();
  if (field.type !== "object" || !field.objectFields) {
    return null;
  }
  const data = value || {};
  return (0, import_jsx_runtime19.jsx)(
    Label2,
    {
      label: label || name,
      icon: labelIcon || (0, import_jsx_runtime19.jsx)(EllipsisVertical, { size: 16 }),
      el: "div",
      readOnly,
      children: (0, import_jsx_runtime19.jsx)("div", { className: getClassName14(), children: (0, import_jsx_runtime19.jsx)("fieldset", { className: getClassName14("fieldset"), children: Object.keys(field.objectFields).map((subName) => {
        const subField = field.objectFields[subName];
        const subPath = `${localName}.${subName}`;
        const subReadOnly = readOnly ? readOnly : readOnlyFields[subPath];
        const label2 = subField.label || subName;
        return (0, import_jsx_runtime19.jsx)(
          NestedFieldProvider,
          {
            name: localName || id,
            subName,
            readOnlyFields,
            children: (0, import_jsx_runtime19.jsx)(
              AutoFieldPrivate,
              {
                name: subPath,
                label: subPath,
                id: `${id}_${subName}`,
                readOnly: subReadOnly,
                field: __spreadProps(__spreadValues({}, subField), {
                  label: label2
                  // May be used by custom fields
                }),
                value: data[subName],
                onChange: (val, ui) => {
                  onChange(
                    __spreadProps(__spreadValues({}, data), {
                      [subName]: val
                    }),
                    ui
                  );
                }
              }
            )
          },
          subPath
        );
      }) }) })
    }
  );
};
init_react_import();
var useSafeId = () => {
  if (typeof import_react29.default.useId !== "undefined") {
    return import_react29.default.useId();
  }
  const [id] = (0, import_react29.useState)(generateId());
  return id;
};
var getClassName15 = get_class_name_factory_default("Input", styles_module_default3);
var getClassNameWrapper = get_class_name_factory_default("InputWrapper", styles_module_default3);
var FieldLabel = ({
  children,
  icon,
  label,
  el = "label",
  readOnly,
  className
}) => {
  const El = el;
  return (0, import_jsx_runtime20.jsxs)(El, { className, children: [
    (0, import_jsx_runtime20.jsxs)("div", { className: getClassName15("label"), children: [
      icon ? (0, import_jsx_runtime20.jsx)("div", { className: getClassName15("labelIcon"), children: icon }) : (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, {}),
      label,
      readOnly && (0, import_jsx_runtime20.jsx)("div", { className: getClassName15("disabledIcon"), title: "Read-only", children: (0, import_jsx_runtime20.jsx)(Lock, { size: "12" }) })
    ] }),
    children
  ] });
};
var FieldLabelInternal = ({
  children,
  icon,
  label,
  el = "label",
  readOnly
}) => {
  const overrides = useAppStore((s2) => s2.overrides);
  const Wrapper = (0, import_react18.useMemo)(
    () => overrides.fieldLabel || FieldLabel,
    [overrides]
  );
  if (!label) {
    return (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, { children });
  }
  return (0, import_jsx_runtime20.jsx)(
    Wrapper,
    {
      label,
      icon,
      className: getClassName15({ readOnly }),
      readOnly,
      el,
      children
    }
  );
};
var defaultFields = {
  array: ArrayField,
  external: ExternalField,
  object: ObjectField,
  select: SelectField,
  textarea: TextareaField,
  radio: RadioField,
  text: DefaultField,
  number: DefaultField
};
function AutoFieldInternal(props) {
  var _a5;
  const dispatch = useAppStore((s2) => s2.dispatch);
  const overrides = useAppStore((s2) => s2.overrides);
  const readOnly = useAppStore((s2) => {
    var _a23;
    return (_a23 = s2.selectedItem) == null ? void 0 : _a23.readOnly;
  });
  const nestedFieldContext = (0, import_react18.useContext)(NestedFieldContext);
  const { id, Label: Label2 = FieldLabelInternal } = props;
  const field = props.field;
  const label = field.label;
  const labelIcon = field.labelIcon;
  const defaultId = useSafeId();
  const resolvedId = id || defaultId;
  const render = (0, import_react18.useMemo)(
    () => {
      var _a23, _b3, _c4, _d2, _e, _f, _g, _h;
      return __spreadProps(__spreadValues({}, overrides.fieldTypes), {
        array: ((_a23 = overrides.fieldTypes) == null ? void 0 : _a23.array) || defaultFields.array,
        external: ((_b3 = overrides.fieldTypes) == null ? void 0 : _b3.external) || defaultFields.external,
        object: ((_c4 = overrides.fieldTypes) == null ? void 0 : _c4.object) || defaultFields.object,
        select: ((_d2 = overrides.fieldTypes) == null ? void 0 : _d2.select) || defaultFields.select,
        textarea: ((_e = overrides.fieldTypes) == null ? void 0 : _e.textarea) || defaultFields.textarea,
        radio: ((_f = overrides.fieldTypes) == null ? void 0 : _f.radio) || defaultFields.radio,
        text: ((_g = overrides.fieldTypes) == null ? void 0 : _g.text) || defaultFields.text,
        number: ((_h = overrides.fieldTypes) == null ? void 0 : _h.number) || defaultFields.number
      });
    },
    [overrides]
  );
  const mergedProps = (0, import_react18.useMemo)(
    () => __spreadProps(__spreadValues({}, props), {
      field,
      label,
      labelIcon,
      Label: Label2,
      id: resolvedId
    }),
    [props, field, label, labelIcon, Label2, resolvedId]
  );
  const onFocus = (0, import_react18.useCallback)(
    (e3) => {
      if (mergedProps.name && (e3.target.nodeName === "INPUT" || e3.target.nodeName === "TEXTAREA")) {
        e3.stopPropagation();
        dispatch({
          type: "setUi",
          ui: {
            field: { focus: mergedProps.name }
          }
        });
      }
    },
    [mergedProps.name]
  );
  const onBlur = (0, import_react18.useCallback)((e3) => {
    if ("name" in e3.target) {
      dispatch({
        type: "setUi",
        ui: {
          field: { focus: null }
        }
      });
    }
  }, []);
  let Children = (0, import_react18.useMemo)(() => {
    if (field.type !== "custom" && field.type !== "slot") {
      return defaultFields[field.type];
    }
    return (_props) => null;
  }, [field.type]);
  let FieldComponent = (0, import_react18.useMemo)(() => {
    if (field.type === "custom") {
      if (!field.render) {
        return null;
      }
      return field.render;
    } else if (field.type !== "slot") {
      return render[field.type];
    }
  }, [field.type, render]);
  const { visible = true } = props.field;
  if (!visible) {
    return null;
  }
  if (field.type === "slot") {
    return null;
  }
  if (!FieldComponent) {
    throw new Error(`Field type for ${field.type} did not exist.`);
  }
  return (0, import_jsx_runtime20.jsx)(
    NestedFieldContext.Provider,
    {
      value: {
        readOnlyFields: nestedFieldContext.readOnlyFields || readOnly || {},
        localName: (_a5 = nestedFieldContext.localName) != null ? _a5 : mergedProps.name
      },
      children: (0, import_jsx_runtime20.jsx)(
        "div",
        {
          className: getClassNameWrapper(),
          onFocus,
          onBlur,
          onClick: (e3) => {
            e3.stopPropagation();
          },
          children: (0, import_jsx_runtime20.jsx)(FieldComponent, __spreadProps(__spreadValues({}, mergedProps), { children: (0, import_jsx_runtime20.jsx)(Children, __spreadValues({}, mergedProps)) }))
        }
      )
    }
  );
}
function AutoFieldPrivate(props) {
  const isFocused = useAppStore((s2) => s2.state.ui.field.focus === props.name);
  const { value, onChange } = props;
  const [localValue, setLocalValue] = (0, import_react18.useState)(value);
  const onChangeLocal = (0, import_react18.useCallback)(
    (val, ui) => {
      setLocalValue(val);
      onChange(val, ui);
    },
    [onChange]
  );
  (0, import_react18.useEffect)(() => {
    if (!isFocused) {
      setLocalValue(value);
    }
  }, [value]);
  (0, import_react18.useEffect)(() => {
    if (!isFocused) {
      if (value !== localValue) {
        setLocalValue(value);
      }
    }
  }, [isFocused, value, localValue]);
  const localProps = {
    value: localValue,
    onChange: onChangeLocal
  };
  return (0, import_jsx_runtime20.jsx)(AutoFieldInternal, __spreadValues(__spreadValues({}, props), localProps));
}
function AutoField(props) {
  const DefaultLabel = (0, import_react18.useMemo)(() => {
    const DefaultLabel2 = (labelProps) => (0, import_jsx_runtime20.jsx)(
      "div",
      __spreadProps(__spreadValues({}, labelProps), {
        className: getClassName15({ readOnly: props.readOnly })
      })
    );
    return DefaultLabel2;
  }, [props.readOnly]);
  if (props.field.type === "slot") {
    return null;
  }
  return (0, import_jsx_runtime20.jsx)(AutoFieldInternal, __spreadProps(__spreadValues({}, props), { Label: DefaultLabel }));
}
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default10 = { "DraggableComponent": "_DraggableComponent_1vaqy_1", "DraggableComponent-overlayWrapper": "_DraggableComponent-overlayWrapper_1vaqy_12", "DraggableComponent-overlay": "_DraggableComponent-overlay_1vaqy_12", "DraggableComponent-loadingOverlay": "_DraggableComponent-loadingOverlay_1vaqy_34", "DraggableComponent--hover": "_DraggableComponent--hover_1vaqy_50", "DraggableComponent--isSelected": "_DraggableComponent--isSelected_1vaqy_57", "DraggableComponent-actionsOverlay": "_DraggableComponent-actionsOverlay_1vaqy_71", "DraggableComponent-actions": "_DraggableComponent-actions_1vaqy_71" };
init_react_import();
function getDeepScrollPosition(element) {
  let totalScroll = {
    x: 0,
    y: 0
  };
  let current = element;
  while (current && current !== document.documentElement) {
    const parent = current.parentElement;
    if (parent) {
      totalScroll.x += parent.scrollLeft;
      totalScroll.y += parent.scrollTop;
    }
    current = parent;
  }
  return totalScroll;
}
init_react_import();
var dropZoneContext = (0, import_react32.createContext)(null);
var ZoneStoreContext = (0, import_react32.createContext)(
  createStore(() => ({
    zoneDepthIndex: {},
    nextZoneDepthIndex: {},
    areaDepthIndex: {},
    nextAreaDepthIndex: {},
    draggedItem: null,
    previewIndex: {},
    enabledIndex: {},
    hoveringComponent: null
  }))
);
var ZoneStoreProvider = ({
  children,
  store: store2
}) => {
  return (0, import_jsx_runtime21.jsx)(ZoneStoreContext.Provider, { value: store2, children });
};
var DropZoneProvider = ({
  children,
  value
}) => {
  const dispatch = useAppStore((s2) => s2.dispatch);
  const registerZone = (0, import_react32.useCallback)(
    (zoneCompound) => {
      dispatch({
        type: "registerZone",
        zone: zoneCompound
      });
    },
    [dispatch]
  );
  const memoValue = (0, import_react32.useMemo)(
    () => __spreadValues({
      registerZone
    }, value),
    [value]
  );
  return (0, import_jsx_runtime21.jsx)(import_jsx_runtime21.Fragment, { children: memoValue && (0, import_jsx_runtime21.jsx)(dropZoneContext.Provider, { value: memoValue, children }) });
};
init_react_import();
function accumulateTransform(el) {
  let matrix = new DOMMatrixReadOnly();
  let n3 = el.parentElement;
  while (n3 && n3 !== document.documentElement) {
    const t3 = getComputedStyle(n3).transform;
    if (t3 && t3 !== "none") {
      matrix = new DOMMatrixReadOnly(t3).multiply(matrix);
    }
    n3 = n3.parentElement;
  }
  return { scaleX: matrix.a, scaleY: matrix.d };
}
init_react_import();
function useContextStore(context, selector) {
  const store2 = (0, import_react33.useContext)(context);
  if (!store2) {
    throw new Error("useContextStore must be used inside context");
  }
  return useStore(store2, useShallow(selector));
}
init_react_import();
var useOnDragFinished = (cb, deps = []) => {
  const appStore = useAppStoreApi();
  return (0, import_react34.useCallback)(() => {
    let dispose = () => {
    };
    const processDragging = (isDragging2) => {
      if (isDragging2) {
        cb(false);
      } else {
        setTimeout(() => {
          cb(true);
        }, 0);
        if (dispose)
          dispose();
      }
    };
    const isDragging = appStore.getState().state.ui.isDragging;
    processDragging(isDragging);
    if (isDragging) {
      dispose = appStore.subscribe(
        (s2) => s2.state.ui.isDragging,
        (isDragging2) => {
          processDragging(isDragging2);
        }
      );
    }
    return dispose;
  }, [appStore, ...deps]);
};
var getClassName16 = get_class_name_factory_default("DraggableComponent", styles_module_default10);
var DEBUG2 = false;
var space = 8;
var actionsOverlayTop = space * 6.5;
var actionsTop = -(actionsOverlayTop - 8);
var actionsSide = space;
var DefaultActionBar = ({
  label,
  children,
  parentAction
}) => (0, import_jsx_runtime22.jsxs)(ActionBar, { children: [
  (0, import_jsx_runtime22.jsxs)(ActionBar.Group, { children: [
    parentAction,
    label && (0, import_jsx_runtime22.jsx)(ActionBar.Label, { label })
  ] }),
  (0, import_jsx_runtime22.jsx)(ActionBar.Group, { children })
] });
var DefaultOverlay = ({
  children
}) => (0, import_jsx_runtime22.jsx)(import_jsx_runtime22.Fragment, { children });
var DraggableComponent = ({
  children,
  depth,
  componentType,
  id,
  index,
  zoneCompound,
  isLoading = false,
  isSelected = false,
  debug,
  label,
  autoDragAxis,
  userDragAxis,
  inDroppableZone = true
}) => {
  const zoom = useAppStore(
    (s2) => {
      var _a5;
      return ((_a5 = s2.selectedItem) == null ? void 0 : _a5.props.id) === id ? s2.zoomConfig.zoom : 1;
    }
  );
  const overrides = useAppStore((s2) => s2.overrides);
  const dispatch = useAppStore((s2) => s2.dispatch);
  const iframe = useAppStore((s2) => s2.iframe);
  const ctx = (0, import_react31.useContext)(dropZoneContext);
  const [localZones, setLocalZones] = (0, import_react31.useState)({});
  const registerLocalZone = (0, import_react31.useCallback)(
    (zoneCompound2, active) => {
      var _a5;
      (_a5 = ctx == null ? void 0 : ctx.registerLocalZone) == null ? void 0 : _a5.call(ctx, zoneCompound2, active);
      setLocalZones((obj) => __spreadProps(__spreadValues({}, obj), {
        [zoneCompound2]: active
      }));
    },
    [setLocalZones]
  );
  const unregisterLocalZone = (0, import_react31.useCallback)(
    (zoneCompound2) => {
      var _a5;
      (_a5 = ctx == null ? void 0 : ctx.unregisterLocalZone) == null ? void 0 : _a5.call(ctx, zoneCompound2);
      setLocalZones((obj) => {
        const newLocalZones = __spreadValues({}, obj);
        delete newLocalZones[zoneCompound2];
        return newLocalZones;
      });
    },
    [setLocalZones]
  );
  const containsActiveZone = Object.values(localZones).filter(Boolean).length > 0;
  const path = useAppStore(useShallow((s2) => {
    var _a5;
    return (_a5 = s2.state.indexes.nodes[id]) == null ? void 0 : _a5.path;
  }));
  const permissions = useAppStore(
    useShallow((s2) => {
      const item = getItem({ index, zone: zoneCompound }, s2.state);
      return s2.permissions.getPermissions({ item });
    })
  );
  const zoneStore = (0, import_react31.useContext)(ZoneStoreContext);
  const [dragAxis, setDragAxis] = (0, import_react31.useState)(userDragAxis || autoDragAxis);
  const dynamicCollisionDetector = (0, import_react31.useMemo)(
    () => createDynamicCollisionDetector(dragAxis),
    [dragAxis]
  );
  const {
    ref: sortableRef,
    isDragging: thisIsDragging,
    sortable
  } = useSortable({
    id,
    index,
    group: zoneCompound,
    type: "component",
    data: {
      areaId: ctx == null ? void 0 : ctx.areaId,
      zone: zoneCompound,
      index,
      componentType,
      containsActiveZone,
      depth,
      path: path || [],
      inDroppableZone
    },
    collisionPriority: depth,
    collisionDetector: dynamicCollisionDetector,
    // "Out of the way" transition from react-beautiful-dnd
    transition: {
      duration: 200,
      easing: "cubic-bezier(0.2, 0, 0, 1)"
    },
    feedback: "clone"
  });
  (0, import_react31.useEffect)(() => {
    const isEnabled = zoneStore.getState().enabledIndex[zoneCompound];
    sortable.droppable.disabled = !isEnabled;
    sortable.draggable.disabled = !permissions.drag;
    const cleanup = zoneStore.subscribe((s2) => {
      sortable.droppable.disabled = !s2.enabledIndex[zoneCompound];
    });
    if (ref.current && !permissions.drag) {
      ref.current.setAttribute("data-puck-disabled", "");
      return () => {
        var _a5;
        (_a5 = ref.current) == null ? void 0 : _a5.removeAttribute("data-puck-disabled");
        cleanup();
      };
    }
    return cleanup;
  }, [permissions.drag, zoneCompound]);
  const ref = (0, import_react31.useRef)(null);
  const refSetter = (0, import_react31.useCallback)(
    (el) => {
      sortableRef(el);
      if (el) {
        ref.current = el;
      }
    },
    [sortableRef]
  );
  const [portalEl, setPortalEl] = (0, import_react31.useState)();
  (0, import_react31.useEffect)(() => {
    var _a5, _b3, _c4;
    setPortalEl(
      iframe.enabled ? (_a5 = ref.current) == null ? void 0 : _a5.ownerDocument.body : (_c4 = (_b3 = ref.current) == null ? void 0 : _b3.closest("[data-puck-preview]")) != null ? _c4 : document.body
    );
  }, [iframe.enabled, ref.current]);
  const getStyle = (0, import_react31.useCallback)(() => {
    var _a5, _b3, _c4;
    if (!ref.current)
      return;
    const rect = ref.current.getBoundingClientRect();
    const deepScrollPosition = getDeepScrollPosition(ref.current);
    const portalContainerEl = iframe.enabled ? null : (_a5 = ref.current) == null ? void 0 : _a5.closest("[data-puck-preview]");
    const portalContainerRect = portalContainerEl == null ? void 0 : portalContainerEl.getBoundingClientRect();
    const portalScroll = portalContainerEl ? getDeepScrollPosition(portalContainerEl) : { x: 0, y: 0 };
    const scroll = {
      x: deepScrollPosition.x - portalScroll.x - ((_b3 = portalContainerRect == null ? void 0 : portalContainerRect.left) != null ? _b3 : 0),
      y: deepScrollPosition.y - portalScroll.y - ((_c4 = portalContainerRect == null ? void 0 : portalContainerRect.top) != null ? _c4 : 0)
    };
    const untransformed = {
      height: ref.current.offsetHeight,
      width: ref.current.offsetWidth
    };
    const transform = accumulateTransform(ref.current);
    const style2 = {
      left: `${(rect.left + scroll.x) / transform.scaleX}px`,
      top: `${(rect.top + scroll.y) / transform.scaleY}px`,
      height: `${untransformed.height}px`,
      width: `${untransformed.width}px`
    };
    return style2;
  }, [ref.current]);
  const [style, setStyle] = (0, import_react31.useState)();
  const sync = (0, import_react31.useCallback)(() => {
    setStyle(getStyle());
  }, [ref.current, iframe]);
  (0, import_react31.useEffect)(() => {
    if (ref.current) {
      const observer = new ResizeObserver(sync);
      observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [ref.current]);
  const registerNode = useAppStore((s2) => s2.nodes.registerNode);
  const hideOverlay = (0, import_react31.useCallback)(() => {
    setIsVisible(false);
  }, []);
  const showOverlay = (0, import_react31.useCallback)(() => {
    setIsVisible(true);
  }, []);
  (0, import_react31.useEffect)(() => {
    var _a5;
    registerNode(id, {
      methods: { sync, showOverlay, hideOverlay },
      element: (_a5 = ref.current) != null ? _a5 : null
    });
    return () => {
      registerNode(id, {
        methods: {
          sync: () => null,
          hideOverlay: () => null,
          showOverlay: () => null
        },
        element: null
      });
    };
  }, [id, zoneCompound, index, componentType, sync]);
  const CustomActionBar = (0, import_react31.useMemo)(
    () => overrides.actionBar || DefaultActionBar,
    [overrides.actionBar]
  );
  const CustomOverlay = (0, import_react31.useMemo)(
    () => overrides.componentOverlay || DefaultOverlay,
    [overrides.componentOverlay]
  );
  const onClick = (0, import_react31.useCallback)(
    (e3) => {
      const el = e3.target;
      if (!el.closest("[data-puck-overlay-portal]")) {
        e3.stopPropagation();
      }
      dispatch({
        type: "setUi",
        ui: {
          itemSelector: { index, zone: zoneCompound }
        }
      });
    },
    [index, zoneCompound, id]
  );
  const appStore = useAppStoreApi();
  const onSelectParent = (0, import_react31.useCallback)(() => {
    const { nodes, zones } = appStore.getState().state.indexes;
    const node = nodes[id];
    const parentNode = (node == null ? void 0 : node.parentId) ? nodes[node == null ? void 0 : node.parentId] : null;
    if (!parentNode || !node.parentId) {
      return;
    }
    const parentZoneCompound = `${parentNode.parentId}:${parentNode.zone}`;
    const parentIndex = zones[parentZoneCompound].contentIds.indexOf(
      node.parentId
    );
    dispatch({
      type: "setUi",
      ui: {
        itemSelector: {
          zone: parentZoneCompound,
          index: parentIndex
        }
      }
    });
  }, [ctx, path]);
  const onDuplicate = (0, import_react31.useCallback)(() => {
    dispatch({
      type: "duplicate",
      sourceIndex: index,
      sourceZone: zoneCompound
    });
  }, [index, zoneCompound]);
  const onDelete = (0, import_react31.useCallback)(() => {
    dispatch({
      type: "remove",
      index,
      zone: zoneCompound
    });
  }, [index, zoneCompound]);
  const [hover, setHover] = (0, import_react31.useState)(false);
  const indicativeHover = useContextStore(
    ZoneStoreContext,
    (s2) => s2.hoveringComponent === id
  );
  (0, import_react31.useEffect)(() => {
    if (!ref.current) {
      return;
    }
    const el = ref.current;
    const _onMouseOver = (e3) => {
      const userIsDragging = !!zoneStore.getState().draggedItem;
      if (userIsDragging) {
        if (thisIsDragging) {
          setHover(true);
        } else {
          setHover(false);
        }
      } else {
        setHover(true);
      }
      e3.stopPropagation();
    };
    const _onMouseOut = (e3) => {
      e3.stopPropagation();
      setHover(false);
    };
    el.setAttribute("data-puck-component", id);
    el.setAttribute("data-puck-dnd", id);
    el.style.position = "relative";
    el.addEventListener("click", onClick);
    el.addEventListener("mouseover", _onMouseOver);
    el.addEventListener("mouseout", _onMouseOut);
    return () => {
      el.removeAttribute("data-puck-component");
      el.removeAttribute("data-puck-dnd");
      el.removeEventListener("click", onClick);
      el.removeEventListener("mouseover", _onMouseOver);
      el.removeEventListener("mouseout", _onMouseOut);
    };
  }, [
    ref.current,
    // Remount attributes if the element changes
    onClick,
    containsActiveZone,
    zoneCompound,
    id,
    thisIsDragging,
    inDroppableZone
  ]);
  const [isVisible2, setIsVisible] = (0, import_react31.useState)(false);
  const [dragFinished, setDragFinished] = (0, import_react31.useState)(true);
  const [_2, startTransition2] = (0, import_react31.useTransition)();
  (0, import_react31.useEffect)(() => {
    startTransition2(() => {
      if (hover || indicativeHover || isSelected) {
        sync();
        setIsVisible(true);
        setThisWasDragging(false);
      } else {
        setIsVisible(false);
      }
    });
  }, [hover, indicativeHover, isSelected, iframe]);
  const [thisWasDragging, setThisWasDragging] = (0, import_react31.useState)(false);
  const onDragFinished = useOnDragFinished((finished) => {
    if (finished) {
      startTransition2(() => {
        sync();
        setDragFinished(true);
      });
    } else {
      setDragFinished(false);
    }
  });
  (0, import_react31.useEffect)(() => {
    if (thisIsDragging) {
      setThisWasDragging(true);
    }
  }, [thisIsDragging]);
  (0, import_react31.useEffect)(() => {
    if (thisWasDragging)
      return onDragFinished();
  }, [thisWasDragging, onDragFinished]);
  const syncActionsPosition = (0, import_react31.useCallback)(
    (el) => {
      if (el) {
        const view = el.ownerDocument.defaultView;
        if (view) {
          const rect = el.getBoundingClientRect();
          const diffLeft = rect.x;
          const exceedsBoundsLeft = diffLeft < 0;
          const diffTop = rect.y;
          const exceedsBoundsTop = diffTop < 0;
          if (exceedsBoundsLeft) {
            el.style.transformOrigin = "left top";
            el.style.left = "0px";
          }
          if (exceedsBoundsTop) {
            el.style.top = "12px";
            if (!exceedsBoundsLeft) {
              el.style.transformOrigin = "right top";
            }
          }
        }
      }
    },
    [zoom]
  );
  (0, import_react31.useEffect)(() => {
    if (userDragAxis) {
      setDragAxis(userDragAxis);
      return;
    }
    if (ref.current) {
      const computedStyle = window.getComputedStyle(ref.current);
      if (computedStyle.display === "inline" || computedStyle.display === "inline-block") {
        setDragAxis("x");
        return;
      }
    }
    setDragAxis(autoDragAxis);
  }, [ref, userDragAxis, autoDragAxis]);
  const parentAction = (0, import_react31.useMemo)(
    () => (ctx == null ? void 0 : ctx.areaId) && (ctx == null ? void 0 : ctx.areaId) !== "root" && (0, import_jsx_runtime22.jsx)(ActionBar.Action, { onClick: onSelectParent, label: "Select parent", children: (0, import_jsx_runtime22.jsx)(CornerLeftUp, { size: 16 }) }),
    [ctx == null ? void 0 : ctx.areaId]
  );
  const nextContextValue = (0, import_react31.useMemo)(
    () => __spreadProps(__spreadValues({}, ctx), {
      areaId: id,
      zoneCompound,
      index,
      depth: depth + 1,
      registerLocalZone,
      unregisterLocalZone
    }),
    [
      ctx,
      id,
      zoneCompound,
      index,
      depth,
      registerLocalZone,
      unregisterLocalZone
    ]
  );
  return (0, import_jsx_runtime22.jsxs)(DropZoneProvider, { value: nextContextValue, children: [
    dragFinished && isVisible2 && (0, import_react_dom3.createPortal)(
      (0, import_jsx_runtime22.jsxs)(
        "div",
        {
          className: getClassName16({
            isSelected,
            isDragging: thisIsDragging,
            hover: hover || indicativeHover
          }),
          style: __spreadValues({}, style),
          "data-puck-overlay": true,
          children: [
            debug,
            isLoading && (0, import_jsx_runtime22.jsx)("div", { className: getClassName16("loadingOverlay"), children: (0, import_jsx_runtime22.jsx)(Loader, {}) }),
            (0, import_jsx_runtime22.jsx)(
              "div",
              {
                className: getClassName16("actionsOverlay"),
                style: {
                  top: actionsOverlayTop / zoom
                },
                children: (0, import_jsx_runtime22.jsx)(
                  "div",
                  {
                    className: getClassName16("actions"),
                    style: {
                      transform: `scale(${1 / zoom}`,
                      top: actionsTop / zoom,
                      right: 0,
                      paddingLeft: actionsSide,
                      paddingRight: actionsSide
                    },
                    ref: syncActionsPosition,
                    children: (0, import_jsx_runtime22.jsxs)(
                      CustomActionBar,
                      {
                        parentAction,
                        label: DEBUG2 ? id : label,
                        children: [
                          permissions.duplicate && (0, import_jsx_runtime22.jsx)(ActionBar.Action, { onClick: onDuplicate, label: "Duplicate", children: (0, import_jsx_runtime22.jsx)(Copy, { size: 16 }) }),
                          permissions.delete && (0, import_jsx_runtime22.jsx)(ActionBar.Action, { onClick: onDelete, label: "Delete", children: (0, import_jsx_runtime22.jsx)(Trash, { size: 16 }) })
                        ]
                      }
                    )
                  }
                )
              }
            ),
            (0, import_jsx_runtime22.jsx)("div", { className: getClassName16("overlayWrapper"), children: (0, import_jsx_runtime22.jsx)(
              CustomOverlay,
              {
                componentId: id,
                componentType,
                hover,
                isSelected,
                children: (0, import_jsx_runtime22.jsx)("div", { className: getClassName16("overlay") })
              }
            ) })
          ]
        }
      ),
      portalEl || document.body
    ),
    children(refSetter)
  ] });
};
init_react_import();
var styles_module_default11 = { "DropZone": "_DropZone_1i2sv_1", "DropZone--hasChildren": "_DropZone--hasChildren_1i2sv_11", "DropZone--isAreaSelected": "_DropZone--isAreaSelected_1i2sv_24", "DropZone--hoveringOverArea": "_DropZone--hoveringOverArea_1i2sv_25", "DropZone--isRootZone": "_DropZone--isRootZone_1i2sv_25", "DropZone--isDestination": "_DropZone--isDestination_1i2sv_35", "DropZone-item": "_DropZone-item_1i2sv_47", "DropZone-hitbox": "_DropZone-hitbox_1i2sv_51", "DropZone--isEnabled": "_DropZone--isEnabled_1i2sv_59", "DropZone--isAnimating": "_DropZone--isAnimating_1i2sv_68" };
init_react_import();
init_react_import();
var styles_module_default12 = { "Drawer": "_Drawer_pl7z0_1", "Drawer-draggable": "_Drawer-draggable_pl7z0_8", "Drawer-draggableBg": "_Drawer-draggableBg_pl7z0_12", "DrawerItem-draggable": "_DrawerItem-draggable_pl7z0_22", "DrawerItem--disabled": "_DrawerItem--disabled_pl7z0_35", "DrawerItem": "_DrawerItem_pl7z0_22", "Drawer--isDraggingFrom": "_Drawer--isDraggingFrom_pl7z0_45", "DrawerItem-name": "_DrawerItem-name_pl7z0_63" };
init_react_import();
init_react_import();
init_react_import();
function timeout22(callback, duration) {
  const id = setTimeout(callback, duration);
  return () => clearTimeout(id);
}
function throttle2(func, limit) {
  const time = () => performance.now();
  let cancel;
  let lastRan = 0;
  return function(...args) {
    const now = time();
    const context = this;
    if (now - lastRan >= limit) {
      func.apply(context, args);
      lastRan = now;
    } else {
      cancel == null ? void 0 : cancel();
      cancel = timeout22(() => {
        func.apply(context, args);
        lastRan = time();
      }, limit - (now - lastRan));
    }
  };
}
init_react_import();
var getFrame = () => {
  if (typeof window === "undefined")
    return;
  let frameEl = document.querySelector("#preview-frame");
  if ((frameEl == null ? void 0 : frameEl.tagName) === "IFRAME") {
    return frameEl.contentDocument || document;
  }
  return (frameEl == null ? void 0 : frameEl.ownerDocument) || document;
};
init_react_import();
var GlobalPosition = class {
  constructor(target, original) {
    this.scaleFactor = 1;
    this.frameEl = null;
    this.frameRect = null;
    var _a5;
    this.target = target;
    this.original = original;
    this.frameEl = document.querySelector("iframe#preview-frame");
    if (this.frameEl) {
      this.frameRect = this.frameEl.getBoundingClientRect();
      this.scaleFactor = this.frameRect.width / (((_a5 = this.frameEl.contentWindow) == null ? void 0 : _a5.innerWidth) || 1);
    }
  }
  get x() {
    return this.original.x;
  }
  get y() {
    return this.original.y;
  }
  get global() {
    if (document !== this.target.ownerDocument && this.frameRect) {
      return {
        x: this.x * this.scaleFactor + this.frameRect.left,
        y: this.y * this.scaleFactor + this.frameRect.top
      };
    }
    return this.original;
  }
  get frame() {
    if (document === this.target.ownerDocument && this.frameRect) {
      return {
        x: (this.x - this.frameRect.left) / this.scaleFactor,
        y: (this.y - this.frameRect.top) / this.scaleFactor
      };
    }
    return this.original;
  }
};
init_react_import();
var BaseEvent = typeof PointerEvent !== "undefined" ? PointerEvent : Event;
var BubbledPointerEvent = class extends BaseEvent {
  constructor(type, data) {
    super(type, data);
    this._originalTarget = null;
    this.originalTarget = data.originalTarget;
  }
  // Necessary for Firefox
  set originalTarget(target) {
    this._originalTarget = target;
  }
  // Necessary for Firefox
  get originalTarget() {
    return this._originalTarget;
  }
};
var depthSort = (candidates) => {
  return candidates.sort((a2, b2) => {
    const aData = a2.data;
    const bData = b2.data;
    if (aData.depth > bData.depth) {
      return 1;
    }
    if (bData.depth > aData.depth) {
      return -1;
    }
    return 0;
  });
};
var getZoneId2 = (candidate) => {
  let id = candidate == null ? void 0 : candidate.id;
  if (!candidate)
    return null;
  if (candidate.type === "component") {
    const data = candidate.data;
    if (data.containsActiveZone) {
      id = null;
    } else {
      id = data.zone;
    }
  } else if (candidate.type === "void") {
    return "void";
  }
  return id;
};
var BUFFER = 6;
var getPointerCollisions = (position, manager) => {
  const candidates = [];
  let elements = position.target.ownerDocument.elementsFromPoint(
    position.x,
    position.y
  );
  const previewFrame = elements.find(
    (el) => el.getAttribute("data-puck-preview")
  );
  const drawer = elements.find((el) => el.getAttribute("data-puck-drawer"));
  if (drawer) {
    elements = [drawer];
  }
  if (previewFrame) {
    const frame = getFrame();
    if (frame) {
      elements = frame.elementsFromPoint(position.frame.x, position.frame.y);
    }
  }
  if (elements) {
    for (let i2 = 0; i2 < elements.length; i2++) {
      const element = elements[i2];
      const dropzoneId = element.getAttribute("data-puck-dropzone");
      const id = element.getAttribute("data-puck-dnd");
      const isVoid = element.hasAttribute("data-puck-dnd-void");
      if (BUFFER && (dropzoneId || id) && !isVoid) {
        const box = element.getBoundingClientRect();
        const contractedBox = {
          left: box.left + BUFFER,
          right: box.right - BUFFER,
          top: box.top + BUFFER,
          bottom: box.bottom - BUFFER
        };
        if (position.frame.x < contractedBox.left || position.frame.x > contractedBox.right || position.frame.y > contractedBox.bottom || position.frame.y < contractedBox.top) {
          continue;
        }
      }
      if (dropzoneId) {
        const droppable = manager.registry.droppables.get(dropzoneId);
        if (droppable) {
          candidates.push(droppable);
        }
      }
      if (id) {
        const droppable = manager.registry.droppables.get(id);
        if (droppable) {
          candidates.push(droppable);
        }
      }
    }
  }
  return candidates;
};
var findDeepestCandidate = (position, manager) => {
  var _a5;
  const candidates = getPointerCollisions(position, manager);
  if (candidates.length > 0) {
    const sortedCandidates = depthSort(candidates);
    const draggable = manager.dragOperation.source;
    const draggedCandidateIndex = sortedCandidates.findIndex(
      (candidate) => candidate.id === (draggable == null ? void 0 : draggable.id)
    );
    const draggedCandidateId = draggable == null ? void 0 : draggable.id;
    let filteredCandidates = [...sortedCandidates];
    if (draggedCandidateId && draggedCandidateIndex > -1) {
      filteredCandidates.splice(draggedCandidateIndex, 1);
    }
    filteredCandidates = filteredCandidates.filter((candidate) => {
      const candidateData = candidate.data;
      if (draggedCandidateId && draggedCandidateIndex > -1) {
        if (candidateData.path.indexOf(draggedCandidateId) > -1) {
          return false;
        }
      }
      if (candidate.type === "dropzone") {
        const candidateData2 = candidate.data;
        if (!candidateData2.isDroppableTarget) {
          return false;
        }
        if (candidateData2.areaId === draggedCandidateId) {
          return false;
        }
      } else if (candidate.type === "component") {
        const candidateData2 = candidate.data;
        if (!candidateData2.inDroppableZone) {
          return false;
        }
      }
      return true;
    });
    filteredCandidates.reverse();
    const primaryCandidate = filteredCandidates[0];
    if (!primaryCandidate)
      return { zone: null, area: null };
    const primaryCandidateData = primaryCandidate.data;
    const primaryCandidateIsComponent = "containsActiveZone" in primaryCandidateData;
    const zone = getZoneId2(primaryCandidate);
    const area = primaryCandidateIsComponent && primaryCandidateData.containsActiveZone ? filteredCandidates[0].id : (_a5 = filteredCandidates[0]) == null ? void 0 : _a5.data.areaId;
    return { zone, area };
  }
  return {
    zone: rootDroppableId,
    area: rootAreaId
  };
};
var createNestedDroppablePlugin = ({ onChange }, id) => class NestedDroppablePlugin extends Plugin {
  constructor(manager, options2) {
    super(manager);
    if (typeof window === "undefined") {
      return;
    }
    this.registerEffect(() => {
      const handleMove = (event) => {
        const target = event instanceof BubbledPointerEvent ? event.originalTarget || event.target : event.target;
        const position = new GlobalPosition(target, {
          x: event.clientX,
          y: event.clientY
        });
        const elements = document.elementsFromPoint(
          position.global.x,
          position.global.y
        );
        const overEl = elements.some((el) => el.id === id);
        if (overEl) {
          onChange(findDeepestCandidate(position, manager), manager);
        }
      };
      const handleMoveThrottled = throttle2(handleMove, 50);
      const handlePointerMove = (event) => {
        handleMoveThrottled(event);
      };
      document.body.addEventListener("pointermove", handlePointerMove, {
        capture: true
        // dndkit's PointerSensor prevents propagation during drag
      });
      const cleanup = () => {
        document.body.removeEventListener("pointermove", handlePointerMove, {
          capture: true
        });
      };
      return cleanup;
    });
  }
};
init_react_import();
var insertComponent = (componentType, zone, index, appStore) => __async(void 0, null, function* () {
  const id = generateId(componentType);
  const insertActionData = {
    type: "insert",
    componentType,
    destinationIndex: index,
    destinationZone: zone,
    id
  };
  const { state, dispatch, resolveComponentData: resolveComponentData2 } = appStore;
  const insertedState = insertAction(state, insertActionData, appStore);
  dispatch(__spreadProps(__spreadValues({}, insertActionData), {
    // Dispatch insert rather set, as user's may rely on this via onAction
    // We must always record history here so the insert is added to user history
    // If the user has defined a resolveData method, they will end up with 2 history
    // entries on insert - one for the initial insert, and one when the data resolves
    recordHistory: true
  }));
  const itemSelector = {
    index,
    zone
  };
  dispatch({ type: "setUi", ui: { itemSelector } });
  const itemData = getItem(itemSelector, insertedState);
  if (itemData) {
    const resolved = yield resolveComponentData2(itemData, "insert");
    if (resolved.didChange) {
      dispatch({
        type: "replace",
        destinationZone: itemSelector.zone,
        destinationIndex: itemSelector.index,
        data: resolved.node
      });
    }
  }
});
init_react_import();
function getDeepDir(el) {
  function findDir(node) {
    if (!node)
      return "ltr";
    const d2 = node.getAttribute("dir");
    return d2 || findDir(node.parentElement);
  }
  return el ? findDir(el) : "ltr";
}
var DEBUG3 = false;
var dragListenerContext = (0, import_react38.createContext)({
  dragListeners: {}
});
function useDragListener(type, fn, deps = []) {
  const { setDragListeners } = (0, import_react38.useContext)(dragListenerContext);
  (0, import_react38.useEffect)(() => {
    if (setDragListeners) {
      setDragListeners((old) => __spreadProps(__spreadValues({}, old), {
        [type]: [...old[type] || [], fn]
      }));
    }
  }, deps);
}
var AREA_CHANGE_DEBOUNCE_MS = 100;
var useTempDisableFallback = (timeout3) => {
  const lastFallbackDisable = (0, import_react38.useRef)(null);
  return (0, import_react38.useCallback)((manager) => {
    collisionStore.setState({ fallbackEnabled: false });
    const fallbackId = generateId();
    lastFallbackDisable.current = fallbackId;
    setTimeout(() => {
      if (lastFallbackDisable.current === fallbackId) {
        collisionStore.setState({ fallbackEnabled: true });
        manager.collisionObserver.forceUpdate(true);
      }
    }, timeout3);
  }, []);
};
var DragDropContextClient = ({
  children,
  disableAutoScroll
}) => {
  const dispatch = useAppStore((s2) => s2.dispatch);
  const appStore = useAppStoreApi();
  const id = useSafeId();
  const debouncedParamsRef = (0, import_react38.useRef)(null);
  const tempDisableFallback = useTempDisableFallback(100);
  const [zoneStore] = (0, import_react38.useState)(
    () => createStore(() => ({
      zoneDepthIndex: {},
      nextZoneDepthIndex: {},
      areaDepthIndex: {},
      nextAreaDepthIndex: {},
      draggedItem: null,
      previewIndex: {},
      enabledIndex: {},
      hoveringComponent: null
    }))
  );
  const getChanged2 = (0, import_react38.useCallback)(
    (params, id2) => {
      const { zoneDepthIndex = {}, areaDepthIndex = {} } = zoneStore.getState() || {};
      const stateHasZone = Object.keys(zoneDepthIndex).length > 0;
      const stateHasArea = Object.keys(areaDepthIndex).length > 0;
      let zoneChanged = false;
      let areaChanged = false;
      if (params.zone && !zoneDepthIndex[params.zone]) {
        zoneChanged = true;
      } else if (!params.zone && stateHasZone) {
        zoneChanged = true;
      }
      if (params.area && !areaDepthIndex[params.area]) {
        areaChanged = true;
      } else if (!params.area && stateHasArea) {
        areaChanged = true;
      }
      return { zoneChanged, areaChanged };
    },
    [zoneStore]
  );
  const setDeepestAndCollide = (0, import_react38.useCallback)(
    (params, manager) => {
      const { zoneChanged, areaChanged } = getChanged2(params, id);
      if (!zoneChanged && !areaChanged)
        return;
      zoneStore.setState({
        zoneDepthIndex: params.zone ? { [params.zone]: true } : {},
        areaDepthIndex: params.area ? { [params.area]: true } : {}
      });
      tempDisableFallback(manager);
      setTimeout(() => {
        manager.collisionObserver.forceUpdate(true);
      }, 50);
      debouncedParamsRef.current = null;
    },
    [zoneStore]
  );
  const setDeepestDb = c2(
    setDeepestAndCollide,
    AREA_CHANGE_DEBOUNCE_MS
  );
  const cancelDb = () => {
    setDeepestDb.cancel();
    debouncedParamsRef.current = null;
  };
  (0, import_react38.useEffect)(() => {
    if (DEBUG3) {
      zoneStore.subscribe(
        (s2) => {
          var _a5, _b3;
          return console.log(
            s2.previewIndex,
            (_a5 = Object.entries(s2.zoneDepthIndex || {})[0]) == null ? void 0 : _a5[0],
            (_b3 = Object.entries(s2.areaDepthIndex || {})[0]) == null ? void 0 : _b3[0]
          );
        }
      );
    }
  }, []);
  const [plugins] = (0, import_react38.useState)(() => [
    ...disableAutoScroll ? defaultPreset.plugins.filter((plugin) => plugin !== AutoScroller) : defaultPreset.plugins,
    createNestedDroppablePlugin(
      {
        onChange: (params, manager) => {
          const state = zoneStore.getState();
          const { zoneChanged, areaChanged } = getChanged2(params, id);
          const isDragging = manager.dragOperation.status.dragging;
          if (areaChanged || zoneChanged) {
            let nextZoneDepthIndex = {};
            let nextAreaDepthIndex = {};
            if (params.zone) {
              nextZoneDepthIndex = { [params.zone]: true };
            }
            if (params.area) {
              nextAreaDepthIndex = { [params.area]: true };
            }
            zoneStore.setState({ nextZoneDepthIndex, nextAreaDepthIndex });
          }
          if (params.zone !== "void" && (state == null ? void 0 : state.zoneDepthIndex["void"])) {
            setDeepestAndCollide(params, manager);
            return;
          }
          if (areaChanged) {
            if (isDragging) {
              const debouncedParams = debouncedParamsRef.current;
              const isSameParams = debouncedParams && debouncedParams.area === params.area && debouncedParams.zone === params.zone;
              if (!isSameParams) {
                cancelDb();
                setDeepestDb(params, manager);
                debouncedParamsRef.current = params;
              }
            } else {
              cancelDb();
              setDeepestAndCollide(params, manager);
            }
            return;
          }
          if (zoneChanged) {
            setDeepestAndCollide(params, manager);
          }
          cancelDb();
        }
      },
      id
    )
  ]);
  const sensors = useSensors();
  const [dragListeners, setDragListeners] = (0, import_react38.useState)({});
  const dragMode = (0, import_react38.useRef)(null);
  const initialSelector = (0, import_react38.useRef)(void 0);
  const nextContextValue = (0, import_react38.useMemo)(
    () => ({
      mode: "edit",
      areaId: "root",
      depth: 0
    }),
    []
  );
  return (0, import_jsx_runtime23.jsx)("div", { id, children: (0, import_jsx_runtime23.jsx)(
    dragListenerContext.Provider,
    {
      value: {
        dragListeners,
        setDragListeners
      },
      children: (0, import_jsx_runtime23.jsx)(
        DragDropProvider,
        {
          plugins,
          sensors,
          onDragEnd: (event, manager) => {
            var _a5, _b3;
            const entryEl = (_a5 = getFrame()) == null ? void 0 : _a5.querySelector("[data-puck-entry]");
            entryEl == null ? void 0 : entryEl.removeAttribute("data-puck-dragging");
            const { source, target } = event.operation;
            if (!source) {
              zoneStore.setState({ draggedItem: null });
              return;
            }
            const { zone, index } = source.data;
            const { previewIndex = {} } = zoneStore.getState() || {};
            const thisPreview = ((_b3 = previewIndex[zone]) == null ? void 0 : _b3.props.id) === source.id ? previewIndex[zone] : null;
            const onAnimationEnd = () => {
              var _a23, _b22;
              zoneStore.setState({ draggedItem: null });
              if (event.canceled || (target == null ? void 0 : target.type) === "void") {
                zoneStore.setState({ previewIndex: {} });
                (_a23 = dragListeners.dragend) == null ? void 0 : _a23.forEach((fn) => {
                  fn(event, manager);
                });
                dispatch({
                  type: "setUi",
                  ui: {
                    itemSelector: null,
                    isDragging: false
                  }
                });
                return;
              }
              if (thisPreview) {
                zoneStore.setState({ previewIndex: {} });
                if (thisPreview.type === "insert") {
                  insertComponent(
                    thisPreview.componentType,
                    thisPreview.zone,
                    thisPreview.index,
                    appStore.getState()
                  );
                } else if (initialSelector.current) {
                  dispatch({
                    type: "move",
                    sourceIndex: initialSelector.current.index,
                    sourceZone: initialSelector.current.zone,
                    destinationIndex: thisPreview.index,
                    destinationZone: thisPreview.zone,
                    recordHistory: false
                  });
                }
              }
              dispatch({
                type: "setUi",
                ui: {
                  itemSelector: { index, zone },
                  isDragging: false
                },
                recordHistory: true
              });
              (_b22 = dragListeners.dragend) == null ? void 0 : _b22.forEach((fn) => {
                fn(event, manager);
              });
            };
            let dispose;
            dispose = E(() => {
              if (source.status === "idle") {
                onAnimationEnd();
                dispose == null ? void 0 : dispose();
              }
            });
          },
          onDragOver: (event, manager) => {
            var _a5, _b3, _c4, _d2;
            event.preventDefault();
            const draggedItem = (_a5 = zoneStore.getState()) == null ? void 0 : _a5.draggedItem;
            if (!draggedItem)
              return;
            cancelDb();
            const { source, target } = event.operation;
            if (!target || !source || target.type === "void")
              return;
            const [sourceId] = source.id.split(":");
            const [targetId] = target.id.split(":");
            const sourceData = source.data;
            let sourceZone = sourceData.zone;
            let sourceIndex = sourceData.index;
            let targetZone = "";
            let targetIndex = 0;
            if (target.type === "component") {
              const targetData = target.data;
              targetZone = targetData.zone;
              targetIndex = targetData.index;
              const collisionData = (_b3 = manager.collisionObserver.collisions[0]) == null ? void 0 : _b3.data;
              const dir = getDeepDir(target.element);
              const collisionPosition = (collisionData == null ? void 0 : collisionData.direction) === "up" || dir === "ltr" && (collisionData == null ? void 0 : collisionData.direction) === "left" || dir === "rtl" && (collisionData == null ? void 0 : collisionData.direction) === "right" ? "before" : "after";
              if (targetIndex >= sourceIndex && sourceZone === targetZone) {
                targetIndex = targetIndex - 1;
              }
              if (collisionPosition === "after") {
                targetIndex = targetIndex + 1;
              }
            } else {
              targetZone = target.id.toString();
              targetIndex = 0;
            }
            const path = ((_c4 = appStore.getState().state.indexes.nodes[target.id]) == null ? void 0 : _c4.path) || [];
            if (targetId === sourceId || path.find((path2) => {
              const [pathId] = path2.split(":");
              return pathId === sourceId;
            })) {
              return;
            }
            if (dragMode.current === "new") {
              zoneStore.setState({
                previewIndex: {
                  [targetZone]: {
                    componentType: sourceData.componentType,
                    type: "insert",
                    index: targetIndex,
                    zone: targetZone,
                    element: source.element,
                    props: {
                      id: source.id.toString()
                    }
                  }
                }
              });
            } else {
              if (!initialSelector.current) {
                initialSelector.current = {
                  zone: sourceData.zone,
                  index: sourceData.index
                };
              }
              const item = getItem(
                initialSelector.current,
                appStore.getState().state
              );
              if (item) {
                zoneStore.setState({
                  previewIndex: {
                    [targetZone]: {
                      componentType: sourceData.componentType,
                      type: "move",
                      index: targetIndex,
                      zone: targetZone,
                      props: item.props,
                      element: source.element
                    }
                  }
                });
              }
            }
            (_d2 = dragListeners.dragover) == null ? void 0 : _d2.forEach((fn) => {
              fn(event, manager);
            });
          },
          onDragStart: (event, manager) => {
            var _a5;
            const { source } = event.operation;
            if (source && source.type !== "void") {
              const sourceData = source.data;
              const item = getItem(
                {
                  zone: sourceData.zone,
                  index: sourceData.index
                },
                appStore.getState().state
              );
              if (item) {
                zoneStore.setState({
                  previewIndex: {
                    [sourceData.zone]: {
                      componentType: sourceData.componentType,
                      type: "move",
                      index: sourceData.index,
                      zone: sourceData.zone,
                      props: item.props,
                      element: source.element
                    }
                  }
                });
              }
            }
            (_a5 = dragListeners.dragstart) == null ? void 0 : _a5.forEach((fn) => {
              fn(event, manager);
            });
          },
          onBeforeDragStart: (event) => {
            var _a5, _b3, _c4, _d2;
            const isNewComponent = ((_a5 = event.operation.source) == null ? void 0 : _a5.type) === "drawer";
            dragMode.current = isNewComponent ? "new" : "existing";
            initialSelector.current = void 0;
            zoneStore.setState({ draggedItem: event.operation.source });
            if (((_b3 = appStore.getState().selectedItem) == null ? void 0 : _b3.props.id) !== ((_c4 = event.operation.source) == null ? void 0 : _c4.id)) {
              dispatch({
                type: "setUi",
                ui: {
                  itemSelector: null,
                  isDragging: true
                },
                recordHistory: false
              });
            } else {
              dispatch({
                type: "setUi",
                ui: {
                  isDragging: true
                },
                recordHistory: false
              });
            }
            const entryEl = (_d2 = getFrame()) == null ? void 0 : _d2.querySelector("[data-puck-entry]");
            entryEl == null ? void 0 : entryEl.setAttribute("data-puck-dragging", "true");
          },
          children: (0, import_jsx_runtime23.jsx)(ZoneStoreProvider, { store: zoneStore, children: (0, import_jsx_runtime23.jsx)(DropZoneProvider, { value: nextContextValue, children }) })
        }
      )
    }
  ) });
};
var DragDropContext2 = ({
  children,
  disableAutoScroll
}) => {
  const status = useAppStore((s2) => s2.status);
  if (status === "LOADING") {
    return children;
  }
  return (0, import_jsx_runtime23.jsx)(DragDropContextClient, { disableAutoScroll, children });
};
var getClassName17 = get_class_name_factory_default("Drawer", styles_module_default12);
var getClassNameItem2 = get_class_name_factory_default("DrawerItem", styles_module_default12);
var DrawerItemInner = ({
  children,
  name,
  label,
  dragRef,
  isDragDisabled
}) => {
  const CustomInner = (0, import_react36.useMemo)(
    () => children || (({ children: children2 }) => (0, import_jsx_runtime24.jsx)("div", { className: getClassNameItem2("default"), children: children2 })),
    [children]
  );
  return (0, import_jsx_runtime24.jsx)(
    "div",
    {
      className: getClassNameItem2({ disabled: isDragDisabled }),
      ref: dragRef,
      onMouseDown: (e3) => e3.preventDefault(),
      "data-testid": dragRef ? `drawer-item:${name}` : "",
      "data-puck-drawer-item": true,
      children: (0, import_jsx_runtime24.jsx)(CustomInner, { name, children: (0, import_jsx_runtime24.jsx)("div", { className: getClassNameItem2("draggableWrapper"), children: (0, import_jsx_runtime24.jsxs)("div", { className: getClassNameItem2("draggable"), children: [
        (0, import_jsx_runtime24.jsx)("div", { className: getClassNameItem2("name"), children: label != null ? label : name }),
        (0, import_jsx_runtime24.jsx)("div", { className: getClassNameItem2("icon"), children: (0, import_jsx_runtime24.jsx)(DragIcon, {}) })
      ] }) }) })
    }
  );
};
var DrawerItemDraggable = ({
  children,
  name,
  label,
  id,
  isDragDisabled
}) => {
  const { ref } = useDraggable({
    id,
    data: { componentType: name },
    disabled: isDragDisabled,
    type: "drawer"
  });
  return (0, import_jsx_runtime24.jsxs)("div", { className: getClassName17("draggable"), children: [
    (0, import_jsx_runtime24.jsx)("div", { className: getClassName17("draggableBg"), children: (0, import_jsx_runtime24.jsx)(DrawerItemInner, { name, label, children }) }),
    (0, import_jsx_runtime24.jsx)("div", { className: getClassName17("draggableFg"), children: (0, import_jsx_runtime24.jsx)(
      DrawerItemInner,
      {
        name,
        label,
        dragRef: ref,
        isDragDisabled,
        children
      }
    ) })
  ] });
};
var DrawerItem = ({
  name,
  children,
  id,
  label,
  index,
  isDragDisabled
}) => {
  const resolvedId = id || name;
  const [dynamicId, setDynamicId] = (0, import_react36.useState)(generateId(resolvedId));
  if (typeof index !== "undefined") {
    console.error(
      "Warning: The `index` prop on Drawer.Item is deprecated and no longer required."
    );
  }
  useDragListener(
    "dragend",
    () => {
      setDynamicId(generateId(resolvedId));
    },
    [resolvedId]
  );
  return (0, import_jsx_runtime24.jsx)("div", { children: (0, import_jsx_runtime24.jsx)(
    DrawerItemDraggable,
    {
      name,
      label,
      id: dynamicId,
      isDragDisabled,
      children
    }
  ) }, dynamicId);
};
var Drawer = ({
  children,
  droppableId,
  direction
}) => {
  if (droppableId) {
    console.error(
      "Warning: The `droppableId` prop on Drawer is deprecated and no longer required."
    );
  }
  if (direction) {
    console.error(
      "Warning: The `direction` prop on Drawer is deprecated and no longer required to achieve multi-directional dragging."
    );
  }
  const id = useSafeId();
  const { ref } = useDroppable({
    id,
    type: "void",
    collisionPriority: 0
    // Never collide with this, but we use it so NestedDroppablePlugin respects the Drawer
  });
  return (0, import_jsx_runtime24.jsx)(
    "div",
    {
      className: getClassName17(),
      ref,
      "data-puck-dnd": id,
      "data-puck-drawer": true,
      "data-puck-dnd-void": true,
      children
    }
  );
};
Drawer.Item = DrawerItem;
init_react_import();
var getNumItems = (appStore, zoneCompound) => appStore.getState().state.indexes.zones[zoneCompound].contentIds.length;
var useMinEmptyHeight = ({
  zoneCompound,
  userMinEmptyHeight,
  ref
}) => {
  const appStore = useAppStoreApi();
  const [prevHeight, setPrevHeight] = (0, import_react40.useState)(0);
  const [isAnimating, setIsAnimating] = (0, import_react40.useState)(false);
  const { draggedItem, isZone } = useContextStore(ZoneStoreContext, (s2) => {
    var _a5, _b3;
    return {
      draggedItem: ((_a5 = s2.draggedItem) == null ? void 0 : _a5.data.zone) === zoneCompound ? s2.draggedItem : null,
      isZone: ((_b3 = s2.draggedItem) == null ? void 0 : _b3.data.zone) === zoneCompound
    };
  });
  const numItems = (0, import_react40.useRef)(0);
  const onDragFinished = useOnDragFinished(
    (finished) => {
      var _a5;
      if (finished) {
        const newNumItems = getNumItems(appStore, zoneCompound);
        setPrevHeight(0);
        if (newNumItems || numItems.current === 0) {
          setIsAnimating(false);
          return;
        }
        const selectedItem = appStore.getState().selectedItem;
        const zones = appStore.getState().state.indexes.zones;
        const nodes = appStore.getState().nodes;
        (_a5 = nodes.nodes[selectedItem == null ? void 0 : selectedItem.props.id]) == null ? void 0 : _a5.methods.hideOverlay();
        setTimeout(() => {
          var _a23;
          const contentIds = ((_a23 = zones[zoneCompound]) == null ? void 0 : _a23.contentIds) || [];
          contentIds.forEach((contentId) => {
            const node = nodes.nodes[contentId];
            node == null ? void 0 : node.methods.sync();
          });
          if (selectedItem) {
            setTimeout(() => {
              var _a33, _b3;
              (_a33 = nodes.nodes[selectedItem.props.id]) == null ? void 0 : _a33.methods.sync();
              (_b3 = nodes.nodes[selectedItem.props.id]) == null ? void 0 : _b3.methods.showOverlay();
            }, 200);
          }
          setIsAnimating(false);
        }, 100);
      }
    },
    [appStore, prevHeight, zoneCompound]
  );
  (0, import_react40.useEffect)(() => {
    if (draggedItem && ref.current) {
      if (isZone) {
        const rect = ref.current.getBoundingClientRect();
        numItems.current = getNumItems(appStore, zoneCompound);
        setPrevHeight(rect.height);
        setIsAnimating(true);
        return onDragFinished();
      }
    }
  }, [ref.current, draggedItem, onDragFinished]);
  return [prevHeight || userMinEmptyHeight, isAnimating];
};
init_react_import();
function assignRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (ref && typeof ref === "object" && "current" in ref) {
    ref.current = node;
  }
}
function assignRefs(refs, node) {
  refs.forEach((ref) => {
    assignRef(ref, node);
  });
}
init_react_import();
init_react_import();
function useRenderedCallback(callback, deps) {
  const manager = useDragDropManager();
  return (0, import_react43.useCallback)(
    (...args) => __async(this, null, function* () {
      yield manager == null ? void 0 : manager.renderer.rendering;
      return callback(...args);
    }),
    [...deps, manager]
  );
}
var useContentIdsWithPreview = (contentIds, zoneCompound) => {
  const zoneStore = (0, import_react41.useContext)(ZoneStoreContext);
  const preview = useContextStore(
    ZoneStoreContext,
    (s2) => s2.previewIndex[zoneCompound]
  );
  const isDragging = useAppStore((s2) => s2.state.ui.isDragging);
  const [contentIdsWithPreview, setContentIdsWithPreview] = (0, import_react41.useState)(contentIds);
  const [localPreview, setLocalPreview] = (0, import_react41.useState)(
    preview
  );
  const updateContent = useRenderedCallback(
    (contentIds2, preview2, isDragging2, draggedItemId, previewExists) => {
      if (isDragging2 && !previewExists) {
        return;
      }
      if (preview2) {
        if (preview2.type === "insert") {
          setContentIdsWithPreview(
            insert(
              contentIds2.filter((id) => id !== preview2.props.id),
              preview2.index,
              preview2.props.id
            )
          );
        } else {
          setContentIdsWithPreview(
            insert(
              contentIds2.filter((id) => id !== preview2.props.id),
              preview2.index,
              preview2.props.id
            )
          );
        }
      } else {
        setContentIdsWithPreview(
          previewExists ? contentIds2.filter((id) => id !== draggedItemId) : contentIds2
        );
      }
      setLocalPreview(preview2);
    },
    []
  );
  (0, import_react41.useEffect)(() => {
    var _a5;
    const s2 = zoneStore.getState();
    const draggedItemId = (_a5 = s2.draggedItem) == null ? void 0 : _a5.id;
    const previewExists = Object.keys(s2.previewIndex || {}).length > 0;
    updateContent(
      contentIds,
      preview,
      isDragging,
      draggedItemId,
      previewExists
    );
  }, [contentIds, preview, isDragging]);
  return [contentIdsWithPreview, localPreview];
};
init_react_import();
var GRID_DRAG_AXIS = "dynamic";
var FLEX_ROW_DRAG_AXIS = "x";
var DEFAULT_DRAG_AXIS = "y";
var useDragAxis = (ref, collisionAxis) => {
  const status = useAppStore((s2) => s2.status);
  const [dragAxis, setDragAxis] = (0, import_react44.useState)(
    collisionAxis || DEFAULT_DRAG_AXIS
  );
  const calculateDragAxis = (0, import_react44.useCallback)(() => {
    if (ref.current) {
      const computedStyle = window.getComputedStyle(ref.current);
      if (computedStyle.display === "grid") {
        setDragAxis(GRID_DRAG_AXIS);
      } else if (computedStyle.display === "flex" && computedStyle.flexDirection === "row") {
        setDragAxis(FLEX_ROW_DRAG_AXIS);
      } else {
        setDragAxis(DEFAULT_DRAG_AXIS);
      }
    }
  }, [ref.current]);
  (0, import_react44.useEffect)(() => {
    const onViewportChange = () => {
      calculateDragAxis();
    };
    window.addEventListener("viewportchange", onViewportChange);
    return () => {
      window.removeEventListener("viewportchange", onViewportChange);
    };
  }, []);
  (0, import_react44.useEffect)(calculateDragAxis, [status, collisionAxis]);
  return [dragAxis, calculateDragAxis];
};
init_react_import();
var ContextSlotRender = ({
  componentId,
  zone
}) => {
  const config = useAppStore((s2) => s2.config);
  const metadata = useAppStore((s2) => s2.metadata);
  const slotContent = useAppStore(
    useShallow((s2) => {
      var _a5, _b3;
      const indexes = s2.state.indexes;
      const contentIds = (_b3 = (_a5 = indexes.zones[`${componentId}:${zone}`]) == null ? void 0 : _a5.contentIds) != null ? _b3 : [];
      return contentIds.map((contentId) => indexes.nodes[contentId].flatData);
    })
  );
  return (0, import_jsx_runtime25.jsx)(
    SlotRenderPure,
    {
      content: slotContent,
      zone,
      config,
      metadata
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var registerOverlayPortal = (el, opts = {}) => {
  if (!el)
    return;
  const { disableDrag = false, disableDragOnFocus = true } = opts;
  const stopPropagation = (e3) => {
    e3.stopPropagation();
  };
  el.addEventListener("mouseover", stopPropagation, {
    capture: true
  });
  const onFocus = () => {
    setTimeout(() => {
      el.addEventListener("pointerdown", stopPropagation, {
        capture: true
      });
    }, 200);
  };
  const onBlur = () => {
    el.removeEventListener("pointerdown", stopPropagation, {
      capture: true
    });
  };
  if (disableDragOnFocus) {
    el.addEventListener("focus", onFocus, { capture: true });
    el.addEventListener("blur", onBlur, { capture: true });
  } else if (disableDrag) {
    el.addEventListener("pointerdown", stopPropagation, {
      capture: true
    });
  }
  el.setAttribute("data-puck-overlay-portal", "true");
  return () => {
    el.removeEventListener("mouseover", stopPropagation, {
      capture: true
    });
    if (disableDragOnFocus) {
      el.removeEventListener("focus", onFocus, { capture: true });
      el.removeEventListener("blur", onFocus, { capture: true });
    } else if (disableDrag) {
      el.removeEventListener("pointerdown", stopPropagation, {
        capture: true
      });
    }
    el.removeAttribute("data-puck-overlay-portal");
  };
};
init_react_import();
var styles_module_default13 = { "InlineTextField": "_InlineTextField_1xph6_1" };
init_react_import();
function setDeep(node, path, newVal) {
  const parts = path.split(".");
  const newNode = __spreadValues({}, node);
  let cur = newNode;
  for (let i2 = 0; i2 < parts.length; i2++) {
    const [prop, idxStr] = parts[i2].replace("]", "").split("[");
    const isLast = i2 === parts.length - 1;
    if (idxStr !== void 0) {
      if (!Array.isArray(cur[prop])) {
        cur[prop] = [];
      }
      const idx = Number(idxStr);
      if (isLast) {
        cur[prop][idx] = newVal;
        continue;
      }
      if (cur[prop][idx] === void 0)
        cur[prop][idx] = {};
      cur = cur[prop][idx];
      continue;
    }
    if (isLast) {
      cur[prop] = newVal;
      continue;
    }
    if (cur[prop] === void 0) {
      cur[prop] = {};
    }
    cur = cur[prop];
  }
  return __spreadValues(__spreadValues({}, node), newNode);
}
init_react_import();
var getSelectorForId = (state, id) => {
  const node = state.indexes.nodes[id];
  if (!node)
    return;
  const zoneCompound = `${node.parentId}:${node.zone}`;
  const index = state.indexes.zones[zoneCompound].contentIds.indexOf(id);
  return { zone: zoneCompound, index };
};
var getClassName18 = get_class_name_factory_default("InlineTextField", styles_module_default13);
var InlineTextFieldInternal = ({
  propPath,
  componentId,
  value,
  isReadOnly,
  opts = {}
}) => {
  var _a5;
  const ref = (0, import_react45.useRef)(null);
  const appStoreApi = useAppStoreApi();
  const disableLineBreaks = (_a5 = opts.disableLineBreaks) != null ? _a5 : false;
  (0, import_react45.useEffect)(() => {
    const appStore = appStoreApi.getState();
    const data = appStore.state.indexes.nodes[componentId].data;
    const componentConfig = appStore.getComponentConfig(data.type);
    if (!componentConfig) {
      throw new Error(
        `InlineTextField Error: No config defined for ${data.type}`
      );
    }
    if (ref.current) {
      if (value !== ref.current.innerText) {
        ref.current.replaceChildren(value);
      }
      const cleanupPortal = registerOverlayPortal(ref.current);
      const handleInput = (e3) => __async(void 0, null, function* () {
        var _a23;
        const appStore2 = appStoreApi.getState();
        const node = appStore2.state.indexes.nodes[componentId];
        const zoneCompound = `${node.parentId}:${node.zone}`;
        const index = (_a23 = appStore2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a23.contentIds.indexOf(
          componentId
        );
        let value2 = e3.target.innerText;
        if (disableLineBreaks) {
          value2 = value2.replaceAll(/\n/gm, "");
        }
        const newProps = setDeep(node.data.props, propPath, value2);
        const resolvedData = yield appStore2.resolveComponentData(
          __spreadProps(__spreadValues({}, node.data), { props: newProps }),
          "replace"
        );
        appStore2.dispatch({
          type: "replace",
          data: resolvedData.node,
          destinationIndex: index,
          destinationZone: zoneCompound
        });
      });
      ref.current.addEventListener("input", handleInput);
      return () => {
        var _a23;
        (_a23 = ref.current) == null ? void 0 : _a23.removeEventListener("input", handleInput);
        cleanupPortal == null ? void 0 : cleanupPortal();
      };
    }
  }, [appStoreApi, ref.current, value, disableLineBreaks]);
  const [isHovering, setIsHovering] = (0, import_react45.useState)(false);
  const [isFocused, setIsFocused] = (0, import_react45.useState)(false);
  return (0, import_jsx_runtime26.jsx)(
    "span",
    {
      className: getClassName18(),
      ref,
      contentEditable: isHovering || isFocused ? "plaintext-only" : "false",
      onClick: (e3) => {
        e3.preventDefault();
        e3.stopPropagation();
      },
      onClickCapture: (e3) => {
        e3.preventDefault();
        e3.stopPropagation();
        const itemSelector = getSelectorForId(
          appStoreApi.getState().state,
          componentId
        );
        appStoreApi.getState().setUi({ itemSelector });
      },
      onKeyDown: (e3) => {
        e3.stopPropagation();
        if (disableLineBreaks && e3.key === "Enter" || isReadOnly) {
          e3.preventDefault();
        }
      },
      onKeyUp: (e3) => {
        e3.stopPropagation();
        e3.preventDefault();
      },
      onMouseOverCapture: () => setIsHovering(true),
      onMouseOutCapture: () => setIsHovering(false),
      onFocus: () => setIsFocused(true),
      onBlur: () => setIsFocused(false)
    }
  );
};
var InlineTextField = (0, import_react45.memo)(InlineTextFieldInternal);
var getInlineTextTransform = () => ({
  text: ({ value, componentId, field, propPath, isReadOnly }) => {
    if (field.contentEditable) {
      return (0, import_jsx_runtime27.jsx)(
        InlineTextField,
        {
          propPath,
          componentId,
          value,
          opts: { disableLineBreaks: true },
          isReadOnly
        }
      );
    }
    return value;
  },
  textarea: ({ value, componentId, field, propPath, isReadOnly }) => {
    if (field.contentEditable) {
      return (0, import_jsx_runtime27.jsx)(
        InlineTextField,
        {
          propPath,
          componentId,
          value,
          isReadOnly
        }
      );
    }
    return value;
  },
  custom: ({ value, componentId, field, propPath, isReadOnly }) => {
    if (field.contentEditable && typeof value === "string") {
      return (0, import_jsx_runtime27.jsx)(
        InlineTextField,
        {
          propPath,
          componentId,
          value,
          isReadOnly
        }
      );
    }
    return value;
  }
});
var getClassName19 = get_class_name_factory_default("DropZone", styles_module_default11);
var getRandomColor = () => `#${Math.floor(Math.random() * 16777215).toString(16)}`;
var RENDER_DEBUG = false;
var DropZoneEditPure = (props) => (0, import_jsx_runtime28.jsx)(DropZoneEdit, __spreadValues({}, props));
var DropZoneChild = ({
  zoneCompound,
  componentId,
  index,
  dragAxis,
  collisionAxis,
  inDroppableZone
}) => {
  var _a5, _b3;
  const metadata = useAppStore((s2) => s2.metadata);
  const ctx = (0, import_react30.useContext)(dropZoneContext);
  const { depth = 1 } = ctx != null ? ctx : {};
  const zoneStore = (0, import_react30.useContext)(ZoneStoreContext);
  const nodeProps = useAppStore(
    useShallow((s2) => {
      var _a23;
      return (_a23 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a23.flatData.props;
    })
  );
  const nodeType = useAppStore(
    (s2) => {
      var _a23;
      return (_a23 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a23.data.type;
    }
  );
  const nodeReadOnly = useAppStore(
    useShallow((s2) => {
      var _a23;
      return (_a23 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a23.data.readOnly;
    })
  );
  const appStore = useAppStoreApi();
  const item = (0, import_react30.useMemo)(() => {
    if (nodeProps) {
      const expanded = expandNode({
        type: nodeType,
        props: nodeProps
      });
      return expanded;
    }
    const preview = zoneStore.getState().previewIndex[zoneCompound];
    if (componentId === (preview == null ? void 0 : preview.props.id)) {
      return {
        type: preview.componentType,
        props: preview.props,
        previewType: preview.type,
        element: preview.element
      };
    }
    return null;
  }, [appStore, componentId, zoneCompound, nodeType, nodeProps]);
  const componentConfig = useAppStore(
    (s2) => (item == null ? void 0 : item.type) ? s2.config.components[item.type] : null
  );
  const puckProps = (0, import_react30.useMemo)(
    () => ({
      renderDropZone: DropZoneEditPure,
      isEditing: true,
      dragRef: null,
      metadata: __spreadValues(__spreadValues({}, metadata), componentConfig == null ? void 0 : componentConfig.metadata)
    }),
    [metadata, componentConfig == null ? void 0 : componentConfig.metadata]
  );
  const overrides = useAppStore((s2) => s2.overrides);
  const isLoading = useAppStore(
    (s2) => {
      var _a23;
      return ((_a23 = s2.componentState[componentId]) == null ? void 0 : _a23.loadingCount) > 0;
    }
  );
  const isSelected = useAppStore(
    (s2) => {
      var _a23;
      return ((_a23 = s2.selectedItem) == null ? void 0 : _a23.props.id) === componentId || false;
    }
  );
  let label = (_b3 = (_a5 = componentConfig == null ? void 0 : componentConfig.label) != null ? _a5 : item == null ? void 0 : item.type.toString()) != null ? _b3 : "Component";
  const renderPreview = (0, import_react30.useMemo)(
    () => function Preview3() {
      var _a23;
      if (item && "element" in item && item.element) {
        return (
          // Safe to use this since the HTML is set by the user
          (0, import_jsx_runtime28.jsx)("div", { dangerouslySetInnerHTML: { __html: item.element.outerHTML } })
        );
      }
      return (0, import_jsx_runtime28.jsx)(DrawerItemInner, { name: label, children: (_a23 = overrides.componentItem) != null ? _a23 : overrides.drawerItem });
    },
    [componentId, label, overrides]
  );
  const defaultsProps = (0, import_react30.useMemo)(
    () => __spreadProps(__spreadValues(__spreadValues({}, componentConfig == null ? void 0 : componentConfig.defaultProps), item == null ? void 0 : item.props), {
      puck: puckProps,
      editMode: true
      // DEPRECATED
    }),
    [componentConfig == null ? void 0 : componentConfig.defaultProps, item == null ? void 0 : item.props, puckProps]
  );
  const defaultedNode = (0, import_react30.useMemo)(
    () => {
      var _a23;
      return { type: (_a23 = item == null ? void 0 : item.type) != null ? _a23 : nodeType, props: defaultsProps };
    },
    [item == null ? void 0 : item.type, nodeType, defaultsProps]
  );
  const config = useAppStore((s2) => s2.config);
  const plugins = useAppStore((s2) => s2.plugins);
  const userFieldTransforms = useAppStore((s2) => s2.fieldTransforms);
  const combinedFieldTransforms = (0, import_react30.useMemo)(
    () => __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, getSlotTransform(DropZoneEditPure, (slotProps) => (0, import_jsx_runtime28.jsx)(ContextSlotRender, { componentId, zone: slotProps.zone }))), getInlineTextTransform()), plugins.reduce(
      (acc, plugin) => __spreadValues(__spreadValues({}, acc), plugin.fieldTransforms),
      {}
    )), userFieldTransforms),
    [plugins, userFieldTransforms]
  );
  const transformedProps = useFieldTransforms(
    config,
    defaultedNode,
    combinedFieldTransforms,
    nodeReadOnly,
    isLoading
  );
  if (!item)
    return;
  let Render2 = componentConfig ? componentConfig.render : () => (0, import_jsx_runtime28.jsxs)("div", { style: { padding: 48, textAlign: "center" }, children: [
    "No configuration for ",
    item.type
  ] });
  let componentType = item.type;
  const isInserting = "previewType" in item ? item.previewType === "insert" : false;
  if (isInserting) {
    Render2 = renderPreview;
  }
  return (0, import_jsx_runtime28.jsx)(
    DraggableComponent,
    {
      id: componentId,
      componentType,
      zoneCompound,
      depth: depth + 1,
      index,
      isLoading,
      isSelected,
      label,
      autoDragAxis: dragAxis,
      userDragAxis: collisionAxis,
      inDroppableZone,
      children: (dragRef) => (componentConfig == null ? void 0 : componentConfig.inline) && !isInserting ? (0, import_jsx_runtime28.jsx)(import_jsx_runtime28.Fragment, { children: (0, import_jsx_runtime28.jsx)(
        Render2,
        __spreadProps(__spreadValues({}, transformedProps), {
          puck: __spreadProps(__spreadValues({}, transformedProps.puck), {
            dragRef
          })
        })
      ) }) : (0, import_jsx_runtime28.jsx)("div", { ref: dragRef, children: (0, import_jsx_runtime28.jsx)(Render2, __spreadValues({}, transformedProps)) })
    }
  );
};
var DropZoneChildMemo = (0, import_react30.memo)(DropZoneChild);
var DropZoneEdit = (0, import_react30.forwardRef)(
  function DropZoneEditInternal({
    zone,
    allow,
    disallow,
    style,
    className,
    minEmptyHeight: userMinEmptyHeight = 128,
    collisionAxis
  }, userRef) {
    const ctx = (0, import_react30.useContext)(dropZoneContext);
    const appStoreApi = useAppStoreApi();
    const {
      // These all need setting via context
      areaId,
      depth = 0,
      registerLocalZone,
      unregisterLocalZone
    } = ctx != null ? ctx : {};
    const path = useAppStore(
      useShallow((s2) => {
        var _a5;
        return areaId ? (_a5 = s2.state.indexes.nodes[areaId]) == null ? void 0 : _a5.path : null;
      })
    );
    let zoneCompound = rootDroppableId;
    if (areaId) {
      if (zone !== rootDroppableId) {
        zoneCompound = `${areaId}:${zone}`;
      }
    }
    const isRootZone = zoneCompound === rootDroppableId || zone === rootDroppableId || areaId === "root";
    const inNextDeepestArea = useContextStore(
      ZoneStoreContext,
      (s2) => s2.nextAreaDepthIndex[areaId || ""]
    );
    const zoneContentIds = useAppStore(
      useShallow((s2) => {
        var _a5;
        return (_a5 = s2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.contentIds;
      })
    );
    const zoneType = useAppStore(
      useShallow((s2) => {
        var _a5;
        return (_a5 = s2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.type;
      })
    );
    (0, import_react30.useEffect)(() => {
      if (!zoneType || zoneType === "dropzone") {
        if (ctx == null ? void 0 : ctx.registerZone) {
          ctx == null ? void 0 : ctx.registerZone(zoneCompound);
        }
      }
    }, [zoneType, appStoreApi]);
    (0, import_react30.useEffect)(() => {
      if (zoneType === "dropzone") {
        if (zoneCompound !== rootDroppableId) {
          console.warn(
            "DropZones have been deprecated in favor of slot fields and will be removed in a future version of Puck. Please see the migration guide: https://www.puckeditor.com/docs/guides/migrations/dropzones-to-slots"
          );
        }
      }
    }, [zoneType]);
    const contentIds = (0, import_react30.useMemo)(() => {
      return zoneContentIds || [];
    }, [zoneContentIds]);
    const ref = (0, import_react30.useRef)(null);
    const acceptsTarget = (0, import_react30.useCallback)(
      (componentType) => {
        if (!componentType) {
          return true;
        }
        if (disallow) {
          const defaultedAllow = allow || [];
          const filteredDisallow = (disallow || []).filter(
            (item) => defaultedAllow.indexOf(item) === -1
          );
          if (filteredDisallow.indexOf(componentType) !== -1) {
            return false;
          }
        } else if (allow) {
          if (allow.indexOf(componentType) === -1) {
            return false;
          }
        }
        return true;
      },
      [allow, disallow]
    );
    const targetAccepted = useContextStore(ZoneStoreContext, (s2) => {
      var _a5;
      const draggedComponentType = (_a5 = s2.draggedItem) == null ? void 0 : _a5.data.componentType;
      return acceptsTarget(draggedComponentType);
    });
    const hoveringOverArea = inNextDeepestArea || isRootZone;
    const isEnabled = useContextStore(ZoneStoreContext, (s2) => {
      var _a5;
      let _isEnabled = true;
      const isDeepestZone = (_a5 = s2.zoneDepthIndex[zoneCompound]) != null ? _a5 : false;
      _isEnabled = isDeepestZone;
      if (_isEnabled) {
        _isEnabled = targetAccepted;
      }
      return _isEnabled;
    });
    (0, import_react30.useEffect)(() => {
      if (registerLocalZone) {
        registerLocalZone(zoneCompound, targetAccepted || isEnabled);
      }
      return () => {
        if (unregisterLocalZone) {
          unregisterLocalZone(zoneCompound);
        }
      };
    }, [targetAccepted, isEnabled, zoneCompound]);
    const [contentIdsWithPreview, preview] = useContentIdsWithPreview(
      contentIds,
      zoneCompound
    );
    const isDropEnabled = isEnabled && (preview ? contentIdsWithPreview.length === 1 : contentIdsWithPreview.length === 0);
    const zoneStore = (0, import_react30.useContext)(ZoneStoreContext);
    (0, import_react30.useEffect)(() => {
      const { enabledIndex } = zoneStore.getState();
      zoneStore.setState({
        enabledIndex: __spreadProps(__spreadValues({}, enabledIndex), { [zoneCompound]: isEnabled })
      });
    }, [isEnabled, zoneStore, zoneCompound]);
    const droppableConfig = {
      id: zoneCompound,
      collisionPriority: isEnabled ? depth : 0,
      disabled: !isDropEnabled,
      collisionDetector: pointerIntersection3,
      type: "dropzone",
      data: {
        areaId,
        depth,
        isDroppableTarget: targetAccepted,
        path: path || []
      }
    };
    const { ref: dropRef } = useDroppable(droppableConfig);
    const isAreaSelected = useAppStore(
      (s2) => (s2 == null ? void 0 : s2.selectedItem) && areaId === (s2 == null ? void 0 : s2.selectedItem.props.id)
    );
    const [dragAxis] = useDragAxis(ref, collisionAxis);
    const [minEmptyHeight, isAnimating] = useMinEmptyHeight({
      zoneCompound,
      userMinEmptyHeight,
      ref
    });
    return (0, import_jsx_runtime28.jsx)(
      "div",
      {
        className: `${getClassName19({
          isRootZone,
          hoveringOverArea,
          isEnabled,
          isAreaSelected,
          hasChildren: contentIds.length > 0,
          isAnimating
        })}${className ? ` ${className}` : ""}`,
        ref: (node) => {
          assignRefs([ref, dropRef, userRef], node);
        },
        "data-testid": `dropzone:${zoneCompound}`,
        "data-puck-dropzone": zoneCompound,
        style: __spreadProps(__spreadValues({}, style), {
          "--min-empty-height": `${minEmptyHeight}px`,
          backgroundColor: RENDER_DEBUG ? getRandomColor() : style == null ? void 0 : style.backgroundColor
        }),
        children: contentIdsWithPreview.map((componentId, i2) => {
          return (0, import_jsx_runtime28.jsx)(
            DropZoneChildMemo,
            {
              zoneCompound,
              componentId,
              dragAxis,
              index: i2,
              collisionAxis,
              inDroppableZone: targetAccepted
            },
            componentId
          );
        })
      }
    );
  }
);
var DropZoneRenderItem = ({
  config,
  item,
  metadata
}) => {
  const Component = config.components[item.type];
  const props = useSlots(config, item, (slotProps) => (0, import_jsx_runtime28.jsx)(SlotRenderPure, __spreadProps(__spreadValues({}, slotProps), { config, metadata })));
  const nextContextValue = (0, import_react30.useMemo)(
    () => ({
      areaId: props.id,
      depth: 1
    }),
    [props]
  );
  return (0, import_jsx_runtime28.jsx)(DropZoneProvider, { value: nextContextValue, children: (0, import_jsx_runtime28.jsx)(
    Component.render,
    __spreadProps(__spreadValues({}, props), {
      puck: __spreadProps(__spreadValues({}, props.puck), {
        renderDropZone: DropZoneRenderPure,
        metadata: __spreadValues(__spreadValues({}, metadata), Component.metadata)
      })
    })
  ) }, props.id);
};
var DropZoneRenderPure = (props) => (0, import_jsx_runtime28.jsx)(DropZoneRender, __spreadValues({}, props));
var DropZoneRender = (0, import_react30.forwardRef)(
  function DropZoneRenderInternal({ className, style, zone }, ref) {
    const ctx = (0, import_react30.useContext)(dropZoneContext);
    const { areaId = "root" } = ctx || {};
    const { config, data, metadata } = (0, import_react30.useContext)(renderContext);
    let zoneCompound = `${areaId}:${zone}`;
    let content = (data == null ? void 0 : data.content) || [];
    (0, import_react30.useEffect)(() => {
      if (!content) {
        if (ctx == null ? void 0 : ctx.registerZone) {
          ctx == null ? void 0 : ctx.registerZone(zoneCompound);
        }
      }
    }, [content]);
    if (!data || !config) {
      return null;
    }
    if (zoneCompound !== rootDroppableId) {
      content = setupZone(data, zoneCompound).zones[zoneCompound];
    }
    return (0, import_jsx_runtime28.jsx)("div", { className, style, ref, children: content.map((item) => {
      const Component = config.components[item.type];
      if (Component) {
        return (0, import_jsx_runtime28.jsx)(
          DropZoneRenderItem,
          {
            config,
            item,
            metadata
          },
          item.props.id
        );
      }
      return null;
    }) });
  }
);
var DropZonePure = (props) => (0, import_jsx_runtime28.jsx)(DropZone, __spreadValues({}, props));
var DropZone = (0, import_react30.forwardRef)(
  function DropZone2(props, ref) {
    const ctx = (0, import_react30.useContext)(dropZoneContext);
    if ((ctx == null ? void 0 : ctx.mode) === "edit") {
      return (0, import_jsx_runtime28.jsx)(import_jsx_runtime28.Fragment, { children: (0, import_jsx_runtime28.jsx)(DropZoneEdit, __spreadProps(__spreadValues({}, props), { ref })) });
    }
    return (0, import_jsx_runtime28.jsx)(import_jsx_runtime28.Fragment, { children: (0, import_jsx_runtime28.jsx)(DropZoneRender, __spreadProps(__spreadValues({}, props), { ref })) });
  }
);
var renderContext = import_react46.default.createContext({
  config: { components: {} },
  data: { root: {}, content: [] },
  metadata: {}
});
function Render({
  config,
  data,
  metadata = {}
}) {
  var _a5;
  const defaultedData = __spreadProps(__spreadValues({}, data), {
    root: data.root || {},
    content: data.content || []
  });
  const rootProps = "props" in defaultedData.root ? defaultedData.root.props : defaultedData.root;
  const title = (rootProps == null ? void 0 : rootProps.title) || "";
  const pageProps = __spreadProps(__spreadValues({}, rootProps), {
    puck: {
      renderDropZone: DropZonePure,
      isEditing: false,
      dragRef: null,
      metadata
    },
    title,
    editMode: false,
    id: "puck-root"
  });
  const propsWithSlots = useSlots(
    config,
    { type: "root", props: pageProps },
    (props) => (0, import_jsx_runtime29.jsx)(SlotRender, __spreadProps(__spreadValues({}, props), { config, metadata }))
  );
  const nextContextValue = (0, import_react46.useMemo)(
    () => ({
      mode: "render",
      depth: 0
    }),
    []
  );
  if ((_a5 = config.root) == null ? void 0 : _a5.render) {
    return (0, import_jsx_runtime29.jsx)(renderContext.Provider, { value: { config, data: defaultedData, metadata }, children: (0, import_jsx_runtime29.jsx)(DropZoneProvider, { value: nextContextValue, children: (0, import_jsx_runtime29.jsx)(config.root.render, __spreadProps(__spreadValues({}, propsWithSlots), { children: (0, import_jsx_runtime29.jsx)(DropZoneRenderPure, { zone: rootZone }) })) }) });
  }
  return (0, import_jsx_runtime29.jsx)(renderContext.Provider, { value: { config, data: defaultedData, metadata }, children: (0, import_jsx_runtime29.jsx)(DropZoneProvider, { value: nextContextValue, children: (0, import_jsx_runtime29.jsx)(DropZoneRenderPure, { zone: rootZone }) }) });
}
init_react_import();
var generateUsePuck = (store2) => {
  const history = {
    back: store2.history.back,
    forward: store2.history.forward,
    setHistories: store2.history.setHistories,
    setHistoryIndex: store2.history.setHistoryIndex,
    hasPast: store2.history.hasPast(),
    hasFuture: store2.history.hasFuture(),
    histories: store2.history.histories,
    index: store2.history.index
  };
  const storeData = {
    appState: makeStatePublic(store2.state),
    config: store2.config,
    dispatch: store2.dispatch,
    getPermissions: store2.permissions.getPermissions,
    refreshPermissions: store2.permissions.refreshPermissions,
    history,
    selectedItem: store2.selectedItem || null,
    getItemBySelector: (selector) => getItem(selector, store2.state),
    getItemById: (id) => store2.state.indexes.nodes[id].data,
    getSelectorForId: (id) => getSelectorForId(store2.state, id)
  };
  return storeData;
};
var UsePuckStoreContext = (0, import_react47.createContext)(
  null
);
var convertToPickedStore = (store2) => {
  return {
    state: store2.state,
    config: store2.config,
    dispatch: store2.dispatch,
    permissions: store2.permissions,
    history: store2.history,
    selectedItem: store2.selectedItem
  };
};
var useRegisterUsePuckStore = (appStore) => {
  const [usePuckStore] = (0, import_react47.useState)(
    () => createStore(
      () => generateUsePuck(convertToPickedStore(appStore.getState()))
    )
  );
  (0, import_react47.useEffect)(() => {
    return appStore.subscribe(
      (store2) => convertToPickedStore(store2),
      (pickedStore) => {
        usePuckStore.setState(generateUsePuck(pickedStore));
      }
    );
  }, []);
  return usePuckStore;
};
function createUsePuck() {
  return function usePuck2(selector) {
    const usePuckApi = (0, import_react47.useContext)(UsePuckStoreContext);
    if (!usePuckApi) {
      throw new Error("usePuck must be used inside <Puck>.");
    }
    const result = useStore(
      usePuckApi,
      selector != null ? selector : (s2) => s2
    );
    return result;
  };
}
function usePuck() {
  (0, import_react47.useEffect)(() => {
    console.warn(
      "You're using the `usePuck` method without a selector, which may cause unnecessary re-renders. Replace with `createUsePuck` and provide a selector for improved performance."
    );
  }, []);
  return createUsePuck()((s2) => s2);
}
function useGetPuck() {
  const usePuckApi = (0, import_react47.useContext)(UsePuckStoreContext);
  if (!usePuckApi) {
    throw new Error("usePuckGet must be used inside <Puck>.");
  }
  return usePuckApi.getState;
}
init_react_import();
init_react_import();
init_react_import();
var styles_module_default14 = { "SidebarSection": "_SidebarSection_8boj8_1", "SidebarSection-title": "_SidebarSection-title_8boj8_12", "SidebarSection--noBorderTop": "_SidebarSection--noBorderTop_8boj8_20", "SidebarSection-content": "_SidebarSection-content_8boj8_24", "SidebarSection--noPadding": "_SidebarSection--noPadding_8boj8_28", "SidebarSection-breadcrumbLabel": "_SidebarSection-breadcrumbLabel_8boj8_41", "SidebarSection-breadcrumbs": "_SidebarSection-breadcrumbs_8boj8_70", "SidebarSection-breadcrumb": "_SidebarSection-breadcrumb_8boj8_41", "SidebarSection-heading": "_SidebarSection-heading_8boj8_82", "SidebarSection-loadingOverlay": "_SidebarSection-loadingOverlay_8boj8_86" };
init_react_import();
var useBreadcrumbs = (renderCount) => {
  const selectedId = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.selectedItem) == null ? void 0 : _a5.props.id;
  });
  const config = useAppStore((s2) => s2.config);
  const path = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.state.indexes.nodes[selectedId]) == null ? void 0 : _a5.path;
  });
  const appStore = useAppStoreApi();
  return (0, import_react49.useMemo)(() => {
    const breadcrumbs = (path == null ? void 0 : path.map((zoneCompound) => {
      var _a5, _b3, _c4;
      const [componentId] = zoneCompound.split(":");
      if (componentId === "root") {
        return {
          label: "Page",
          selector: null
        };
      }
      const node = appStore.getState().state.indexes.nodes[componentId];
      const parentId = node.path[node.path.length - 1];
      const contentIds = ((_a5 = appStore.getState().state.indexes.zones[parentId]) == null ? void 0 : _a5.contentIds) || [];
      const index = contentIds.indexOf(componentId);
      const label = node ? (_c4 = (_b3 = config.components[node.data.type]) == null ? void 0 : _b3.label) != null ? _c4 : node.data.type : "Component";
      return {
        label,
        selector: node ? {
          index,
          zone: node.path[node.path.length - 1]
        } : null
      };
    })) || [];
    if (renderCount) {
      return breadcrumbs.slice(breadcrumbs.length - renderCount);
    }
    return breadcrumbs;
  }, [path, renderCount]);
};
var getClassName20 = get_class_name_factory_default("SidebarSection", styles_module_default14);
var SidebarSection = ({
  children,
  title,
  background,
  showBreadcrumbs,
  noBorderTop,
  noPadding,
  isLoading
}) => {
  const setUi = useAppStore((s2) => s2.setUi);
  const breadcrumbs = useBreadcrumbs(1);
  return (0, import_jsx_runtime30.jsxs)(
    "div",
    {
      className: getClassName20({ noBorderTop, noPadding }),
      style: { background },
      children: [
        (0, import_jsx_runtime30.jsx)("div", { className: getClassName20("title"), children: (0, import_jsx_runtime30.jsxs)("div", { className: getClassName20("breadcrumbs"), children: [
          showBreadcrumbs ? breadcrumbs.map((breadcrumb, i2) => (0, import_jsx_runtime30.jsxs)("div", { className: getClassName20("breadcrumb"), children: [
            (0, import_jsx_runtime30.jsx)(
              "button",
              {
                type: "button",
                className: getClassName20("breadcrumbLabel"),
                onClick: () => setUi({ itemSelector: breadcrumb.selector }),
                children: breadcrumb.label
              }
            ),
            (0, import_jsx_runtime30.jsx)(ChevronRight, { size: 16 })
          ] }, i2)) : null,
          (0, import_jsx_runtime30.jsx)("div", { className: getClassName20("heading"), children: (0, import_jsx_runtime30.jsx)(Heading, { rank: "2", size: "xs", children: title }) })
        ] }) }),
        (0, import_jsx_runtime30.jsx)("div", { className: getClassName20("content"), children }),
        isLoading && (0, import_jsx_runtime30.jsx)("div", { className: getClassName20("loadingOverlay"), children: (0, import_jsx_runtime30.jsx)(Loader, { size: 32 }) })
      ]
    }
  );
};
init_react_import();
var styles_module_default15 = { "Puck": "_Puck_1yxlw_19", "Puck-portal": "_Puck-portal_1yxlw_31", "PuckLayout-inner": "_PuckLayout-inner_1yxlw_38", "PuckLayout--mounted": "_PuckLayout--mounted_1yxlw_59", "PuckLayout--leftSideBarVisible": "_PuckLayout--leftSideBarVisible_1yxlw_63", "PuckLayout--rightSideBarVisible": "_PuckLayout--rightSideBarVisible_1yxlw_69", "PuckLayout-mounted": "_PuckLayout-mounted_1yxlw_83", "PuckLayout": "_PuckLayout_1yxlw_38" };
init_react_import();
init_react_import();
var styles_module_default16 = { "PuckFields": "_PuckFields_10bh7_1", "PuckFields--isLoading": "_PuckFields--isLoading_10bh7_6", "PuckFields-loadingOverlay": "_PuckFields-loadingOverlay_10bh7_10", "PuckFields-loadingOverlayInner": "_PuckFields-loadingOverlayInner_10bh7_25", "PuckFields-field": "_PuckFields-field_10bh7_32", "PuckFields--wrapFields": "_PuckFields--wrapFields_10bh7_36" };
var getClassName21 = get_class_name_factory_default("PuckFields", styles_module_default16);
var DefaultFields = ({
  children
}) => {
  return (0, import_jsx_runtime31.jsx)(import_jsx_runtime31.Fragment, { children });
};
var createOnChange = (fieldName, appStore) => (value, updatedUi) => __async(void 0, null, function* () {
  let currentProps;
  const { dispatch, state, selectedItem, resolveComponentData: resolveComponentData2 } = appStore.getState();
  const { data, ui } = state;
  const { itemSelector } = ui;
  const rootProps = data.root.props || data.root;
  if (selectedItem) {
    currentProps = selectedItem.props;
  } else {
    currentProps = rootProps;
  }
  const newProps = __spreadProps(__spreadValues({}, currentProps), {
    [fieldName]: value
  });
  if (selectedItem && itemSelector) {
    dispatch({
      type: "replace",
      destinationIndex: itemSelector.index,
      destinationZone: itemSelector.zone || rootDroppableId,
      data: (yield resolveComponentData2(
        __spreadProps(__spreadValues({}, selectedItem), { props: newProps }),
        "replace"
      )).node,
      ui: updatedUi
    });
  } else {
    if (data.root.props) {
      dispatch({
        type: "replaceRoot",
        root: (yield resolveComponentData2(
          __spreadProps(__spreadValues({}, data.root), { props: newProps }),
          "replace"
        )).node,
        ui: __spreadValues(__spreadValues({}, ui), updatedUi),
        recordHistory: true
      });
    } else {
      dispatch({
        type: "setData",
        data: { root: newProps }
      });
    }
  }
});
var FieldsChild = ({ fieldName }) => {
  const field = useAppStore((s2) => s2.fields.fields[fieldName]);
  const isReadOnly = useAppStore(
    (s2) => ((s2.selectedItem ? s2.selectedItem.readOnly : s2.state.data.root.readOnly) || {})[fieldName]
  );
  const value = useAppStore((s2) => {
    const rootProps = s2.state.data.root.props || s2.state.data.root;
    return s2.selectedItem ? s2.selectedItem.props[fieldName] : rootProps[fieldName];
  });
  const id = useAppStore((s2) => {
    if (!field)
      return null;
    return s2.selectedItem ? `${s2.selectedItem.props.id}_${field.type}_${fieldName}` : `root_${field.type}_${fieldName}`;
  });
  const permissions = useAppStore(
    useShallow((s2) => {
      const { selectedItem, permissions: permissions2 } = s2;
      return selectedItem ? permissions2.getPermissions({ item: selectedItem }) : permissions2.getPermissions({ root: true });
    })
  );
  const appStore = useAppStoreApi();
  const onChange = (0, import_react50.useCallback)(createOnChange(fieldName, appStore), [
    fieldName
  ]);
  const { visible = true } = field != null ? field : {};
  if (!field || !id || !visible)
    return null;
  if (field.type === "slot")
    return null;
  return (0, import_jsx_runtime31.jsx)("div", { className: getClassName21("field"), children: (0, import_jsx_runtime31.jsx)(
    AutoFieldPrivate,
    {
      field,
      name: fieldName,
      id,
      readOnly: !permissions.edit || isReadOnly,
      value,
      onChange
    }
  ) }, id);
};
var FieldsChildMemo = (0, import_react50.memo)(FieldsChild);
var FieldsInternal = ({ wrapFields = true }) => {
  const overrides = useAppStore((s2) => s2.overrides);
  const componentResolving = useAppStore((s2) => {
    var _a5, _b3;
    const loadingCount = s2.selectedItem ? (_a5 = s2.componentState[s2.selectedItem.props.id]) == null ? void 0 : _a5.loadingCount : (_b3 = s2.componentState["root"]) == null ? void 0 : _b3.loadingCount;
    return (loadingCount != null ? loadingCount : 0) > 0;
  });
  const itemSelector = useAppStore(useShallow((s2) => s2.state.ui.itemSelector));
  const id = useAppStore((s2) => {
    var _a5;
    return (_a5 = s2.selectedItem) == null ? void 0 : _a5.props.id;
  });
  const appStore = useAppStoreApi();
  useRegisterFieldsSlice(appStore, id);
  const fieldsLoading = useAppStore((s2) => s2.fields.loading);
  const fieldNames = useAppStore(
    useShallow((s2) => {
      if (s2.fields.id === id) {
        return Object.keys(s2.fields.fields);
      }
      return [];
    })
  );
  const isLoading = fieldsLoading || componentResolving;
  const Wrapper = (0, import_react50.useMemo)(() => overrides.fields || DefaultFields, [overrides]);
  return (0, import_jsx_runtime31.jsxs)(
    "form",
    {
      className: getClassName21({ wrapFields }),
      onSubmit: (e3) => {
        e3.preventDefault();
      },
      children: [
        (0, import_jsx_runtime31.jsx)(Wrapper, { isLoading, itemSelector, children: fieldNames.map((fieldName) => (0, import_jsx_runtime31.jsx)(FieldsChildMemo, { fieldName }, fieldName)) }),
        isLoading && (0, import_jsx_runtime31.jsx)("div", { className: getClassName21("loadingOverlay"), children: (0, import_jsx_runtime31.jsx)("div", { className: getClassName21("loadingOverlayInner"), children: (0, import_jsx_runtime31.jsx)(Loader, { size: 16 }) }) })
      ]
    }
  );
};
var Fields = (0, import_react50.memo)(FieldsInternal);
init_react_import();
init_react_import();
init_react_import();
init_react_import();
var styles_module_default17 = { "ComponentList": "_ComponentList_1rrlt_1", "ComponentList--isExpanded": "_ComponentList--isExpanded_1rrlt_5", "ComponentList-content": "_ComponentList-content_1rrlt_9", "ComponentList-title": "_ComponentList-title_1rrlt_17", "ComponentList-titleIcon": "_ComponentList-titleIcon_1rrlt_53" };
var getClassName22 = get_class_name_factory_default("ComponentList", styles_module_default17);
var ComponentListItem = ({
  name,
  label
}) => {
  var _a5;
  const overrides = useAppStore((s2) => s2.overrides);
  const canInsert = useAppStore(
    (s2) => s2.permissions.getPermissions({
      type: name
    }).insert
  );
  (0, import_react52.useEffect)(() => {
    if (overrides.componentItem) {
      console.warn(
        "The `componentItem` override has been deprecated and renamed to `drawerItem`"
      );
    }
  }, [overrides]);
  return (0, import_jsx_runtime32.jsx)(Drawer.Item, { label, name, isDragDisabled: !canInsert, children: (_a5 = overrides.componentItem) != null ? _a5 : overrides.drawerItem });
};
var ComponentList = ({
  children,
  title,
  id
}) => {
  const config = useAppStore((s2) => s2.config);
  const setUi = useAppStore((s2) => s2.setUi);
  const componentList = useAppStore((s2) => s2.state.ui.componentList);
  const { expanded = true } = componentList[id] || {};
  return (0, import_jsx_runtime32.jsxs)("div", { className: getClassName22({ isExpanded: expanded }), children: [
    title && (0, import_jsx_runtime32.jsxs)(
      "button",
      {
        type: "button",
        className: getClassName22("title"),
        onClick: () => setUi({
          componentList: __spreadProps(__spreadValues({}, componentList), {
            [id]: __spreadProps(__spreadValues({}, componentList[id]), {
              expanded: !expanded
            })
          })
        }),
        title: expanded ? `Collapse${title ? ` ${title}` : ""}` : `Expand${title ? ` ${title}` : ""}`,
        children: [
          (0, import_jsx_runtime32.jsx)("div", { children: title }),
          (0, import_jsx_runtime32.jsx)("div", { className: getClassName22("titleIcon"), children: expanded ? (0, import_jsx_runtime32.jsx)(ChevronUp, { size: 12 }) : (0, import_jsx_runtime32.jsx)(ChevronDown, { size: 12 }) })
        ]
      }
    ),
    (0, import_jsx_runtime32.jsx)("div", { className: getClassName22("content"), children: (0, import_jsx_runtime32.jsx)(Drawer, { children: children || Object.keys(config.components).map((componentKey) => {
      var _a5;
      return (0, import_jsx_runtime32.jsx)(
        ComponentListItem,
        {
          label: (_a5 = config.components[componentKey]["label"]) != null ? _a5 : componentKey,
          name: componentKey
        },
        componentKey
      );
    }) }) })
  ] });
};
ComponentList.Item = ComponentListItem;
var useComponentList = () => {
  const [componentList, setComponentList] = (0, import_react51.useState)();
  const config = useAppStore((s2) => s2.config);
  const uiComponentList = useAppStore((s2) => s2.state.ui.componentList);
  (0, import_react51.useEffect)(() => {
    var _a5, _b3, _c4;
    if (Object.keys(uiComponentList).length > 0) {
      const matchedComponents = [];
      let _componentList;
      _componentList = Object.entries(uiComponentList).map(
        ([categoryKey, category]) => {
          if (category.visible === false || !category.components) {
            return null;
          }
          return (0, import_jsx_runtime33.jsx)(
            ComponentList,
            {
              id: categoryKey,
              title: category.title || categoryKey,
              children: category.components.map((componentName, i2) => {
                var _a23;
                matchedComponents.push(componentName);
                const componentConf = config.components[componentName] || {};
                return (0, import_jsx_runtime33.jsx)(
                  ComponentList.Item,
                  {
                    label: (_a23 = componentConf["label"]) != null ? _a23 : componentName,
                    name: componentName,
                    index: i2
                  },
                  componentName
                );
              })
            },
            categoryKey
          );
        }
      );
      const remainingComponents = Object.keys(config.components).filter(
        (component) => matchedComponents.indexOf(component) === -1
      );
      if (remainingComponents.length > 0 && !((_a5 = uiComponentList.other) == null ? void 0 : _a5.components) && ((_b3 = uiComponentList.other) == null ? void 0 : _b3.visible) !== false) {
        _componentList.push(
          (0, import_jsx_runtime33.jsx)(
            ComponentList,
            {
              id: "other",
              title: ((_c4 = uiComponentList.other) == null ? void 0 : _c4.title) || "Other",
              children: remainingComponents.map((componentName, i2) => {
                var _a23;
                const componentConf = config.components[componentName] || {};
                return (0, import_jsx_runtime33.jsx)(
                  ComponentList.Item,
                  {
                    name: componentName,
                    label: (_a23 = componentConf["label"]) != null ? _a23 : componentName,
                    index: i2
                  },
                  componentName
                );
              })
            },
            "other"
          )
        );
      }
      setComponentList(_componentList);
    }
  }, [config.categories, config.components, uiComponentList]);
  return componentList;
};
var Components = () => {
  const overrides = useAppStore((s2) => s2.overrides);
  const componentList = useComponentList();
  const Wrapper = (0, import_react53.useMemo)(() => {
    if (overrides.components) {
      console.warn(
        "The `components` override has been deprecated and renamed to `drawer`"
      );
    }
    return overrides.components || overrides.drawer || "div";
  }, [overrides]);
  return (0, import_jsx_runtime34.jsx)(Wrapper, { children: componentList ? componentList : (0, import_jsx_runtime34.jsx)(ComponentList, { id: "all" }) });
};
init_react_import();
init_react_import();
var styleSelector = 'style, link[rel="stylesheet"]';
var collectStyles = (doc) => {
  const collected = [];
  doc.querySelectorAll(styleSelector).forEach((style) => {
    if (style.tagName === "STYLE") {
      const hasContent = !!style.innerHTML.trim();
      if (hasContent) {
        collected.push(style);
      }
    } else {
      collected.push(style);
    }
  });
  return collected;
};
var getStyleSheet = (el) => {
  return Array.from(document.styleSheets).find((ss) => {
    const ownerNode = ss.ownerNode;
    return ownerNode.href === el.href;
  });
};
var getStyles = (styleSheet) => {
  if (styleSheet) {
    try {
      return [...Array.from(styleSheet.cssRules)].map((rule) => rule.cssText).join("");
    } catch (e3) {
      console.warn(
        "Access to stylesheet %s is denied. Ignoring…",
        styleSheet.href
      );
    }
  }
  return "";
};
var syncAttributes = (sourceElement, targetElement) => {
  const attributes = sourceElement.attributes;
  if ((attributes == null ? void 0 : attributes.length) > 0) {
    Array.from(attributes).forEach((attribute) => {
      targetElement.setAttribute(attribute.name, attribute.value);
    });
  }
};
var defer = (fn) => setTimeout(fn, 0);
var CopyHostStyles = ({
  children,
  debug = false,
  onStylesLoaded = () => null
}) => {
  const { document: doc, window: win } = useFrame();
  (0, import_react55.useEffect)(() => {
    if (!win || !doc) {
      return () => {
      };
    }
    let elements = [];
    const hashes = {};
    const lookupEl = (el) => elements.findIndex((elementMap) => elementMap.original === el);
    const mirrorEl = (el, inlineStyles = false) => __async(void 0, null, function* () {
      let mirror;
      if (el.nodeName === "LINK" && inlineStyles) {
        mirror = document.createElement("style");
        mirror.type = "text/css";
        let styleSheet = getStyleSheet(el);
        if (!styleSheet) {
          yield new Promise((resolve) => {
            const fn = () => {
              resolve();
              el.removeEventListener("load", fn);
            };
            el.addEventListener("load", fn);
          });
          styleSheet = getStyleSheet(el);
        }
        const styles2 = getStyles(styleSheet);
        if (!styles2) {
          if (debug) {
            console.warn(
              `Tried to load styles for link element, but couldn't find them. Skipping...`
            );
          }
          return;
        }
        mirror.innerHTML = styles2;
        mirror.setAttribute("data-href", el.getAttribute("href"));
      } else {
        mirror = el.cloneNode(true);
      }
      return mirror;
    });
    const addEl = (el) => __async(void 0, null, function* () {
      const index = lookupEl(el);
      if (index > -1) {
        if (debug)
          console.log(
            `Tried to add an element that was already mirrored. Updating instead...`
          );
        elements[index].mirror.innerText = el.innerText;
        return;
      }
      const mirror = yield mirrorEl(el);
      if (!mirror) {
        return;
      }
      const elHash = (0, import_object_hash.default)(mirror.outerHTML);
      if (hashes[elHash]) {
        if (debug)
          console.log(
            `iframe already contains element that is being mirrored. Skipping...`
          );
        return;
      }
      hashes[elHash] = true;
      doc.head.append(mirror);
      elements.push({ original: el, mirror });
      if (debug)
        console.log(`Added style node ${el.outerHTML}`);
    });
    const removeEl = (el) => {
      var _a5, _b3;
      const index = lookupEl(el);
      if (index === -1) {
        if (debug)
          console.log(
            `Tried to remove an element that did not exist. Skipping...`
          );
        return;
      }
      const elHash = (0, import_object_hash.default)(el.outerHTML);
      (_b3 = (_a5 = elements[index]) == null ? void 0 : _a5.mirror) == null ? void 0 : _b3.remove();
      delete hashes[elHash];
      if (debug)
        console.log(`Removed style node ${el.outerHTML}`);
    };
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
              const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
              if (el && el.matches(styleSelector)) {
                defer(() => addEl(el));
              }
            }
          });
          mutation.removedNodes.forEach((node) => {
            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {
              const el = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
              if (el && el.matches(styleSelector)) {
                defer(() => removeEl(el));
              }
            }
          });
        }
      });
    });
    const parentDocument = win.parent.document;
    const collectedStyles = collectStyles(parentDocument);
    const hrefs = [];
    let stylesLoaded = 0;
    const parentHtml = parentDocument.getElementsByTagName("html")[0];
    syncAttributes(parentHtml, doc.documentElement);
    const parentBody = parentDocument.getElementsByTagName("body")[0];
    syncAttributes(parentBody, doc.body);
    Promise.all(
      collectedStyles.map((styleNode, i2) => __async(void 0, null, function* () {
        if (styleNode.nodeName === "LINK") {
          const linkHref = styleNode.href;
          if (hrefs.indexOf(linkHref) > -1) {
            return;
          }
          hrefs.push(linkHref);
        }
        const mirror = yield mirrorEl(styleNode);
        if (!mirror)
          return;
        elements.push({ original: styleNode, mirror });
        return mirror;
      }))
    ).then((mirrorStyles) => {
      const filtered = mirrorStyles.filter(
        (el) => typeof el !== "undefined"
      );
      filtered.forEach((mirror) => {
        mirror.onload = () => {
          stylesLoaded = stylesLoaded + 1;
          if (stylesLoaded >= elements.length) {
            onStylesLoaded();
          }
        };
        mirror.onerror = () => {
          console.warn(`AutoFrame couldn't load a stylesheet`);
          stylesLoaded = stylesLoaded + 1;
          if (stylesLoaded >= elements.length) {
            onStylesLoaded();
          }
        };
      });
      doc.head.innerHTML = "";
      doc.head.append(...filtered);
      observer.observe(parentDocument.head, { childList: true, subtree: true });
      filtered.forEach((el) => {
        const elHash = (0, import_object_hash.default)(el.outerHTML);
        hashes[elHash] = true;
      });
    });
    return () => {
      observer.disconnect();
    };
  }, []);
  return (0, import_jsx_runtime35.jsx)(import_jsx_runtime35.Fragment, { children });
};
var autoFrameContext = (0, import_react55.createContext)({});
var useFrame = () => (0, import_react55.useContext)(autoFrameContext);
function AutoFrame(_a5) {
  var _b3 = _a5, {
    children,
    className,
    debug,
    id,
    onReady = () => {
    },
    onNotReady = () => {
    },
    frameRef
  } = _b3, props = __objRest(_b3, [
    "children",
    "className",
    "debug",
    "id",
    "onReady",
    "onNotReady",
    "frameRef"
  ]);
  const [loaded, setLoaded] = (0, import_react55.useState)(false);
  const [ctx, setCtx] = (0, import_react55.useState)({});
  const [mountTarget, setMountTarget] = (0, import_react55.useState)();
  const [stylesLoaded, setStylesLoaded] = (0, import_react55.useState)(false);
  (0, import_react55.useEffect)(() => {
    var _a23;
    if (frameRef.current) {
      const doc = frameRef.current.contentDocument;
      const win = frameRef.current.contentWindow;
      setCtx({
        document: doc || void 0,
        window: win || void 0
      });
      setMountTarget(
        (_a23 = frameRef.current.contentDocument) == null ? void 0 : _a23.getElementById("frame-root")
      );
      if (doc && win && stylesLoaded) {
        onReady();
      } else {
        onNotReady();
      }
    }
  }, [frameRef, loaded, stylesLoaded]);
  return (0, import_jsx_runtime35.jsx)(
    "iframe",
    __spreadProps(__spreadValues({}, props), {
      className,
      id,
      srcDoc: '<!DOCTYPE html><html><head></head><body><div id="frame-root" data-puck-entry></div></body></html>',
      ref: frameRef,
      onLoad: () => {
        setLoaded(true);
      },
      children: (0, import_jsx_runtime35.jsx)(autoFrameContext.Provider, { value: ctx, children: loaded && mountTarget && (0, import_jsx_runtime35.jsx)(
        CopyHostStyles,
        {
          debug,
          onStylesLoaded: () => setStylesLoaded(true),
          children: (0, import_react_dom4.createPortal)(children, mountTarget)
        }
      ) })
    })
  );
}
AutoFrame.displayName = "AutoFrame";
var AutoFrame_default = AutoFrame;
init_react_import();
var styles_module_default18 = { "PuckPreview": "_PuckPreview_z2rgu_1", "PuckPreview-frame": "_PuckPreview-frame_z2rgu_6" };
var getClassName23 = get_class_name_factory_default("PuckPreview", styles_module_default18);
var useBubbleIframeEvents = (ref) => {
  const status = useAppStore((s2) => s2.status);
  (0, import_react54.useEffect)(() => {
    if (ref.current && status === "READY") {
      const iframe = ref.current;
      const handlePointerMove = (event) => {
        const evt = new BubbledPointerEvent("pointermove", __spreadProps(__spreadValues({}, event), {
          bubbles: true,
          cancelable: false,
          clientX: event.clientX,
          clientY: event.clientY,
          originalTarget: event.target
        }));
        iframe.dispatchEvent(evt);
      };
      const register = () => {
        var _a5;
        unregister();
        (_a5 = iframe.contentDocument) == null ? void 0 : _a5.addEventListener(
          "pointermove",
          handlePointerMove,
          {
            capture: true
          }
        );
      };
      const unregister = () => {
        var _a5;
        (_a5 = iframe.contentDocument) == null ? void 0 : _a5.removeEventListener(
          "pointermove",
          handlePointerMove
        );
      };
      register();
      return () => {
        unregister();
      };
    }
  }, [status]);
};
var Preview2 = ({ id = "puck-preview" }) => {
  const dispatch = useAppStore((s2) => s2.dispatch);
  const root = useAppStore((s2) => s2.state.data.root);
  const config = useAppStore((s2) => s2.config);
  const setStatus = useAppStore((s2) => s2.setStatus);
  const iframe = useAppStore((s2) => s2.iframe);
  const overrides = useAppStore((s2) => s2.overrides);
  const metadata = useAppStore((s2) => s2.metadata);
  const renderData = useAppStore(
    (s2) => s2.state.ui.previewMode === "edit" ? null : s2.state.data
  );
  const Page = (0, import_react54.useCallback)(
    (pageProps) => {
      var _a5, _b3;
      const propsWithSlots = useSlots(
        config,
        { type: "root", props: pageProps },
        DropZoneEditPure
      );
      return ((_a5 = config.root) == null ? void 0 : _a5.render) ? (_b3 = config.root) == null ? void 0 : _b3.render(__spreadValues({
        id: "puck-root"
      }, propsWithSlots)) : (0, import_jsx_runtime36.jsx)(import_jsx_runtime36.Fragment, { children: propsWithSlots.children });
    },
    [config]
  );
  const Frame = (0, import_react54.useMemo)(() => overrides.iframe, [overrides]);
  const rootProps = root.props || root;
  const ref = (0, import_react54.useRef)(null);
  useBubbleIframeEvents(ref);
  const inner = !renderData ? (0, import_jsx_runtime36.jsx)(
    Page,
    __spreadProps(__spreadValues({}, rootProps), {
      puck: {
        renderDropZone: DropZonePure,
        isEditing: true,
        dragRef: null,
        metadata
      },
      editMode: true,
      children: (0, import_jsx_runtime36.jsx)(DropZonePure, { zone: rootDroppableId })
    })
  ) : (0, import_jsx_runtime36.jsx)(Render, { data: renderData, config, metadata });
  (0, import_react54.useEffect)(() => {
    if (!iframe.enabled) {
      setStatus("READY");
    }
  }, [iframe.enabled]);
  return (0, import_jsx_runtime36.jsx)(
    "div",
    {
      className: getClassName23(),
      id,
      "data-puck-preview": true,
      onClick: (e3) => {
        const el = e3.target;
        if (!el.hasAttribute("data-puck-component") && !el.hasAttribute("data-puck-dropzone")) {
          dispatch({ type: "setUi", ui: { itemSelector: null } });
        }
      },
      children: iframe.enabled ? (0, import_jsx_runtime36.jsx)(
        AutoFrame_default,
        {
          id: "preview-frame",
          className: getClassName23("frame"),
          "data-rfd-iframe": true,
          onReady: () => {
            setStatus("READY");
          },
          onNotReady: () => {
            setStatus("MOUNTED");
          },
          frameRef: ref,
          children: (0, import_jsx_runtime36.jsx)(autoFrameContext.Consumer, { children: ({ document: document2 }) => {
            if (Frame) {
              return (0, import_jsx_runtime36.jsx)(Frame, { document: document2, children: inner });
            }
            return inner;
          } })
        }
      ) : (0, import_jsx_runtime36.jsx)(
        "div",
        {
          id: "preview-frame",
          className: getClassName23("frame"),
          ref,
          "data-puck-entry": true,
          children: inner
        }
      )
    }
  );
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default19 = { "LayerTree": "_LayerTree_7rx04_1", "LayerTree-zoneTitle": "_LayerTree-zoneTitle_7rx04_11", "LayerTree-helper": "_LayerTree-helper_7rx04_17", "Layer": "_Layer_7rx04_1", "Layer-inner": "_Layer-inner_7rx04_29", "Layer--containsZone": "_Layer--containsZone_7rx04_35", "Layer-clickable": "_Layer-clickable_7rx04_39", "Layer--isSelected": "_Layer--isSelected_7rx04_61", "Layer-chevron": "_Layer-chevron_7rx04_77", "Layer--childIsSelected": "_Layer--childIsSelected_7rx04_78", "Layer-zones": "_Layer-zones_7rx04_82", "Layer-title": "_Layer-title_7rx04_96", "Layer-name": "_Layer-name_7rx04_105", "Layer-icon": "_Layer-icon_7rx04_111", "Layer-zoneIcon": "_Layer-zoneIcon_7rx04_116" };
init_react_import();
var scrollIntoView = (el) => {
  const oldStyle = __spreadValues({}, el.style);
  el.style.scrollMargin = "256px";
  if (el) {
    el == null ? void 0 : el.scrollIntoView({ behavior: "smooth" });
    el.style.scrollMargin = oldStyle.scrollMargin || "";
  }
};
init_react_import();
var onScrollEnd = (frame, cb) => {
  let scrollTimeout;
  const callback = function() {
    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(function() {
      cb();
      frame == null ? void 0 : frame.removeEventListener("scroll", callback);
    }, 50);
  };
  frame == null ? void 0 : frame.addEventListener("scroll", callback);
  setTimeout(() => {
    if (!scrollTimeout) {
      cb();
    }
  }, 50);
};
var getClassName24 = get_class_name_factory_default("LayerTree", styles_module_default19);
var getClassNameLayer = get_class_name_factory_default("Layer", styles_module_default19);
var Layer = ({
  index,
  itemId,
  zoneCompound
}) => {
  var _a5;
  const config = useAppStore((s2) => s2.config);
  const itemSelector = useAppStore((s2) => s2.state.ui.itemSelector);
  const dispatch = useAppStore((s2) => s2.dispatch);
  const setItemSelector = (0, import_react56.useCallback)(
    (itemSelector2) => {
      dispatch({ type: "setUi", ui: { itemSelector: itemSelector2 } });
    },
    [dispatch]
  );
  const selecedItemId = useAppStore((s2) => {
    var _a23;
    return (_a23 = s2.selectedItem) == null ? void 0 : _a23.props.id;
  });
  const isSelected = selecedItemId === itemId || itemSelector && itemSelector.zone === rootDroppableId && !zoneCompound;
  const nodeData = useAppStore((s2) => s2.state.indexes.nodes[itemId]);
  const zonesForItem = useAppStore(
    useShallow(
      (s2) => Object.keys(s2.state.indexes.zones).filter(
        (z) => z.split(":")[0] === itemId
      )
    )
  );
  const containsZone = zonesForItem.length > 0;
  const zoneStore = (0, import_react56.useContext)(ZoneStoreContext);
  const isHovering = useContextStore(
    ZoneStoreContext,
    (s2) => s2.hoveringComponent === itemId
  );
  const childIsSelected = useAppStore((s2) => {
    var _a23, _b3;
    const selectedData = s2.state.indexes.nodes[(_a23 = s2.selectedItem) == null ? void 0 : _a23.props.id];
    return (_b3 = selectedData == null ? void 0 : selectedData.path.some((candidate) => {
      const [candidateId] = candidate.split(":");
      return candidateId === itemId;
    })) != null ? _b3 : false;
  });
  const componentConfig = config.components[nodeData.data.type];
  const label = (_a5 = componentConfig == null ? void 0 : componentConfig["label"]) != null ? _a5 : nodeData.data.type.toString();
  return (0, import_jsx_runtime37.jsxs)(
    "li",
    {
      className: getClassNameLayer({
        isSelected,
        isHovering,
        containsZone,
        childIsSelected
      }),
      children: [
        (0, import_jsx_runtime37.jsx)("div", { className: getClassNameLayer("inner"), children: (0, import_jsx_runtime37.jsxs)(
          "button",
          {
            type: "button",
            className: getClassNameLayer("clickable"),
            onClick: () => {
              if (isSelected) {
                setItemSelector(null);
                return;
              }
              const frame = getFrame();
              const el = frame == null ? void 0 : frame.querySelector(
                `[data-puck-component="${itemId}"]`
              );
              if (!el) {
                setItemSelector({
                  index,
                  zone: zoneCompound
                });
                return;
              }
              scrollIntoView(el);
              onScrollEnd(frame, () => {
                setItemSelector({
                  index,
                  zone: zoneCompound
                });
              });
            },
            onMouseEnter: (e3) => {
              e3.stopPropagation();
              zoneStore.setState({ hoveringComponent: itemId });
            },
            onMouseLeave: (e3) => {
              e3.stopPropagation();
              zoneStore.setState({ hoveringComponent: null });
            },
            children: [
              containsZone && (0, import_jsx_runtime37.jsx)(
                "div",
                {
                  className: getClassNameLayer("chevron"),
                  title: isSelected ? "Collapse" : "Expand",
                  children: (0, import_jsx_runtime37.jsx)(ChevronDown, { size: "12" })
                }
              ),
              (0, import_jsx_runtime37.jsxs)("div", { className: getClassNameLayer("title"), children: [
                (0, import_jsx_runtime37.jsx)("div", { className: getClassNameLayer("icon"), children: nodeData.data.type === "Text" || nodeData.data.type === "Heading" ? (0, import_jsx_runtime37.jsx)(Type, { size: "16" }) : (0, import_jsx_runtime37.jsx)(LayoutGrid, { size: "16" }) }),
                (0, import_jsx_runtime37.jsx)("div", { className: getClassNameLayer("name"), children: label })
              ] })
            ]
          }
        ) }),
        containsZone && zonesForItem.map((subzone) => (0, import_jsx_runtime37.jsx)("div", { className: getClassNameLayer("zones"), children: (0, import_jsx_runtime37.jsx)(LayerTree, { zoneCompound: subzone }) }, subzone))
      ]
    }
  );
};
var LayerTree = ({
  label: _label,
  zoneCompound
}) => {
  const label = useAppStore((s2) => {
    var _a5, _b3, _c4, _d2;
    if (_label)
      return _label;
    if (zoneCompound === rootDroppableId)
      return;
    const [componentId, slotId] = zoneCompound.split(":");
    const componentType = (_a5 = s2.state.indexes.nodes[componentId]) == null ? void 0 : _a5.data.type;
    const configForComponent = componentType && componentType !== rootAreaId ? s2.config.components[componentType] : s2.config.root;
    return (_d2 = (_c4 = (_b3 = configForComponent == null ? void 0 : configForComponent.fields) == null ? void 0 : _b3[slotId]) == null ? void 0 : _c4.label) != null ? _d2 : slotId;
  });
  const contentIds = useAppStore(
    useShallow(
      (s2) => {
        var _a5, _b3;
        return zoneCompound ? (_b3 = (_a5 = s2.state.indexes.zones[zoneCompound]) == null ? void 0 : _a5.contentIds) != null ? _b3 : [] : [];
      }
    )
  );
  return (0, import_jsx_runtime37.jsxs)(import_jsx_runtime37.Fragment, { children: [
    label && (0, import_jsx_runtime37.jsxs)("div", { className: getClassName24("zoneTitle"), children: [
      (0, import_jsx_runtime37.jsx)("div", { className: getClassName24("zoneIcon"), children: (0, import_jsx_runtime37.jsx)(Layers, { size: "16" }) }),
      label
    ] }),
    (0, import_jsx_runtime37.jsxs)("ul", { className: getClassName24(), children: [
      contentIds.length === 0 && (0, import_jsx_runtime37.jsx)("div", { className: getClassName24("helper"), children: "No items" }),
      contentIds.map((itemId, i2) => {
        return (0, import_jsx_runtime37.jsx)(
          Layer,
          {
            index: i2,
            itemId,
            zoneCompound
          },
          itemId
        );
      })
    ] })
  ] });
};
init_react_import();
var findZonesForArea = (state, area) => {
  return Object.keys(state.indexes.zones).filter(
    (zone) => zone.split(":")[0] === area
  );
};
var Outline = () => {
  const outlineOverride = useAppStore((s2) => s2.overrides.outline);
  const rootZones = useAppStore(
    useShallow((s2) => findZonesForArea(s2.state, "root"))
  );
  const Wrapper = (0, import_react57.useMemo)(() => outlineOverride || "div", [outlineOverride]);
  return (0, import_jsx_runtime38.jsx)(Wrapper, { children: rootZones.map((zoneCompound) => (0, import_jsx_runtime38.jsx)(
    LayerTree,
    {
      label: rootZones.length === 1 ? "" : zoneCompound.split(":")[1],
      zoneCompound
    },
    zoneCompound
  )) });
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default20 = { "ViewportControls": "_ViewportControls_gejzr_1", "ViewportControls-divider": "_ViewportControls-divider_gejzr_15", "ViewportControls-zoomSelect": "_ViewportControls-zoomSelect_gejzr_21", "ViewportButton--isActive": "_ViewportButton--isActive_gejzr_38", "ViewportButton-inner": "_ViewportButton-inner_gejzr_38" };
var icons = {
  Smartphone: (0, import_jsx_runtime39.jsx)(Smartphone, { size: 16 }),
  Tablet: (0, import_jsx_runtime39.jsx)(Tablet, { size: 16 }),
  Monitor: (0, import_jsx_runtime39.jsx)(Monitor2, { size: 16 })
};
var getClassName25 = get_class_name_factory_default("ViewportControls", styles_module_default20);
var getClassNameButton = get_class_name_factory_default("ViewportButton", styles_module_default20);
var ViewportButton = ({
  children,
  height = "auto",
  title,
  width,
  onClick
}) => {
  const viewports = useAppStore((s2) => s2.state.ui.viewports);
  const [isActive, setIsActive] = (0, import_react59.useState)(false);
  (0, import_react59.useEffect)(() => {
    setIsActive(width === viewports.current.width);
  }, [width, viewports.current.width]);
  return (0, import_jsx_runtime39.jsx)("span", { className: getClassNameButton({ isActive }), children: (0, import_jsx_runtime39.jsx)(
    IconButton,
    {
      type: "button",
      title,
      disabled: isActive,
      onClick: (e3) => {
        e3.stopPropagation();
        onClick({ width, height });
      },
      children: (0, import_jsx_runtime39.jsx)("span", { className: getClassNameButton("inner"), children })
    }
  ) });
};
var defaultZoomOptions = [
  { label: "25%", value: 0.25 },
  { label: "50%", value: 0.5 },
  { label: "75%", value: 0.75 },
  { label: "100%", value: 1 },
  { label: "125%", value: 1.25 },
  { label: "150%", value: 1.5 },
  { label: "200%", value: 2 }
];
var ViewportControls = ({
  autoZoom,
  zoom,
  onViewportChange,
  onZoom
}) => {
  var _a5, _b3;
  const viewports = useAppStore((s2) => s2.viewports);
  const defaultsContainAutoZoom = defaultZoomOptions.find(
    (option) => option.value === autoZoom
  );
  const zoomOptions = (0, import_react59.useMemo)(
    () => [
      ...defaultZoomOptions,
      ...defaultsContainAutoZoom ? [] : [
        {
          value: autoZoom,
          label: `${(autoZoom * 100).toFixed(0)}% (Auto)`
        }
      ]
    ].filter((a2) => a2.value <= autoZoom).sort((a2, b2) => a2.value > b2.value ? 1 : -1),
    [autoZoom]
  );
  return (0, import_jsx_runtime39.jsxs)("div", { className: getClassName25(), children: [
    viewports.map((viewport, i2) => (0, import_jsx_runtime39.jsx)(
      ViewportButton,
      {
        height: viewport.height,
        width: viewport.width,
        title: viewport.label ? `Switch to ${viewport.label} viewport` : "Switch viewport",
        onClick: onViewportChange,
        children: typeof viewport.icon === "string" ? icons[viewport.icon] || viewport.icon : viewport.icon || icons.Smartphone
      },
      i2
    )),
    (0, import_jsx_runtime39.jsx)("div", { className: getClassName25("divider") }),
    (0, import_jsx_runtime39.jsx)(
      IconButton,
      {
        type: "button",
        title: "Zoom viewport out",
        disabled: zoom <= ((_a5 = zoomOptions[0]) == null ? void 0 : _a5.value),
        onClick: (e3) => {
          e3.stopPropagation();
          onZoom(
            zoomOptions[Math.max(
              zoomOptions.findIndex((option) => option.value === zoom) - 1,
              0
            )].value
          );
        },
        children: (0, import_jsx_runtime39.jsx)(ZoomOut, { size: 16 })
      }
    ),
    (0, import_jsx_runtime39.jsx)(
      IconButton,
      {
        type: "button",
        title: "Zoom viewport in",
        disabled: zoom >= ((_b3 = zoomOptions[zoomOptions.length - 1]) == null ? void 0 : _b3.value),
        onClick: (e3) => {
          e3.stopPropagation();
          onZoom(
            zoomOptions[Math.min(
              zoomOptions.findIndex((option) => option.value === zoom) + 1,
              zoomOptions.length - 1
            )].value
          );
        },
        children: (0, import_jsx_runtime39.jsx)(ZoomIn, { size: 16 })
      }
    ),
    (0, import_jsx_runtime39.jsx)("div", { className: getClassName25("divider") }),
    (0, import_jsx_runtime39.jsx)(
      "select",
      {
        className: getClassName25("zoomSelect"),
        value: zoom.toString(),
        onChange: (e3) => {
          onZoom(parseFloat(e3.currentTarget.value));
        },
        children: zoomOptions.map((option) => (0, import_jsx_runtime39.jsx)(
          "option",
          {
            value: option.value,
            label: option.label
          },
          option.label
        ))
      }
    )
  ] });
};
init_react_import();
var styles_module_default21 = { "PuckCanvas": "_PuckCanvas_18jay_1", "PuckCanvas-controls": "_PuckCanvas-controls_18jay_16", "PuckCanvas-inner": "_PuckCanvas-inner_18jay_21", "PuckCanvas-root": "_PuckCanvas-root_18jay_30", "PuckCanvas--ready": "_PuckCanvas--ready_18jay_55", "PuckCanvas-loader": "_PuckCanvas-loader_18jay_60", "PuckCanvas--showLoader": "_PuckCanvas--showLoader_18jay_70" };
init_react_import();
var FrameContext = (0, import_react60.createContext)(null);
var FrameProvider = ({
  children
}) => {
  const frameRef = (0, import_react60.useRef)(null);
  const value = (0, import_react60.useMemo)(
    () => ({
      frameRef
    }),
    []
  );
  return (0, import_jsx_runtime40.jsx)(FrameContext.Provider, { value, children });
};
var useCanvasFrame = () => {
  const context = (0, import_react60.useContext)(FrameContext);
  if (context === null) {
    throw new Error("useCanvasFrame must be used within a FrameProvider");
  }
  return context;
};
var getClassName26 = get_class_name_factory_default("PuckCanvas", styles_module_default21);
var ZOOM_ON_CHANGE = true;
var TRANSITION_DURATION = 150;
var Canvas = () => {
  const { frameRef } = useCanvasFrame();
  const resetAutoZoom = useResetAutoZoom(frameRef);
  const {
    dispatch,
    overrides,
    setUi,
    zoomConfig,
    setZoomConfig,
    status,
    iframe
  } = useAppStore(
    useShallow((s2) => ({
      dispatch: s2.dispatch,
      overrides: s2.overrides,
      setUi: s2.setUi,
      zoomConfig: s2.zoomConfig,
      setZoomConfig: s2.setZoomConfig,
      status: s2.status,
      iframe: s2.iframe
    }))
  );
  const {
    leftSideBarVisible,
    rightSideBarVisible,
    leftSideBarWidth,
    rightSideBarWidth,
    viewports
  } = useAppStore(
    useShallow((s2) => ({
      leftSideBarVisible: s2.state.ui.leftSideBarVisible,
      rightSideBarVisible: s2.state.ui.rightSideBarVisible,
      leftSideBarWidth: s2.state.ui.leftSideBarWidth,
      rightSideBarWidth: s2.state.ui.rightSideBarWidth,
      viewports: s2.state.ui.viewports
    }))
  );
  const [showTransition, setShowTransition] = (0, import_react58.useState)(false);
  const isResizingRef = (0, import_react58.useRef)(false);
  const defaultRender = (0, import_react58.useMemo)(() => {
    const PuckDefault = ({ children }) => (0, import_jsx_runtime41.jsx)(import_jsx_runtime41.Fragment, { children });
    return PuckDefault;
  }, []);
  const CustomPreview = (0, import_react58.useMemo)(
    () => overrides.preview || defaultRender,
    [overrides]
  );
  const getFrameDimensions = (0, import_react58.useCallback)(() => {
    if (frameRef.current) {
      const frame = frameRef.current;
      const box = getBox(frame);
      return { width: box.contentBox.width, height: box.contentBox.height };
    }
    return { width: 0, height: 0 };
  }, [frameRef]);
  (0, import_react58.useEffect)(() => {
    resetAutoZoom();
  }, [
    frameRef,
    leftSideBarVisible,
    rightSideBarVisible,
    leftSideBarWidth,
    rightSideBarWidth,
    viewports
  ]);
  (0, import_react58.useEffect)(() => {
    const { height: frameHeight } = getFrameDimensions();
    if (viewports.current.height === "auto") {
      setZoomConfig(__spreadProps(__spreadValues({}, zoomConfig), {
        rootHeight: frameHeight / zoomConfig.zoom
      }));
    }
  }, [zoomConfig.zoom, getFrameDimensions, setZoomConfig]);
  (0, import_react58.useEffect)(() => {
    if (ZOOM_ON_CHANGE) {
      resetAutoZoom();
    }
  }, [viewports.current.width, viewports]);
  (0, import_react58.useEffect)(() => {
    if (!frameRef.current)
      return;
    const resizeObserver = new ResizeObserver(() => {
      if (!isResizingRef.current) {
        resetAutoZoom();
      }
    });
    resizeObserver.observe(frameRef.current);
    return () => {
      resizeObserver.disconnect();
    };
  }, [frameRef.current]);
  const [showLoader, setShowLoader] = (0, import_react58.useState)(false);
  (0, import_react58.useEffect)(() => {
    setTimeout(() => {
      setShowLoader(true);
    }, 500);
  }, []);
  return (0, import_jsx_runtime41.jsxs)(
    "div",
    {
      className: getClassName26({
        ready: status === "READY" || !iframe.enabled || !iframe.waitForStyles,
        showLoader
      }),
      onClick: (e3) => {
        const el = e3.target;
        if (!el.hasAttribute("data-puck-component") && !el.hasAttribute("data-puck-dropzone")) {
          dispatch({
            type: "setUi",
            ui: { itemSelector: null },
            recordHistory: true
          });
        }
      },
      children: [
        viewports.controlsVisible && iframe.enabled && (0, import_jsx_runtime41.jsx)("div", { className: getClassName26("controls"), children: (0, import_jsx_runtime41.jsx)(
          ViewportControls,
          {
            autoZoom: zoomConfig.autoZoom,
            zoom: zoomConfig.zoom,
            onViewportChange: (viewport) => {
              setShowTransition(true);
              isResizingRef.current = true;
              const uiViewport = __spreadProps(__spreadValues({}, viewport), {
                height: viewport.height || "auto",
                zoom: zoomConfig.zoom
              });
              const newUi = {
                viewports: __spreadProps(__spreadValues({}, viewports), { current: uiViewport }),
                itemSelector: null
              };
              setUi(newUi);
              if (ZOOM_ON_CHANGE) {
                resetAutoZoom({
                  viewports: __spreadProps(__spreadValues({}, viewports), { current: uiViewport })
                });
              }
            },
            onZoom: (zoom) => {
              setShowTransition(true);
              isResizingRef.current = true;
              setZoomConfig(__spreadProps(__spreadValues({}, zoomConfig), { zoom }));
            }
          }
        ) }),
        (0, import_jsx_runtime41.jsxs)("div", { className: getClassName26("inner"), ref: frameRef, children: [
          (0, import_jsx_runtime41.jsx)(
            "div",
            {
              className: getClassName26("root"),
              style: {
                width: iframe.enabled ? viewports.current.width : "100%",
                height: zoomConfig.rootHeight,
                transform: iframe.enabled ? `scale(${zoomConfig.zoom})` : void 0,
                transition: showTransition ? `width ${TRANSITION_DURATION}ms ease-out, height ${TRANSITION_DURATION}ms ease-out, transform ${TRANSITION_DURATION}ms ease-out` : "",
                overflow: iframe.enabled ? void 0 : "auto"
              },
              suppressHydrationWarning: true,
              id: "puck-canvas-root",
              onTransitionEnd: () => {
                setShowTransition(false);
                isResizingRef.current = false;
              },
              children: (0, import_jsx_runtime41.jsx)(CustomPreview, { children: (0, import_jsx_runtime41.jsx)(Preview2, {}) })
            }
          ),
          (0, import_jsx_runtime41.jsx)("div", { className: getClassName26("loader"), children: (0, import_jsx_runtime41.jsx)(Loader, { size: 24 }) })
        ] })
      ]
    }
  );
};
init_react_import();
init_react_import();
var loadOverrides = ({
  overrides,
  plugins
}) => {
  const collected = __spreadValues({}, overrides);
  plugins == null ? void 0 : plugins.forEach((plugin) => {
    if (!plugin.overrides)
      return;
    Object.keys(plugin.overrides).forEach((_overridesType) => {
      var _a5;
      const overridesType = _overridesType;
      if (!((_a5 = plugin.overrides) == null ? void 0 : _a5[overridesType]))
        return;
      if (overridesType === "fieldTypes") {
        const fieldTypes = plugin.overrides.fieldTypes;
        Object.keys(fieldTypes).forEach((fieldType) => {
          collected.fieldTypes = collected.fieldTypes || {};
          const childNode2 = collected.fieldTypes[fieldType];
          const Comp2 = (props) => fieldTypes[fieldType](__spreadProps(__spreadValues({}, props), {
            children: childNode2 ? childNode2(props) : props.children
          }));
          collected.fieldTypes[fieldType] = Comp2;
        });
        return;
      }
      const childNode = collected[overridesType];
      const Comp = (props) => plugin.overrides[overridesType](__spreadProps(__spreadValues({}, props), {
        children: childNode ? childNode(props) : props.children
      }));
      collected[overridesType] = Comp;
    });
  });
  return collected;
};
var useLoadedOverrides = ({
  overrides,
  plugins
}) => {
  return (0, import_react61.useMemo)(() => {
    return loadOverrides({ overrides, plugins });
  }, [plugins, overrides]);
};
init_react_import();
var DefaultOverride = ({ children }) => (0, import_jsx_runtime42.jsx)(import_jsx_runtime42.Fragment, { children });
init_react_import();
var styles = ``;
var useInjectStyleSheet = (initialStyles, iframeEnabled) => {
  const [el, setEl] = (0, import_react62.useState)();
  (0, import_react62.useEffect)(() => {
    setEl(document.createElement("style"));
  }, []);
  (0, import_react62.useEffect)(() => {
    var _a5;
    if (!el || typeof window === "undefined") {
      return;
    }
    el.innerHTML = initialStyles;
    if (iframeEnabled) {
      const frame = getFrame();
      (_a5 = frame == null ? void 0 : frame.head) == null ? void 0 : _a5.appendChild(el);
    }
    document.head.appendChild(el);
  }, [iframeEnabled, el]);
  return el;
};
var useInjectGlobalCss = (iframeEnabled) => {
  return useInjectStyleSheet(styles, iframeEnabled);
};
init_react_import();
var usePreviewModeHotkeys = () => {
  const appStore = useAppStoreApi();
  const toggleInteractive = (0, import_react63.useCallback)(() => {
    const dispatch = appStore.getState().dispatch;
    dispatch({
      type: "setUi",
      ui: (ui) => ({
        previewMode: ui.previewMode === "edit" ? "interactive" : "edit"
      })
    });
  }, [appStore]);
  useHotkey({ meta: true, i: true }, toggleInteractive);
  useHotkey({ ctrl: true, i: true }, toggleInteractive);
};
init_react_import();
init_react_import();
init_react_import();
var styles_module_default22 = { "MenuBar": "_MenuBar_8pf8c_1", "MenuBar--menuOpen": "_MenuBar--menuOpen_8pf8c_14", "MenuBar-inner": "_MenuBar-inner_8pf8c_29", "MenuBar-history": "_MenuBar-history_8pf8c_45" };
var getClassName27 = get_class_name_factory_default("MenuBar", styles_module_default22);
function MenuBar({
  menuOpen = false,
  renderHeaderActions,
  setMenuOpen
}) {
  const back = useAppStore((s2) => s2.history.back);
  const forward = useAppStore((s2) => s2.history.forward);
  const hasFuture = useAppStore((s2) => s2.history.hasFuture());
  const hasPast = useAppStore((s2) => s2.history.hasPast());
  return (0, import_jsx_runtime43.jsx)(
    "div",
    {
      className: getClassName27({ menuOpen }),
      onClick: (event) => {
        var _a5;
        const element = event.target;
        if (window.matchMedia("(min-width: 638px)").matches) {
          return;
        }
        if (element.tagName === "A" && ((_a5 = element.getAttribute("href")) == null ? void 0 : _a5.startsWith("#"))) {
          setMenuOpen(false);
        }
      },
      children: (0, import_jsx_runtime43.jsxs)("div", { className: getClassName27("inner"), children: [
        (0, import_jsx_runtime43.jsxs)("div", { className: getClassName27("history"), children: [
          (0, import_jsx_runtime43.jsx)(
            IconButton,
            {
              type: "button",
              title: "undo",
              disabled: !hasPast,
              onClick: back,
              children: (0, import_jsx_runtime43.jsx)(Undo2, { size: 21 })
            }
          ),
          (0, import_jsx_runtime43.jsx)(
            IconButton,
            {
              type: "button",
              title: "redo",
              disabled: !hasFuture,
              onClick: forward,
              children: (0, import_jsx_runtime43.jsx)(Redo2, { size: 21 })
            }
          )
        ] }),
        (0, import_jsx_runtime43.jsx)(import_jsx_runtime43.Fragment, { children: renderHeaderActions && renderHeaderActions() })
      ] })
    }
  );
}
init_react_import();
var styles_module_default23 = { "PuckHeader": "_PuckHeader_15xnq_1", "PuckHeader-inner": "_PuckHeader-inner_15xnq_10", "PuckHeader-toggle": "_PuckHeader-toggle_15xnq_20", "PuckHeader--rightSideBarVisible": "_PuckHeader--rightSideBarVisible_15xnq_27", "PuckHeader-rightSideBarToggle": "_PuckHeader-rightSideBarToggle_15xnq_27", "PuckHeader--leftSideBarVisible": "_PuckHeader--leftSideBarVisible_15xnq_28", "PuckHeader-leftSideBarToggle": "_PuckHeader-leftSideBarToggle_15xnq_28", "PuckHeader-title": "_PuckHeader-title_15xnq_32", "PuckHeader-path": "_PuckHeader-path_15xnq_36", "PuckHeader-tools": "_PuckHeader-tools_15xnq_43", "PuckHeader-menuButton": "_PuckHeader-menuButton_15xnq_49", "PuckHeader--menuOpen": "_PuckHeader--menuOpen_15xnq_54" };
var getClassName28 = get_class_name_factory_default("PuckHeader", styles_module_default23);
var HeaderInner = () => {
  const {
    onPublish,
    renderHeader,
    renderHeaderActions,
    headerTitle,
    headerPath,
    iframe: _iframe
  } = usePropsContext();
  const dispatch = useAppStore((s2) => s2.dispatch);
  const appStore = useAppStoreApi();
  const defaultHeaderRender = (0, import_react64.useMemo)(() => {
    if (renderHeader) {
      console.warn(
        "`renderHeader` is deprecated. Please use `overrides.header` and the `usePuck` hook instead"
      );
      const RenderHeader = (_a5) => {
        var _b3 = _a5, { actions } = _b3, props = __objRest(_b3, ["actions"]);
        const Comp = renderHeader;
        const appState = useAppStore((s2) => s2.state);
        return (0, import_jsx_runtime44.jsx)(Comp, __spreadProps(__spreadValues({}, props), { dispatch, state: appState, children: actions }));
      };
      return RenderHeader;
    }
    return DefaultOverride;
  }, [renderHeader]);
  const defaultHeaderActionsRender = (0, import_react64.useMemo)(() => {
    if (renderHeaderActions) {
      console.warn(
        "`renderHeaderActions` is deprecated. Please use `overrides.headerActions` and the `usePuck` hook instead."
      );
      const RenderHeader = (props) => {
        const Comp = renderHeaderActions;
        const appState = useAppStore((s2) => s2.state);
        return (0, import_jsx_runtime44.jsx)(Comp, __spreadProps(__spreadValues({}, props), { dispatch, state: appState }));
      };
      return RenderHeader;
    }
    return DefaultOverride;
  }, [renderHeaderActions]);
  const CustomHeader = useAppStore(
    (s2) => s2.overrides.header || defaultHeaderRender
  );
  const CustomHeaderActions = useAppStore(
    (s2) => s2.overrides.headerActions || defaultHeaderActionsRender
  );
  const [menuOpen, setMenuOpen] = (0, import_react64.useState)(false);
  const rootTitle = useAppStore((s2) => {
    var _a5, _b3;
    const rootData = (_a5 = s2.state.indexes.nodes["root"]) == null ? void 0 : _a5.data;
    return (_b3 = rootData.props.title) != null ? _b3 : "";
  });
  const leftSideBarVisible = useAppStore((s2) => s2.state.ui.leftSideBarVisible);
  const rightSideBarVisible = useAppStore(
    (s2) => s2.state.ui.rightSideBarVisible
  );
  const toggleSidebars = (0, import_react64.useCallback)(
    (sidebar) => {
      const widerViewport = window.matchMedia("(min-width: 638px)").matches;
      const sideBarVisible = sidebar === "left" ? leftSideBarVisible : rightSideBarVisible;
      const oppositeSideBar = sidebar === "left" ? "rightSideBarVisible" : "leftSideBarVisible";
      dispatch({
        type: "setUi",
        ui: __spreadValues({
          [`${sidebar}SideBarVisible`]: !sideBarVisible
        }, !widerViewport ? { [oppositeSideBar]: false } : {})
      });
    },
    [dispatch, leftSideBarVisible, rightSideBarVisible]
  );
  return (0, import_jsx_runtime44.jsx)(
    CustomHeader,
    {
      actions: (0, import_jsx_runtime44.jsx)(import_jsx_runtime44.Fragment, { children: (0, import_jsx_runtime44.jsx)(CustomHeaderActions, { children: (0, import_jsx_runtime44.jsx)(
        Button,
        {
          onClick: () => {
            const data = appStore.getState().state.data;
            onPublish && onPublish(data);
          },
          icon: (0, import_jsx_runtime44.jsx)(Globe, { size: "14px" }),
          children: "Publish"
        }
      ) }) }),
      children: (0, import_jsx_runtime44.jsx)(
        "header",
        {
          className: getClassName28({ leftSideBarVisible, rightSideBarVisible }),
          children: (0, import_jsx_runtime44.jsxs)("div", { className: getClassName28("inner"), children: [
            (0, import_jsx_runtime44.jsxs)("div", { className: getClassName28("toggle"), children: [
              (0, import_jsx_runtime44.jsx)("div", { className: getClassName28("leftSideBarToggle"), children: (0, import_jsx_runtime44.jsx)(
                IconButton,
                {
                  type: "button",
                  onClick: () => {
                    toggleSidebars("left");
                  },
                  title: "Toggle left sidebar",
                  children: (0, import_jsx_runtime44.jsx)(PanelLeft, { focusable: "false" })
                }
              ) }),
              (0, import_jsx_runtime44.jsx)("div", { className: getClassName28("rightSideBarToggle"), children: (0, import_jsx_runtime44.jsx)(
                IconButton,
                {
                  type: "button",
                  onClick: () => {
                    toggleSidebars("right");
                  },
                  title: "Toggle right sidebar",
                  children: (0, import_jsx_runtime44.jsx)(PanelRight, { focusable: "false" })
                }
              ) })
            ] }),
            (0, import_jsx_runtime44.jsx)("div", { className: getClassName28("title"), children: (0, import_jsx_runtime44.jsxs)(Heading, { rank: "2", size: "xs", children: [
              headerTitle || rootTitle || "Page",
              headerPath && (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [
                " ",
                (0, import_jsx_runtime44.jsx)("code", { className: getClassName28("path"), children: headerPath })
              ] })
            ] }) }),
            (0, import_jsx_runtime44.jsxs)("div", { className: getClassName28("tools"), children: [
              (0, import_jsx_runtime44.jsx)("div", { className: getClassName28("menuButton"), children: (0, import_jsx_runtime44.jsx)(
                IconButton,
                {
                  type: "button",
                  onClick: () => {
                    return setMenuOpen(!menuOpen);
                  },
                  title: "Toggle menu bar",
                  children: menuOpen ? (0, import_jsx_runtime44.jsx)(ChevronUp, { focusable: "false" }) : (0, import_jsx_runtime44.jsx)(ChevronDown, { focusable: "false" })
                }
              ) }),
              (0, import_jsx_runtime44.jsx)(
                MenuBar,
                {
                  dispatch,
                  onPublish,
                  menuOpen,
                  renderHeaderActions: () => (0, import_jsx_runtime44.jsx)(CustomHeaderActions, { children: (0, import_jsx_runtime44.jsx)(
                    Button,
                    {
                      onClick: () => {
                        const data = appStore.getState().state.data;
                        onPublish && onPublish(data);
                      },
                      icon: (0, import_jsx_runtime44.jsx)(Globe, { size: "14px" }),
                      children: "Publish"
                    }
                  ) }),
                  setMenuOpen
                }
              )
            ] })
          ] })
        }
      )
    }
  );
};
var Header = (0, import_react64.memo)(HeaderInner);
init_react_import();
init_react_import();
init_react_import();
var styles_module_default24 = { "ResizeHandle": "_ResizeHandle_144bf_2", "ResizeHandle--left": "_ResizeHandle--left_144bf_16", "ResizeHandle--right": "_ResizeHandle--right_144bf_20" };
var getClassName29 = get_class_name_factory_default("ResizeHandle", styles_module_default24);
var ResizeHandle = ({
  position,
  sidebarRef,
  onResize,
  onResizeEnd
}) => {
  const { frameRef } = useCanvasFrame();
  const resetAutoZoom = useResetAutoZoom(frameRef);
  const handleRef = (0, import_react65.useRef)(null);
  const isDragging = (0, import_react65.useRef)(false);
  const startX = (0, import_react65.useRef)(0);
  const startWidth = (0, import_react65.useRef)(0);
  const handleMouseMove = (0, import_react65.useCallback)(
    (e3) => {
      if (!isDragging.current)
        return;
      const delta = e3.clientX - startX.current;
      const newWidth = position === "left" ? startWidth.current + delta : startWidth.current - delta;
      const width = Math.max(192, newWidth);
      onResize(width);
      e3.preventDefault();
    },
    [onResize, position]
  );
  const handleMouseUp = (0, import_react65.useCallback)(() => {
    var _a5;
    if (!isDragging.current)
      return;
    isDragging.current = false;
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
    const overlay = document.getElementById("resize-overlay");
    if (overlay) {
      document.body.removeChild(overlay);
    }
    document.removeEventListener("mousemove", handleMouseMove);
    document.removeEventListener("mouseup", handleMouseUp);
    const finalWidth = ((_a5 = sidebarRef.current) == null ? void 0 : _a5.getBoundingClientRect().width) || 0;
    onResizeEnd(finalWidth);
    resetAutoZoom();
  }, [onResizeEnd]);
  const handleMouseDown = (0, import_react65.useCallback)(
    (e3) => {
      var _a5;
      isDragging.current = true;
      startX.current = e3.clientX;
      startWidth.current = ((_a5 = sidebarRef.current) == null ? void 0 : _a5.getBoundingClientRect().width) || 0;
      document.body.style.cursor = "col-resize";
      document.body.style.userSelect = "none";
      const overlay = document.createElement("div");
      overlay.id = "resize-overlay";
      overlay.setAttribute("data-resize-overlay", "");
      document.body.appendChild(overlay);
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      e3.preventDefault();
    },
    [position, handleMouseMove, handleMouseUp]
  );
  return (0, import_jsx_runtime45.jsx)(
    "div",
    {
      ref: handleRef,
      className: getClassName29({ [position]: true }),
      onMouseDown: handleMouseDown
    }
  );
};
init_react_import();
var styles_module_default25 = { "Sidebar": "_Sidebar_1xksb_1", "Sidebar--left": "_Sidebar--left_1xksb_8", "Sidebar--right": "_Sidebar--right_1xksb_14", "Sidebar-resizeHandle": "_Sidebar-resizeHandle_1xksb_20" };
var getClassName30 = get_class_name_factory_default("Sidebar", styles_module_default25);
var Sidebar = ({
  position,
  sidebarRef,
  isVisible: isVisible2,
  onResize,
  onResizeEnd,
  children
}) => {
  if (!isVisible2)
    return null;
  return (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
    (0, import_jsx_runtime46.jsx)("div", { ref: sidebarRef, className: getClassName30({ [position]: true }), children }),
    (0, import_jsx_runtime46.jsx)("div", { className: `${getClassName30("resizeHandle")}`, children: (0, import_jsx_runtime46.jsx)(
      ResizeHandle,
      {
        position,
        sidebarRef,
        onResize,
        onResizeEnd
      }
    ) })
  ] });
};
init_react_import();
function useSidebarResize(position, dispatch) {
  const [width, setWidth] = (0, import_react66.useState)(null);
  const sidebarRef = (0, import_react66.useRef)(null);
  const storeWidth = useAppStore(
    (s2) => position === "left" ? s2.state.ui.leftSideBarWidth : s2.state.ui.rightSideBarWidth
  );
  (0, import_react66.useEffect)(() => {
    if (typeof window !== "undefined" && !storeWidth) {
      try {
        const savedWidths = localStorage.getItem("puck-sidebar-widths");
        if (savedWidths) {
          const widths = JSON.parse(savedWidths);
          const savedWidth = widths[position];
          const key = position === "left" ? "leftSideBarWidth" : "rightSideBarWidth";
          if (savedWidth) {
            dispatch({
              type: "setUi",
              ui: {
                [key]: savedWidth
              }
            });
          }
        }
      } catch (error) {
        console.error(
          `Failed to load ${position} sidebar width from localStorage`,
          error
        );
      }
    }
  }, [dispatch, position, storeWidth]);
  (0, import_react66.useEffect)(() => {
    if (storeWidth !== void 0) {
      setWidth(storeWidth);
    }
  }, [storeWidth]);
  const handleResizeEnd = (0, import_react66.useCallback)(
    (width2) => {
      dispatch({
        type: "setUi",
        ui: {
          [position === "left" ? "leftSideBarWidth" : "rightSideBarWidth"]: width2
        }
      });
      let widths = {};
      try {
        const savedWidths = localStorage.getItem("puck-sidebar-widths");
        widths = savedWidths ? JSON.parse(savedWidths) : {};
      } catch (error) {
        console.error(
          `Failed to save ${position} sidebar width to localStorage`,
          error
        );
      } finally {
        localStorage.setItem(
          "puck-sidebar-widths",
          JSON.stringify(__spreadProps(__spreadValues({}, widths), {
            [position]: width2
          }))
        );
      }
      window.dispatchEvent(
        new CustomEvent("viewportchange", {
          bubbles: true,
          cancelable: false
        })
      );
    },
    [dispatch, position]
  );
  return {
    width,
    setWidth,
    sidebarRef,
    handleResizeEnd
  };
}
var getClassName31 = get_class_name_factory_default("Puck", styles_module_default15);
var getLayoutClassName = get_class_name_factory_default("PuckLayout", styles_module_default15);
var FieldSideBar = () => {
  const title = useAppStore(
    (s2) => {
      var _a5, _b3;
      return s2.selectedItem ? (_b3 = (_a5 = s2.config.components[s2.selectedItem.type]) == null ? void 0 : _a5["label"]) != null ? _b3 : s2.selectedItem.type.toString() : "Page";
    }
  );
  return (0, import_jsx_runtime47.jsx)(SidebarSection, { noPadding: true, noBorderTop: true, showBreadcrumbs: true, title, children: (0, import_jsx_runtime47.jsx)(Fields, {}) });
};
var propsContext = (0, import_react48.createContext)({});
function PropsProvider(props) {
  return (0, import_jsx_runtime47.jsx)(propsContext.Provider, { value: props, children: props.children });
}
var usePropsContext = () => (0, import_react48.useContext)(propsContext);
function PuckProvider({ children }) {
  const {
    config,
    data: initialData,
    ui: initialUi,
    onChange,
    permissions = {},
    plugins,
    overrides,
    viewports = defaultViewports,
    iframe: _iframe,
    initialHistory: _initialHistory,
    metadata,
    onAction,
    fieldTransforms
  } = usePropsContext();
  const iframe = (0, import_react48.useMemo)(
    () => __spreadValues({
      enabled: true,
      waitForStyles: true
    }, _iframe),
    [_iframe]
  );
  const [generatedAppState] = (0, import_react48.useState)(() => {
    var _a5, _b3, _c4, _d2, _e, _f, _g, _h, _i;
    const initial = __spreadValues(__spreadValues({}, defaultAppState.ui), initialUi);
    let clientUiState = {};
    if (typeof window !== "undefined") {
      if (window.matchMedia("(max-width: 638px)").matches) {
        clientUiState = __spreadProps(__spreadValues({}, clientUiState), {
          leftSideBarVisible: false,
          rightSideBarVisible: false
        });
      }
      const viewportWidth = window.innerWidth;
      const viewportDifferences = Object.entries(viewports).map(([key, value]) => ({
        key,
        diff: Math.abs(viewportWidth - value.width)
      })).sort((a2, b2) => a2.diff > b2.diff ? 1 : -1);
      const closestViewport = viewportDifferences[0].key;
      if (iframe.enabled) {
        clientUiState = __spreadProps(__spreadValues({}, clientUiState), {
          viewports: __spreadProps(__spreadValues({}, initial.viewports), {
            current: __spreadProps(__spreadValues({}, initial.viewports.current), {
              height: ((_b3 = (_a5 = initialUi == null ? void 0 : initialUi.viewports) == null ? void 0 : _a5.current) == null ? void 0 : _b3.height) || ((_c4 = viewports[closestViewport]) == null ? void 0 : _c4.height) || "auto",
              width: ((_e = (_d2 = initialUi == null ? void 0 : initialUi.viewports) == null ? void 0 : _d2.current) == null ? void 0 : _e.width) || ((_f = viewports[closestViewport]) == null ? void 0 : _f.width)
            })
          })
        });
      }
    }
    if (Object.keys((initialData == null ? void 0 : initialData.root) || {}).length > 0 && !((_g = initialData == null ? void 0 : initialData.root) == null ? void 0 : _g.props)) {
      console.warn(
        "Warning: Defining props on `root` is deprecated. Please use `root.props`, or republish this page to migrate automatically."
      );
    }
    const rootProps = ((_h = initialData == null ? void 0 : initialData.root) == null ? void 0 : _h.props) || (initialData == null ? void 0 : initialData.root) || {};
    const defaultedRootProps = __spreadValues(__spreadValues({}, (_i = config.root) == null ? void 0 : _i.defaultProps), rootProps);
    const newAppState = __spreadProps(__spreadValues({}, defaultAppState), {
      data: __spreadProps(__spreadValues({}, initialData), {
        root: __spreadProps(__spreadValues({}, initialData == null ? void 0 : initialData.root), { props: defaultedRootProps }),
        content: initialData.content || []
      }),
      ui: __spreadProps(__spreadValues(__spreadValues({}, initial), clientUiState), {
        // Store categories under componentList on state to allow render functions and plugins to modify
        componentList: config.categories ? Object.entries(config.categories).reduce(
          (acc, [categoryName, category]) => {
            return __spreadProps(__spreadValues({}, acc), {
              [categoryName]: {
                title: category.title,
                components: category.components,
                expanded: category.defaultExpanded,
                visible: category.visible
              }
            });
          },
          {}
        ) : {}
      })
    });
    return walkAppState(newAppState, config);
  });
  const { appendData = true } = _initialHistory || {};
  const [blendedHistories] = (0, import_react48.useState)(
    [
      ...(_initialHistory == null ? void 0 : _initialHistory.histories) || [],
      ...appendData ? [{ state: generatedAppState }] : []
    ].map((history) => {
      let newState = __spreadValues(__spreadValues({}, generatedAppState), history.state);
      if (!history.state.indexes) {
        newState = walkAppState(newState, config);
      }
      return __spreadProps(__spreadValues({}, history), {
        state: newState
      });
    })
  );
  const initialHistoryIndex = (_initialHistory == null ? void 0 : _initialHistory.index) || blendedHistories.length - 1;
  const initialAppState = blendedHistories[initialHistoryIndex].state;
  const loadedOverrides = useLoadedOverrides({
    overrides,
    plugins
  });
  const loadedFieldTransforms = (0, import_react48.useMemo)(() => {
    const _plugins = plugins || [];
    const pluginFieldTransforms = _plugins.reduce(
      (acc, plugin) => __spreadValues(__spreadValues({}, acc), plugin.fieldTransforms),
      {}
    );
    return __spreadValues(__spreadValues({}, pluginFieldTransforms), fieldTransforms);
  }, [fieldTransforms, plugins]);
  const generateAppStore = (0, import_react48.useCallback)(
    (state) => {
      return {
        state,
        config,
        plugins: plugins || [],
        overrides: loadedOverrides,
        viewports,
        iframe,
        onAction,
        metadata,
        fieldTransforms: loadedFieldTransforms
      };
    },
    [
      initialAppState,
      config,
      plugins,
      loadedOverrides,
      viewports,
      iframe,
      onAction,
      metadata,
      loadedFieldTransforms
    ]
  );
  const [appStore] = (0, import_react48.useState)(
    () => createAppStore(generateAppStore(initialAppState))
  );
  (0, import_react48.useEffect)(() => {
    if (true) {
      window.__PUCK_INTERNAL_DO_NOT_USE = { appStore };
    }
  }, [appStore]);
  (0, import_react48.useEffect)(() => {
    const state = appStore.getState().state;
    appStore.setState(__spreadValues({}, generateAppStore(state)));
  }, [config, plugins, loadedOverrides, viewports, iframe, onAction, metadata]);
  useRegisterHistorySlice(appStore, {
    histories: blendedHistories,
    index: initialHistoryIndex,
    initialAppState
  });
  const previousData = (0, import_react48.useRef)(null);
  (0, import_react48.useEffect)(() => {
    appStore.subscribe(
      (s2) => s2.state.data,
      (data) => {
        if (onChange) {
          if ((0, import_fast_deep_equal3.default)(data, previousData.current))
            return;
          onChange(data);
          previousData.current = data;
        }
      }
    );
  }, []);
  useRegisterPermissionsSlice(appStore, permissions);
  const uPuckStore = useRegisterUsePuckStore(appStore);
  (0, import_react48.useEffect)(() => {
    const { resolveAndCommitData } = appStore.getState();
    resolveAndCommitData();
  }, []);
  return (0, import_jsx_runtime47.jsx)(appStoreContext.Provider, { value: appStore, children: (0, import_jsx_runtime47.jsx)(UsePuckStoreContext.Provider, { value: uPuckStore, children }) });
}
function PuckLayout({ children }) {
  const {
    iframe: _iframe,
    dnd,
    initialHistory: _initialHistory
  } = usePropsContext();
  const iframe = (0, import_react48.useMemo)(
    () => __spreadValues({
      enabled: true,
      waitForStyles: true
    }, _iframe),
    [_iframe]
  );
  useInjectGlobalCss(iframe.enabled);
  const dispatch = useAppStore((s2) => s2.dispatch);
  const leftSideBarVisible = useAppStore((s2) => s2.state.ui.leftSideBarVisible);
  const rightSideBarVisible = useAppStore(
    (s2) => s2.state.ui.rightSideBarVisible
  );
  const {
    width: leftWidth,
    setWidth: setLeftWidth,
    sidebarRef: leftSidebarRef,
    handleResizeEnd: handleLeftSidebarResizeEnd
  } = useSidebarResize("left", dispatch);
  const {
    width: rightWidth,
    setWidth: setRightWidth,
    sidebarRef: rightSidebarRef,
    handleResizeEnd: handleRightSidebarResizeEnd
  } = useSidebarResize("right", dispatch);
  (0, import_react48.useEffect)(() => {
    if (!window.matchMedia("(min-width: 638px)").matches) {
      dispatch({
        type: "setUi",
        ui: {
          leftSideBarVisible: false,
          rightSideBarVisible: false
        }
      });
    }
    const handleResize = () => {
      if (!window.matchMedia("(min-width: 638px)").matches) {
        dispatch({
          type: "setUi",
          ui: (ui) => __spreadValues(__spreadValues({}, ui), ui.rightSideBarVisible ? { leftSideBarVisible: false } : {})
        });
      }
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  const overrides = useAppStore((s2) => s2.overrides);
  const CustomPuck = (0, import_react48.useMemo)(
    () => overrides.puck || DefaultOverride,
    [overrides]
  );
  const [mounted, setMounted] = (0, import_react48.useState)(false);
  (0, import_react48.useEffect)(() => {
    setMounted(true);
  }, []);
  const ready = useAppStore((s2) => s2.status === "READY");
  useMonitorHotkeys();
  (0, import_react48.useEffect)(() => {
    if (ready && iframe.enabled) {
      const frameDoc = getFrame();
      if (frameDoc) {
        return monitorHotkeys(frameDoc);
      }
    }
  }, [ready, iframe.enabled]);
  usePreviewModeHotkeys();
  const layoutOptions = {};
  if (leftWidth) {
    layoutOptions["--puck-user-left-side-bar-width"] = `${leftWidth}px`;
  }
  if (rightWidth) {
    layoutOptions["--puck-user-right-side-bar-width"] = `${rightWidth}px`;
  }
  return (0, import_jsx_runtime47.jsxs)("div", { className: `Puck ${getClassName31()}`, children: [
    (0, import_jsx_runtime47.jsx)(DragDropContext2, { disableAutoScroll: dnd == null ? void 0 : dnd.disableAutoScroll, children: (0, import_jsx_runtime47.jsx)(CustomPuck, { children: children || (0, import_jsx_runtime47.jsx)(FrameProvider, { children: (0, import_jsx_runtime47.jsx)(
      "div",
      {
        className: getLayoutClassName({
          leftSideBarVisible,
          mounted,
          rightSideBarVisible
        }),
        children: (0, import_jsx_runtime47.jsxs)(
          "div",
          {
            className: getLayoutClassName("inner"),
            style: layoutOptions,
            children: [
              (0, import_jsx_runtime47.jsx)(Header, {}),
              (0, import_jsx_runtime47.jsxs)(
                Sidebar,
                {
                  position: "left",
                  sidebarRef: leftSidebarRef,
                  isVisible: leftSideBarVisible,
                  onResize: setLeftWidth,
                  onResizeEnd: handleLeftSidebarResizeEnd,
                  children: [
                    (0, import_jsx_runtime47.jsx)(SidebarSection, { title: "Components", noBorderTop: true, children: (0, import_jsx_runtime47.jsx)(Components, {}) }),
                    (0, import_jsx_runtime47.jsx)(SidebarSection, { title: "Outline", children: (0, import_jsx_runtime47.jsx)(Outline, {}) })
                  ]
                }
              ),
              (0, import_jsx_runtime47.jsx)(Canvas, {}),
              (0, import_jsx_runtime47.jsx)(
                Sidebar,
                {
                  position: "right",
                  sidebarRef: rightSidebarRef,
                  isVisible: rightSideBarVisible,
                  onResize: setRightWidth,
                  onResizeEnd: handleRightSidebarResizeEnd,
                  children: (0, import_jsx_runtime47.jsx)(FieldSideBar, {})
                }
              )
            ]
          }
        )
      }
    ) }) }) }),
    (0, import_jsx_runtime47.jsx)("div", { id: "puck-portal-root", className: getClassName31("portal") })
  ] });
}
function Puck(props) {
  return (0, import_jsx_runtime47.jsx)(PropsProvider, __spreadProps(__spreadValues({}, props), { children: (0, import_jsx_runtime47.jsx)(PuckProvider, __spreadProps(__spreadValues({}, props), { children: (0, import_jsx_runtime47.jsx)(PuckLayout, __spreadValues({}, props)) })) }));
}
Puck.Components = Components;
Puck.Fields = Fields;
Puck.Outline = Outline;
Puck.Preview = Preview2;
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();
init_react_import();

// node_modules/@measured/puck/dist/index.mjs
init_react_import();
export {
  Action,
  ActionBar,
  AutoField,
  Button,
  Drawer,
  DropZone,
  FieldLabel,
  Group,
  IconButton,
  Label,
  Puck,
  Render,
  createUsePuck,
  migrate,
  overrideKeys,
  registerOverlayPortal,
  renderContext,
  resolveAllData,
  setDeep,
  transformProps,
  useGetPuck,
  usePuck,
  walkTree
};
/*! Bundled license information:

@measured/puck/dist/chunk-V7Y7BFEC.mjs:
  (*! Bundled license information:
  
  classnames/index.js:
    (*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    *)
  
  lucide-react/dist/esm/shared/src/utils.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/defaultAttributes.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/Icon.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/createLucideIcon.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/chevron-down.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/chevron-right.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/chevron-up.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/circle-check-big.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/copy.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/corner-left-up.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/ellipsis-vertical.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/globe.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/hash.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/layers.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/layout-grid.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/link.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/list.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/lock-open.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/lock.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/monitor.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/panel-left.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/panel-right.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/plus.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/redo-2.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/search.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/sliders-horizontal.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/smartphone.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/tablet.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/trash.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/type.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/undo-2.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/zoom-in.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/icons/zoom-out.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  
  lucide-react/dist/esm/lucide-react.js:
    (**
     * @license lucide-react v0.468.0 - ISC
     *
     * This source code is licensed under the ISC license.
     * See the LICENSE file in the root directory of this source tree.
     *)
  *)
*/
//# sourceMappingURL=@measured_puck.js.map
